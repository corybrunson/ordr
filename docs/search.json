[{"path":"/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute opening issues (including questions, bugs, feature requests), updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience fluency, contribution history, social status, age, gender identity expression, sexual orientation, visible invisible disability, personal appearance, body size, ethnic racial identity perception, cultural religious background identity. Examples unacceptable behavior participants include use sexual language imagery, derogatory derisive comments, personal attacks, trolling, public private harassment insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, issues, contributions inconsistent Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances behavior inconsistent Code Conduct may reported opening issue contacting one project maintainers. Code Conduct adapted (changes) Contributor Covenant, version 1.0.0, available https://www.contributor-covenant.org/version/1/0/0/code--conduct.html","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to ordr development","title":"Contributing to ordr development","text":"goal guide help contributors ordr plan contributions navigate process. sections cover different types contributions, usually increasing degrees proposed change. Note ordr released Contributor Code Conduct. contributing, agree terms. guide copied ggalluvial, loosely adapted contributing guides ggplot2 ropensci. questions suggestions guide, please feel free contact package maintainer.","code":""},{"path":"/CONTRIBUTING.html","id":"editor","dir":"","previous_headings":"","what":"Editor","title":"Contributing to ordr development","text":"Small edits comments, documentation, non-code files may made using GitHub file editor. edit roxygen2 documentation, make changes source file R/<topic>.r, line begins #', rather documentation file man/<topic>.Rd. guidance roxygen2 documentation, see chapter online book R packages.","code":""},{"path":"/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contributing to ordr development","text":"Questions, possible bugs, feature requests, open-ended issues may raised issues GitHub. cases, issue consist two sections: description issue, reproducible example . reproducible example attach packages, include data, execute code: Attach relevant packages top example. Use small data set can conveniently get illustrates issue. data set, best way include example re-create using data.frame() constructor function. Another way follows: Execute dput(data) R, data data set. Copy output. Paste example package attachments. Use lines steps code feasible illustrate issue. Add comments key steps. guidance reproducible examples, see vignette reprex package.","code":""},{"path":"/CONTRIBUTING.html","id":"pull-requests","dir":"","previous_headings":"","what":"Pull requests","title":"Contributing to ordr development","text":"Bug fixes, feature upgrades, substantive, self-contained changes may contributed via pull request. Unless previously discussed maintainer, please follow steps: Fork home repository (corybrunson/ordr). Create new (local) branch make changes. appropriate, update documentation branch run functionality checks (e.g. using devtools package). Push branch fork open pull request home repository. maintainer(s), discuss (necessary) update pull request accepted decided . latter case, clear consistent reason provided maintainer(s). guidance pull request process, see contributing guidelines ggplot2.","code":""},{"path":"/articles/cmds-variables.html","id":"dimension-reduction-of-geometric-data","dir":"Articles","previous_headings":"","what":"dimension reduction of geometric data","title":"multidimensional scaling of variables","text":"ordination grounded geometric data analysis, easiest straightforward naturally geometric data. example, mineral compositional measurements analyzed Freestone, Gorin–Rosen, Hughes (2000) consists five primary (several secondary) concentrations 68 artifacts. variables lie (percentage) scale, vary different absolute rates; order represent cases (artifacts) geometrically might separately center scale . basic ordination method, principal components analysis (PCA), computes singular value decomposition \\(X = U D V^\\top\\) centered scaled data matrix \\(X \\\\mathbb{R}^{n\\times p}\\): matrix factors \\(U \\\\mathbb{R}^{n\\times r}\\) \\(V \\\\mathbb{R}^{p\\times r}\\) arise eigendecompositions \\(X X^\\top\\) \\(X^\\top X\\), respectively, set eigenvalues \\(\\lambda_1,\\ldots,\\lambda_r\\). square roots eigenvalues make diagonal matrix \\(D \\\\mathbb{R}^{r\\times r}\\). conventional PCA biplot uses principal coordinates cases, given rows \\(U D\\), standardized coordinates variables, given rows \\(V\\). columns \\(U = \\left[\\,u_1\\,\\cdots\\,u_r\\,\\right]\\) \\(V = \\left[\\,v_1\\,\\cdots\\,v_r\\,\\right]\\) comprise eigenvectors \\(X X^\\top\\) \\(X^\\top X\\). orthonormal, means \\(U^\\top U = I_r = V^\\top V\\) total variance (called inertia) matrix \\(\\sum_{j=1}^{r}{ {v_j}^2 } = r = \\sum_{j=1}^{r}{ {v_j}^2 }\\). Meanwhile, diagonal \\(D\\) contains inertia centered scaled data matrix \\(X\\): (2-dimensional, .e. planar) biplot, inertia conferred cases (converting standardized coordinates principal coordinates) planar distances points plot representing cases approximately equal Euclidean distances \\(X\\). biplot accommodates two principal components (projection onto subset orthogonal coordinates), planar distances underestimate true distances. scatterplot true distances biplot approximations:  contrast, variables better understood correlations, approximately preserved standardized coordinates. Writing \\(X = [\\,y_1\\,\\cdots\\,y_m\\,]\\) array column variables, covariance \\(y_i\\) \\(y_j\\) proportional inner product \\[\\textstyle \\operatorname{cov}(y_i,y_j) = \\frac{1}{n} y_i \\cdot y_j = \\frac{1}{n} \\lVert y_i\\rVert\\lVert y_j\\rVert\\cos\\theta_{ij}\\text,\\] cosine angle \\(\\theta_{ij}\\) equals correlation: \\[\\cos\\theta_{ij} = \\frac{\\operatorname{cov}(y_i,y_j)}{\\sqrt{\\operatorname{cov}(y_i,y_i)\\operatorname{cov}(y_j,y_j)}/n} = \\frac{\\operatorname{cov}(y_i,y_j)}{\\sigma_i\\sigma_j} = r_{ij}\\] cosines vectors biplot plotted variable correlations \\(r_{ij}\\) centered scaled data. vectors shorter biplot reason distances shorter, consines may larger smaller depending respective coordinates remaining coordinates.","code":"data(glass, package = \"ordr\") x <- scale(glass[, c(\"SiO2\", \"Al2O3\", \"FeO\", \"MgO\", \"CaO\")],            center = TRUE, scale = TRUE) s <- svd(x) r <- length(s$d) # inertia of the (scaled) data sum(x^2) ## [1] 335 # inertia of the case and variable factors sum(s$u^2) ## [1] 5 sum(s$v^2) ## [1] 5 # inertia of the diagonal factor sum(s$d^2) ## [1] 335 # distances between cases x.dist <- dist(x) # distances between cases (principal coordinates) s.dist <- dist(s$u[, 1:2] %*% diag(s$d[1:2])) # scatterplot plot(   x = as.vector(x.dist),   y = as.vector(s.dist),   xlim = c(0, 10), ylim = c(0, 10),   asp = 1, pch = 19, cex = .5,   xlab = \"Case distances in centered and scaled data\",   ylab = \"Case point distances in planar biplot\" ) lines(x = c(0, 10), y = c(0, 10)) # correlations between variables x.cor <- cor(x) # magnitudes of variable vectors s.len <- apply(s$v[, 1:2] %*% diag(s$d[1:2]), 1, norm, \"2\") # cosines between variables (principal coordinates) s.cor <- (s$v[, 1:2] / s.len) %*% diag(s$d[1:2]^2) %*% t(s$v[, 1:2] / s.len) # scatterplot plot(   x = as.vector(x.cor[lower.tri(x.cor)]),   y = as.vector(s.cor[lower.tri(s.cor)]),   xlim = c(-1, 1), ylim = c(-1, 1),   asp = 1, pch = 19, cex = .5,   xlab = \"Variable correlations in centered and scaled data\",   ylab = \"Variable vector cosines in planar biplot\" ) lines(x = c(-1, 1), y = c(-1, 1))"},{"path":"/articles/cmds-variables.html","id":"multidimensional-scaling-of-distance-data","dir":"Articles","previous_headings":"","what":"multidimensional scaling of distance data","title":"multidimensional scaling of variables","text":"faithful approximation inter-case distances principal coordinates idea behind classical multidimensional scaling (CMDS), can applied data set distances \\(\\delta_{ij},\\ 1\\leq \\leq j\\leq n\\) absence coordinates (variables). CMDS produces set artificial coordinates cases yield nested best approximations inter-case distances terms sum squared errors. technique uses eigendecomposition doubly-centered matrix squared distances, produces matrix \\(U \\Lambda^{1/2}\\) whose first \\(r\\) coordinates—\\(r\\leq n\\)—minimize variance \\((U \\Lambda^{1/2}) (U \\Lambda^{1/2})^\\top - \\Delta = U \\Lambda U^\\top - \\Delta\\), \\(\\Delta = (\\delta_{ij}) \\\\mathbb{R}^{n\\times n}\\), obtain approximation. columns \\(U \\Lambda^{1/2}\\) called principal coordinates, first \\(r\\) faithfully recover \\(\\delta_{ij}\\) using points \\(\\mathbb{R}^r\\) possible \\(r\\). example, road distances several U.S. cities arise roughly 2-dimensional process, point distances CMDS close approximations:  practice, goal CMDS usually produce scatterplot distances \\(\\sqrt{(x_j-x_i)^2+(y_j-y_i)^2}\\) points represent \\(n\\) cases approximate original distances \\(\\delta_{ij}\\). case, artificial coordinates approximately recover geographic arrangement. chance, CMDS rotated conventional cardinal directions \\(\\pi\\) radians (though least map recognizable rather surface Earth):","code":"d <- as.matrix(UScitiesD) cent <- diag(1, nrow(d)) - matrix(1/nrow(d), nrow(d), nrow(d)) d.cent <- -.5 * cent %*% (d^2) %*% cent d.cmds <- svd(d.cent) d.coord <- d.cmds$u[, 1:2] %*% diag(sqrt(d.cmds$d[1:2])) # scatterplot plot(   x = as.vector(UScitiesD),   y = as.vector(dist(d.coord)),   xlim = c(0, max(UScitiesD)), ylim = c(0, max(UScitiesD)),   asp = 1, pch = 19, cex = .5,   xlab = \"City road distances\",   ylab = \"Point distances in planar CMDS\" ) lines(x = c(0, max(UScitiesD)), y = c(0, max(UScitiesD))) plot(   d.coord, pch = NA, asp = 1,   xlab = \"First principal coordinate\", ylab = \"Second principal coordinate\" ) text(d.coord, labels = rownames(d), cex = .9)"},{"path":"/articles/cmds-variables.html","id":"multidimensional-scaling-of-covariance-data","dir":"Articles","previous_headings":"","what":"multidimensional scaling of covariance data","title":"multidimensional scaling of variables","text":"faithful approximation inter-variable correlations angles coordinate vectors provides dual CMDS procedure. Suppose data consist distances cases covariances \\(\\operatorname{cov}(y_i,y_j),\\ 1\\leq \\leq j\\leq p\\) variables. data coordinate-free, PCA inapplicable. data derived (necessarily centered scaled) case–variable matrix \\(X\\), covariance matrix \\(C=(\\operatorname{cov}(y_i,y_j))\\) obtained \\(C=\\frac{1}{n}X^\\top X\\). , scalar, matrix whose eigenvectors given \\(V\\) SVD \\(X = U D V^\\top\\). Therefore, can obtain artificial coordinates variables approximate know geometry—thinking variables unknown vectors whose magnitudes angles encoded \\(C\\)—via eigendecomposition \\(C = V \\Lambda V^\\top\\): Take \\(Y = V \\Lambda^{1/2} \\\\mathbb{R}^{p\\times r}\\), \\(Y^\\top Y \\approx C\\). covariances unscaled glass measurements meaningful, can used validate technique. eigendecomposition intrinsically ordered variance, first \\(r\\) eigenvectors provide faithful \\(r\\)-dimensional approximation; ’ll take \\(r=2\\) anticipation biplot:  Thus, whereas CMDS cases approximates distances, CMDS variables approximates covariances. equips us analogous visualization technique correlation data: Represent variable \\(y_i\\) unit vector \\(\\hat{y}_i\\) way angle cosines \\(\\cos\\theta_{ij}\\) equal correlations \\(r_{ij}\\), project vectors onto plane variance maximized. exactly variables commonly represented row-principal PCA biplots, equivalence \\(V\\) SVD \\(X = U D V^\\top\\) \\(E\\) eigendecomposition \\(X^\\top X = E \\Lambda E^\\top\\). result five compositional measurements glass artifacts:  can immediately see concentrations silica ferrous oxide highly correlated, anticorrelated quicklime, vary independently (statistical sense) aluminium oxide magnesia, anticorrelated . setting, obtained visualization directly case–variable data \\(X\\), PCA. technique becomes uniquely useful correlations without underlying coordinates.","code":"# covariances and standard deviations c <- cov(x) s <- diag(sqrt(diag(c))) # eigendecomposition of covariance matrix c.eigen <- eigen(c) # artificial coordinates c.coord <- c.eigen$vectors[, 1:2] %*% diag(sqrt(c.eigen$values[1:2])) # scatterplot c.inner <- c.coord %*% t(c.coord) plot(   x = as.vector(c[lower.tri(c)]),   y = as.vector(c.inner[lower.tri(c.inner)]),   xlim = range(c[lower.tri(c)]), ylim = range(c[lower.tri(c)]),   asp = 1, pch = 19, cex = .5,   xlab = \"Measurement covariances in unscaled data\",   ylab = \"Vector inner products in planar CMDS\" ) lines(x = range(c[lower.tri(c)]), y = range(c[lower.tri(c)])) c <- cor(glass[, c(\"SiO2\", \"Al2O3\", \"FeO\", \"MgO\", \"CaO\")]) c.eigen <- eigen(c) c.coord <- c.eigen$vectors[, 1:2] %*% diag(sqrt(c.eigen$values[1:2])) plot(   c.coord, pch = NA, asp = 1,   xlab = \"First principal coordinate\", ylab = \"Second principal coordinate\" ) arrows(0, 0, c.coord[, 1L], c.coord[, 2L]) text(c.coord, labels = rownames(c), cex = .9)"},{"path":"/articles/cmds-variables.html","id":"use-case-rankings-of-universities","dir":"Articles","previous_headings":"","what":"use case: rankings of universities","title":"multidimensional scaling of variables","text":"natural use case CMDS variables analysis multiple rankings set objects terms concordance. Rankings’ concordance often measured using rank correlations Kendall’s \\(\\tau\\), may general correlation coefficients sense proposed Kendall associated underlying geometry. setting, original \\(X\\) Euclidean coordinates. Nevertheless, can use CMDS represent rankings unit vectors Euclidean space whose pairwise cosines approximate rank correlations! real-world example provided Quacquarelli Symonds World University Rankings, include rankings hundreds world universities along six dimensions: academic reputation, employer reputation, faculty–student ratio, citations per faculty, international faculty ratio, international student ratio. QS weight rankings differently overall assessment, analysis compare rankings across universities, ignoring weights. subset qswur_usa installed ordr include U.S.-based universities ranked years 2017–2020, classifications QS, six integer-valued rankings. (Scores used generate rankings included QS data files omitted qswur_usa.) example, ’ll focus rankings year 2020 rankings available. leaves 38 universities, conclusions must taken caution! Since rankings subsetted full international data set, contiguous (integers rankings never appear). resolve , ’ll also recalibrate rankings matching vector ranks vector sorted unique values: subset universities now contiguously ranked along six dimensions described . Kendall correlation \\(\\tau_{ij}\\) two rankings measures concordance. calculate , every pair universities contributes either \\(+1\\) \\(-1\\) according rankings \\(\\) \\(j\\) place pair order, sum scaled number pairs \\({n\\choose 2}\\) result lies \\(-1\\) \\(1\\). interpret \\(\\tau_{ij}=1\\) perfect concordance (rankings equivalent), \\(\\tau_{ij}=-1\\) perfect discordance (rankings reversed), \\(\\tau_{ij}=0\\) independence (rankings independent). six QS rankings academic reputation (rk_academic), employer reputation (rk_employer) faculty–student ratio (rk_ratio) citations per faculty (rk_citations) international faculty ratio (rk_intl_faculty) international student ratio (rk_intl_students) variations single theme (measures construct), like different measures guideline adherence positive affect. Though seem potentially sensitive university’s resources, including finance prestige. intuit two reputation indexes positively correlated, two international personnel ratios well. also wonder faculty–student ratio might anti-correlated number citations per faculty, separating research-focused institutions teaching-focused ones.","code":"library(ordr) library(dplyr) data(qswur_usa, package = \"ordr\") print(qswur_usa) ## # A tibble: 612 × 13 ##     year institution      size  focus res     age status rk_academic rk_employer ##    <int> <chr>            <fct> <fct> <fct> <int> <chr>        <int>       <int> ##  1  2017 MASSACHUSETTS I… M     CO    VH        5 B                6           4 ##  2  2017 STANFORD UNIVER… L     FC    VH        5 A                5           5 ##  3  2017 HARVARD UNIVERS… L     FC    VH        5 B                1           1 ##  4  2017 CALIFORNIA INST… S     CO    VH        5 B               23          90 ##  5  2017 UNIVERSITY OF C… L     FC    VH        5 B               13          47 ##  6  2017 PRINCETON UNIVE… M     CO    VH        5 B               10          32 ##  7  2017 YALE UNIVERSITY  L     FC    VH        5 B                9          12 ##  8  2017 CORNELL UNIVERS… L     FC    VH        5 B               21          49 ##  9  2017 JOHNS HOPKINS U… L     FC    VH        5 B               41         139 ## 10  2017 UNIVERSITY OF P… L     FC    VH        5 B               33          35 ## # ℹ 602 more rows ## # ℹ 4 more variables: rk_ratio <int>, rk_citations <int>, ## #   rk_intl_faculty <int>, rk_intl_students <int> qswur_usa %>%   filter(year == 2020L) %>%   select(institution, starts_with(\"rk_\")) %>%   mutate_at(     vars(starts_with(\"rk_\")),     ~ match(., sort(unique(as.numeric(.))))   ) %>%   filter_at(vars(starts_with(\"rk_\")), ~ ! is.na(.)) ->   qswur_usa2020 print(qswur_usa2020) ## # A tibble: 38 × 7 ##    institution     rk_academic rk_employer rk_ratio rk_citations rk_intl_faculty ##    <chr>                 <int>       <int>    <int>        <int>           <int> ##  1 MASSACHUSETTS …           3           2        8            4               1 ##  2 STANFORD UNIVE…           2           3        5            7               2 ##  3 HARVARD UNIVER…           1           1       17            5               8 ##  4 CALIFORNIA INS…          12          17        1            2               3 ##  5 UNIVERSITY OF …           9          11       19           22              20 ##  6 PRINCETON UNIV…           7           7       35            1              26 ##  7 CORNELL UNIVER…          11          13       40            9               5 ##  8 UNIVERSITY OF …          14          12       11           31              12 ##  9 YALE UNIVERSITY           6           4        2           46              17 ## 10 COLUMBIA UNIVE…           8           8       10           47              51 ## # ℹ 28 more rows ## # ℹ 1 more variable: rk_intl_students <int>"},{"path":"/articles/cmds-variables.html","id":"correlation-heatmap","dir":"Articles","previous_headings":"use case: rankings of universities","what":"correlation heatmap","title":"multidimensional scaling of variables","text":"Heatmaps commonly, perhaps commonly, used visualize correlation matrices, make useful contrast CMDS correlation plot. use heatmap() produce basic correlation heatmap, blog post version vignette uses corrplot package elegant effect. can learned glance plot? rankings academic employer reputations highly concordant, international faculty student ratios less . faculty–student ratio faculty citation rankings weakest concordance pair, still positively correlated.  visualization useful, ’s busy: compare pair rankings, find cell grid corresponding pair refer back color scale assess meaning. can’t rely nearby cells context, may stronger weaker average skew interpretation. example, visibly weak associations faculty–student ratio rankings (third row/column) happen arranged slightly stronger among , two reputational variables, sandwiched even stronger associations two reputational rankings faculty citations ranking. Meanwhile, ranking’s weaker associations sandwiched typical, still comparatively stronger, associations. different ordering variables might “obscure” pattern “reveal” others, forces analyst choose emphases rather allowing viewer assess even footing. plot also strictly pairwise: Every correlation two rankings occupies cell—two, fact, making almost half plot duplicative. means subset analysis , say, three rankings requires focusing three cells corners right triangle ignoring surrounding cells. easy visual task. straightforward create new plot subset, larger context remaining rankings lost. Finally, color size scales less desirable plot data lie single scale (\\(-1 \\leq r \\leq 1\\)). Contrast histogram, also visualizes single data type (count) uses one axis represent count (represent value) require color . general, plots simple data use scales (aesthetic mappings)—make plots readable also allow additional scales highlight additional data properties.","code":"corr <- cor(select(qswur_usa2020, starts_with(\"rk_\")), method = \"kendall\") heatmap(corr, scale = \"none\")"},{"path":"/articles/cmds-variables.html","id":"correlation-monoplot","dir":"Articles","previous_headings":"use case: rankings of universities","what":"correlation monoplot","title":"multidimensional scaling of variables","text":"CMDS variables offers natural alternative visualization, Gower, Gardner–Lubbe, le Roux (2011) call “correlation monoplot” consists one two layers PCA biplot. CMDS cases, point isn’t overlay case scores variable loadings singular value decomposition, use scores loadings alone endow cases variables Euclidean geometry didn’t originally . end, ’ll plot variables vectors tails origin heads principal coordinates \\(Y = V \\Lambda^{1/2}\\), unit circle included reference:  respect pairwise correlations, biplot significantly less precise: Though vectors unit length \\(\\mathbb{R}^r\\) (\\(r\\leq p=6\\)), projections onto first two principal coordinates much shorter, indicating much geometric configuration requires additional dimensions represent. Indeed, coordinates capture \\(48.2\\%+14.3\\%=62.5\\%\\) inertia full, six-dimensional eigendecomposition. means angles vectors must interpreted caution: example, looks like academic employer reputation rankings extremely correlated, apparent alignment vectors artifact projection, fact “rise” “fall” opposite directions along remaining principal coordinates. correlation heatmap, comparison, leaves ambiguity. However, biplot far surpasses heatmap parsimony: variable represented single vector, angle cosines variable vectors roughly approximate correlations. instance, rankings based international student faculty ratios correlation around \\(\\cos(\\frac{\\pi}{4})=\\frac{1}{\\sqrt{2}}\\), corresponding either explaining half “variance” —technically meaningful ranking context useful conceptual anchor. Meanwhile, faculty–student ratio ranking nearly independent faculty citation ranking, contrary intuition rankings reflect reverse association research- teaching-oriented institutions. convenience recognizing correlations cosines may worth significant risk error, especially since error (residual \\(37.5\\%\\) inertia) can exactly quantified. Moreover, principal coordinates variable vectors indicate loadings onto first second principal moments inertia—two dimensions capture variation data. example, first principal coordinate aligned two reputational rankings, suggesting general prestige ranking strongest overall component several specific rankings. contrast, faculty–student ratio faculty citation rankings load strongly onto second principal coordinate, suggesting divide research- teaching-focused institutions may yet important understanding universities compare along different metrics. observations, provisional though , difficult discern heatmap. importantly, unlike secondary patterns visible heatmap, artifacts layout arise directly (correlational) data. last point means observations made correlation monoplot can validated CMDS coordinates. particular, can examine variables’ loadings onto third principal coordinate, can check whether reputational rankings aligned misaligned along . Based third principal coordinates, reputational rankings aligned, knew already correlation matrix heatmap. ’s bit interesting component seems separate two rankings faculty citation rates international compositions faculty student body. Based decomposition inertia, third principal coordinate nearly important second! therefore makes sense plot two together, effect examining residuals regressing first principal coordinate:  primary antitheses reputational rankings, removing first principal coordinate, two rankings based international composition. third principal coordinate aligns closely axis. axis also largely independent axis distinguishes research- teaching-oriented institutions, closely aligned second principal coordinate. limited experience, ’d hazard guess reflects two tiers international representation among students faculty, one expressed prestigious institutions recruit highly qualified applicants world, expressed institutions especially prestigious located communities regions high percentages international residents. sum, interpreted three strongest axes along QS rankings vary: (1) overall quality, prestige, reputation; (2) research versus teaching orientation; (3) international personnel ratios, come cost reputation. course preliminary amateur analysis! visualization scheme encourages hypothesis generation worth hand.","code":"eigen_ord(corr) %>%   as_tbl_ord() %>%   augment_ord() %>%   mutate_rows(metric = stringr::str_remove(name, \"rk_\")) %>%   confer_inertia(1) ->   c_eigen c_eigen %>%   ggbiplot() +   theme_minimal() +   geom_unit_circle() +   geom_rows_vector(aes(label = metric)) +   scale_x_reverse(expand = expansion(add = .4)) +   scale_y_continuous(expand = expansion(add = .3)) +   ggtitle(\"Kendall correlations between university rankings\",           \"CMDS correlation monoplot\") c_eigen %>%   fortify(.matrix = \"rows\") %>%   select(-name, -.matrix) ## # A tibble: 6 × 8 ##      EV1     EV2     EV3     EV4     EV5      EV6 metric        .element ##    <dbl>   <dbl>   <dbl>   <dbl>   <dbl>    <dbl> <chr>         <chr>    ## 1 -0.834 -0.0907  0.412   0.0430 -0.0206  0.351   academic      active   ## 2 -0.795 -0.0964  0.477  -0.0416 -0.181  -0.311   employer      active   ## 3 -0.517  0.771  -0.0480  0.331   0.158  -0.0372  ratio         active   ## 4 -0.731 -0.352  -0.239  -0.0278  0.528  -0.0685  citations     active   ## 5 -0.631 -0.233  -0.521   0.392  -0.352   0.00783 intl_faculty  active   ## 6 -0.603  0.262  -0.324  -0.665  -0.140   0.0312  intl_students active c_eigen %>%   ggbiplot(aes(x = 2, y = 3)) +   theme_minimal() +   geom_unit_circle() +   geom_rows_vector(aes(label = metric)) +   scale_x_continuous(expand = expansion(add = .5)) +   scale_y_continuous(expand = expansion(add = .5)) +   ggtitle(\"Kendall correlations between university rankings\",           \"CMDS correlation monoplot, second & third principal coordinates\")"},{"path":"/articles/ordr.html","id":"the-hair-and-eye-color-data","dir":"Articles","previous_headings":"","what":"the hair and eye color data","title":"Ordination in the tidyverse","text":"begin inspection data using base R. information data set, call help(HairEyeColor).  data collected students one Ronald Snee’s statistics courses.1 consist hair color eye color, binned four groups, 592 subjects. data also stratified sex, forming 3-way array. (default) mosaic plot reveals subtle differences sex, lose little flattening array \\(4 \\times 4\\) matrix. resulting count table suitable correspondence analysis, fit model next.","code":"print(HairEyeColor) #> , , Sex = Male #>  #>        Eye #> Hair    Brown Blue Hazel Green #>   Black    32   11    10     3 #>   Brown    53   50    25    15 #>   Red      10   10     7     7 #>   Blond     3   30     5     8 #>  #> , , Sex = Female #>  #>        Eye #> Hair    Brown Blue Hazel Green #>   Black    36    9     5     2 #>   Brown    66   34    29    14 #>   Red      16    7     7     7 #>   Blond     4   64     5     8 plot(HairEyeColor)"},{"path":"/articles/ordr.html","id":"correspondence-analysis-using-mass","dir":"Articles","previous_headings":"","what":"correspondence analysis using MASS","title":"Ordination in the tidyverse","text":"implementation MASS::corresp() returns object class ‘correspondence’. addition information included print() method, can use canonical correlations calculate proportion variance along dimension: variation table, terms \\(\\chi^2\\) distances distributions hair color among people eye color (, equivalently, vice-versa), lies largely (\\(89\\%\\)) along single dimension, remaining variation largely (\\(9.5\\%\\)) along single orthogonal dimension. first dimension best distinguishes subjects black hair brown eyes blond hair blue eyes. Subjects brown red hair, hazel green eyes, lie extremes. second dimension distinguishes subjects black blond hair, brown blue eyes, brown red hair, hazel green eyes. Subjects red hair green eyes especially distinguished along dimension. disrupts impression first dimension alone subjects lie along spectrum black hair–brown eyes blond hair–blue eyes, may accurately include intermediate phenotype (brown hair–hazel eyes), reveals phenotype (red hair–green eyes) diverges spectrum. exercise, can recover row column standard coordinates returned corresp() direct computations, e.g. following Wikipedia article correspondence analysis, starting data matrix (count table) \\(X\\) total count \\(n = 1^\\top X 1\\): correspondence matrix (matrix relative frequencies) \\(P = \\frac{1}{n} X\\) row column weights \\(r = \\frac{1}{n} X 1\\) \\(c = \\frac{1}{n} 1^\\top X\\) diagonals inverse weights \\(D_r = \\operatorname{diag}(r)\\) \\(D_c = \\operatorname{diag}(c)\\) matrix standardized residuals \\(S = D_r (P - rc) D_c\\) singular value decomposition \\(S = U \\Sigma V^\\top\\) row column standard coordinates \\(F = D_r U\\) \\(G = D_c V\\) can generate biplot display via biplot() method ‘correspondence’ class, also provided MASS:  symmetric biplot evenly distributes inertia rows columns. Distances points matrix factor approximate \\(\\chi^2\\) distances, inner products row column points approximate standardized residuals. row column profile markers resized represent masses groups.","code":"haireye <- apply(HairEyeColor, c(1L, 2L), sum) haireye_ca <- corresp(haireye, nf = 3L) print(haireye_ca) #> First canonical correlation(s): 0.45691646 0.14908593 0.05097489  #>  #>  Hair scores: #>             [,1]       [,2]       [,3] #> Black -1.1042772  1.4409170 -1.0889497 #> Brown -0.3244635 -0.2191109  0.9574152 #> Red   -0.2834725 -2.1440145 -1.6312184 #> Blond  1.8282287  0.4667063 -0.3180920 #>  #>  Eye scores: #>             [,1]       [,2]        [,3] #> Brown -1.0771283  0.5924202 -0.42395984 #> Blue   1.1980612  0.5564193  0.09238682 #> Hazel -0.4652862 -1.1227826  1.97191769 #> Green  0.3540108 -2.2741218 -1.71844295 # proportion of variance in each dimension haireye_ca$cor^2 / sum(haireye_ca$cor^2) #> [1] 0.89372732 0.09514911 0.01112356 # correspondence matrix (matrix of relative frequencies) (haireye_p <- haireye / sum(haireye)) #>        Eye #> Hair         Brown       Blue      Hazel       Green #>   Black 0.11486486 0.03378378 0.02533784 0.008445946 #>   Brown 0.20101351 0.14189189 0.09121622 0.048986486 #>   Red   0.04391892 0.02871622 0.02364865 0.023648649 #>   Blond 0.01182432 0.15878378 0.01689189 0.027027027 # row and column weights (haireye_r <- rowSums(haireye) / sum(haireye)) #>     Black     Brown       Red     Blond  #> 0.1824324 0.4831081 0.1199324 0.2145270 (haireye_c <- colSums(haireye) / sum(haireye)) #>     Brown      Blue     Hazel     Green  #> 0.3716216 0.3631757 0.1570946 0.1081081 # matrix of standardized residuals (haireye_s <-     diag(1 / sqrt(haireye_r)) %*%     (haireye_p - haireye_r %*% t(haireye_c)) %*%     diag(1 / sqrt(haireye_c))) #>              [,1]        [,2]        [,3]        [,4] #> [1,]  0.180773066 -0.12615064 -0.01961905 -0.08029590 #> [2,]  0.050694815 -0.08012300  0.05561963 -0.01418351 #> [3,] -0.003081574 -0.07110772  0.03502737  0.09381990 #> [4,] -0.240474512  0.28973637 -0.09156384  0.02518174 # singular value decomposition haireye_svd <- svd(haireye_s) # row and column standard coordinates diag(1 / sqrt(haireye_r)) %*% haireye_svd$u[, 1:3] #>            [,1]       [,2]       [,3] #> [1,] -1.1042772  1.4409170 -1.0889497 #> [2,] -0.3244635 -0.2191109  0.9574152 #> [3,] -0.2834725 -2.1440145 -1.6312184 #> [4,]  1.8282287  0.4667063 -0.3180920 diag(1 / sqrt(haireye_c)) %*% haireye_svd$v[, 1:3] #>            [,1]       [,2]        [,3] #> [1,] -1.0771283  0.5924202 -0.42395984 #> [2,]  1.1980612  0.5564193  0.09238682 #> [3,] -0.4652862 -1.1227826  1.97191769 #> [4,]  0.3540108 -2.2741218 -1.71844295 biplot(   haireye_ca, type = \"symmetric\", cex = .8,   main = \"Correspondence analysis of subjects' hair & eye colors\" )"},{"path":"/articles/ordr.html","id":"ordr-methods-for-ca-models","dir":"Articles","previous_headings":"","what":"ordr methods for CA models","title":"Ordination in the tidyverse","text":"ordr provides new class, ‘tbl_ord’, wraps ordination objects like class ‘prcomp’ without directly modifying . (original model can recovered un_tbl_ord().) print() method ‘tbl_ord’ based tibbles. prints two tibbles, like ‘tbl_graph’ class tidygraph, one matrix factor. header reminds us dimensions matrix factors inertia distributed. ‘correspondence’ objects, default row column profiles standard coordinates: \\(D_r F\\) \\(D_c G\\), can reassigned pair proportions \\(D_r S {D_c}^\\top = (D_r U \\Sigma^{p}) (D_c V \\Sigma^{q})^\\top\\), even \\(p + q \\neq 1\\). assigning \"symmetric\" inertia, distribute half inertia matrix factor: broom::glance() returns single-row tibble summary model object. designed analysis pipelines involving multiple models (e.g. model selection), facilitate summaries multiple models . ‘tbl_ord’ objects wrap potentially huge variety models, summary statistics usually useful. method includes rank matrix factorization; proportion inertia/variance first two dimensions, characterize fidelity biplot complete data; original object class. Analogous broom::augment(), tbl_ord-specific function preserves ‘tbl_ord’ class augments row column tibbles metadata diagnostics found model object. Vertical bars separate coordinate matrices annotations. Additional row- column-level variables can also augmented manipulated using handful dplyr-like verbs, specific matrix factor affected (rows cols). tibble split shared coordinates left additional annotation columns right. broom::tidy() method tbl_ords returns tibble one row per artificial coordinate.2 CA, variably called dimensions components. ‘correspondence’ object contains $cor vector canonical correlations, included result; coordinate-level attributes vary model object class. .inertia .prop_var fields calculated singular values eigenvalues contained ordination object always appear defined. means tidy() prepares ordination object derived decomposition scree plot ggplot2::ggplot():  ggplot2::fortify() may rarely called directly, plays special role ordr converting ‘tbl_ord’ object ‘tbl_df’ object. , fortifier row-binds two matrix factor tibbles adds additional .matrix column remember : fortifier also preserve row column annotations, can composed augment_ord() row- column-specific verbs. NAs introduced annotation present one matrix factor . (.element column becomes important model produces supplementary well active elements.) .matrix column also plays key role ggbiplot(): row- column-specific ploy layers, take form geom_rows_*() stat_cols_*(), example, use column subset data internally. enables layered grammar graphics ggplot2 apply separately two matrix factors annotation. Though note can also applied entire fortified data frame using conventional plot layers, .matrix column used distinguish colors shapes row column profile markers:  Note conveniences: position aesthetics assumed first second artificial coordinates, unless otherwise specified. Biplots can also specified setting x y aesthetics integers, converted corresponding artificial coordinates. default, aspect ratio set 1. essential biplots, rely distances markers angles vectors convey information. partial theme theme_biplot() removes several plot elements usually important biplots, notably gridlines, retaining properties current theme. layer geom_origin() one two shortcuts plotting elements commonly used biplots, geom_unit_circle().","code":"(haireye_ca_ord <- as_tbl_ord(haireye_ca)) #> # A tbl_ord of class 'correspondence': (4 x 3) x (4 x 3)' #> # 3 coordinates: Can1, Can2, Can3 #> #  #> # Rows (standard): [ 4 x 3 | 0 ] #>     Can1   Can2   Can3 |  #>                        |  #> 1 -1.10   1.44  -1.09  |  #> 2 -0.324 -0.219  0.957 |  #> 3 -0.283 -2.14  -1.63  |  #> 4  1.83   0.467 -0.318 |  #> #  #> # Columns (standard): [ 4 x 3 | 0 ] #>     Can1   Can2    Can3 |  #>                         |  #> 1 -1.08   0.592 -0.424  |  #> 2  1.20   0.556  0.0924 |  #> 3 -0.465 -1.12   1.97   |  #> 4  0.354 -2.27  -1.72   | get_conference(haireye_ca_ord) #> [1] 0 0 confer_inertia(haireye_ca_ord, c(.25, .75)) #> # A tbl_ord of class 'correspondence': (4 x 3) x (4 x 3)' #> # 3 coordinates: Can1, Can2, Can3 #> #  #> # Rows (25% inertia): [ 4 x 3 | 0 ] #>     Can1   Can2   Can3 |  #>                        |  #> 1 -0.908  0.895 -0.517 |  #> 2 -0.267 -0.136  0.455 |  #> 3 -0.233 -1.33  -0.775 |  #> 4  1.50   0.290 -0.151 |  #> #  #> # Columns (75% inertia): [ 4 x 3 | 0 ] #>     Can1   Can2     Can3 |  #>                          |  #> 1 -0.599  0.142 -0.0455  |  #> 2  0.666  0.133  0.00991 |  #> 3 -0.259 -0.269  0.212   |  #> 4  0.197 -0.546 -0.184   | confer_inertia(haireye_ca_ord, c(1, 1)) #> Warning in confer_inertia(haireye_ca_ord, c(1, 1)): Inertia is not balanced. #> # A tbl_ord of class 'correspondence': (4 x 3) x (4 x 3)' #> # 3 coordinates: Can1, Can2, Can3 #> #  #> # Rows (principal): [ 4 x 3 | 0 ] #>     Can1    Can2    Can3 |  #>                          |  #> 1 -0.505  0.215  -0.0555 |  #> 2 -0.148 -0.0327  0.0488 |  #> 3 -0.130 -0.320  -0.0832 |  #> 4  0.835  0.0696 -0.0162 |  #> #  #> # Columns (principal): [ 4 x 3 | 0 ] #>     Can1    Can2     Can3 |  #>                           |  #> 1 -0.492  0.0883 -0.0216  |  #> 2  0.547  0.0830  0.00471 |  #> 3 -0.213 -0.167   0.101   |  #> 4  0.162 -0.339  -0.0876  | (haireye_ca_ord <- confer_inertia(haireye_ca_ord, \"symmetric\")) #> # A tbl_ord of class 'correspondence': (4 x 3) x (4 x 3)' #> # 3 coordinates: Can1, Can2, Can3 #> #  #> # Rows (symmetric): [ 4 x 3 | 0 ] #>     Can1    Can2    Can3 |  #>                          |  #> 1 -0.746  0.556  -0.246  |  #> 2 -0.219 -0.0846  0.216  |  #> 3 -0.192 -0.828  -0.368  |  #> 4  1.24   0.180  -0.0718 |  #> #  #> # Columns (symmetric): [ 4 x 3 | 0 ] #>     Can1   Can2    Can3 |  #>                         |  #> 1 -0.728  0.229 -0.0957 |  #> 2  0.810  0.215  0.0209 |  #> 3 -0.315 -0.434  0.445  |  #> 4  0.239 -0.878 -0.388  | glance(haireye_ca_ord) #> # A tibble: 1 × 7 #>    rank n.row n.col inertia prop.var.1 prop.var.2 class          #>   <int> <int> <int>   <dbl>      <dbl>      <dbl> <chr>          #> 1     3     4     4   0.234      0.894     0.0951 correspondence augment_ord(haireye_ca_ord) #> # A tbl_ord of class 'correspondence': (4 x 3) x (4 x 3)' #> # 3 coordinates: Can1, Can2, Can3 #> #  #> # Rows (symmetric): [ 4 x 3 | 1 ] #>     Can1    Can2    Can3 |   name  #>                          |   <chr> #> 1 -0.746  0.556  -0.246  | 1 Black #> 2 -0.219 -0.0846  0.216  | 2 Brown #> 3 -0.192 -0.828  -0.368  | 3 Red   #> 4  1.24   0.180  -0.0718 | 4 Blond #> #  #> # Columns (symmetric): [ 4 x 3 | 1 ] #>     Can1   Can2    Can3 |   name  #>                         |   <chr> #> 1 -0.728  0.229 -0.0957 | 1 Brown #> 2  0.810  0.215  0.0209 | 2 Blue  #> 3 -0.315 -0.434  0.445  | 3 Hazel #> 4  0.239 -0.878 -0.388  | 4 Green tidy(haireye_ca_ord) #> # A tibble: 3 × 5 #>   name     cor inertia prop_var quality #>   <fct>  <dbl>   <dbl>    <dbl>   <dbl> #> 1 Can1  0.457  0.209     0.894    0.894 #> 2 Can2  0.149  0.0222    0.0951   0.989 #> 3 Can3  0.0510 0.00260   0.0111   1 ggplot(tidy(haireye_ca_ord), aes(x = name, y = inertia)) +   geom_col() +   labs(x = \"Component\", y = \"Inertia\") +   ggtitle(\"Correspondence analysis of subjects' hair & eye colors\",           \"Decomposition of inertia\") fortify(haireye_ca_ord) #> # A tibble: 8 × 5 #>     Can1    Can2    Can3 .element .matrix #>    <dbl>   <dbl>   <dbl> <chr>    <chr>   #> 1 -0.746  0.556  -0.246  active   rows    #> 2 -0.219 -0.0846  0.216  active   rows    #> 3 -0.192 -0.828  -0.368  active   rows    #> 4  1.24   0.180  -0.0718 active   rows    #> 5 -0.728  0.229  -0.0957 active   cols    #> 6  0.810  0.215   0.0209 active   cols    #> 7 -0.315 -0.434   0.445  active   cols    #> 8  0.239 -0.878  -0.388  active   cols haireye_ca_ord %>%   augment_ord() %>%   fortify() %>%   transform(feature = ifelse(.matrix == \"rows\", \"Hair\", \"Eye\")) %>%   ggbiplot(aes(color = feature, shape = feature, label = name), clip = \"off\") +   theme_biplot() +   geom_origin() +   geom_rows_point() +   geom_cols_point() +   geom_rows_text(vjust = -1, hjust = 0, size = 3) +   geom_cols_text(vjust = -1, hjust = 0, size = 3) +   scale_color_brewer(type = \"qual\", palette = \"Dark2\") +   scale_size_area() +   ggtitle(\"Correspondence analysis of subjects' hair & eye colors\",           \"Symmetric biplot\")"},{"path":"/articles/ordr.html","id":"session-info","dir":"Articles","previous_headings":"","what":"session info","title":"Ordination in the tidyverse","text":"","code":"sessioninfo::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.4.2 (2024-10-31) #>  os       macOS Sonoma 14.4.1 #>  system   aarch64, darwin20 #>  ui       X11 #>  language en #>  collate  en_US.UTF-8 #>  ctype    en_US.UTF-8 #>  tz       America/Los_Angeles #>  date     2025-07-10 #>  pandoc   2.19 @ /opt/homebrew/bin/ (via rmarkdown) #>  quarto   NA #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package      * version date (UTC) lib source #>  bslib          0.9.0   2025-01-30 [2] CRAN (R 4.4.1) #>  cachem         1.1.0   2024-05-16 [2] CRAN (R 4.4.1) #>  cli            3.6.5   2025-04-23 [2] CRAN (R 4.4.1) #>  desc           1.4.3   2023-12-10 [2] CRAN (R 4.4.1) #>  digest         0.6.37  2024-08-19 [2] CRAN (R 4.4.1) #>  dplyr          1.1.4   2023-11-17 [2] CRAN (R 4.4.0) #>  evaluate       1.0.4   2025-06-18 [2] CRAN (R 4.4.1) #>  farver         2.1.2   2024-05-13 [2] CRAN (R 4.4.1) #>  fastmap        1.2.0   2024-05-15 [2] CRAN (R 4.4.1) #>  fs             1.6.6   2025-04-12 [2] CRAN (R 4.4.1) #>  generics       0.1.4   2025-05-09 [2] CRAN (R 4.4.1) #>  gggda          0.1.1   2025-07-09 [2] Github (corybrunson/gggda@91e7e82) #>  ggplot2      * 3.5.2   2025-04-09 [2] CRAN (R 4.4.1) #>  ggrepel        0.9.6   2024-09-07 [2] CRAN (R 4.4.1) #>  glue           1.8.0   2024-09-30 [2] CRAN (R 4.4.1) #>  gtable         0.3.6   2024-10-25 [2] CRAN (R 4.4.1) #>  htmltools      0.5.8.1 2024-04-04 [2] CRAN (R 4.4.1) #>  htmlwidgets    1.6.4   2023-12-06 [2] CRAN (R 4.4.0) #>  jquerylib      0.1.4   2021-04-26 [2] CRAN (R 4.4.0) #>  jsonlite       2.0.0   2025-03-27 [2] CRAN (R 4.4.1) #>  knitr          1.50    2025-03-16 [2] CRAN (R 4.4.1) #>  labeling       0.4.3   2023-08-29 [2] CRAN (R 4.4.1) #>  lifecycle      1.0.4   2023-11-07 [2] CRAN (R 4.4.1) #>  magrittr       2.0.3   2022-03-30 [2] CRAN (R 4.4.1) #>  MASS         * 7.3-65  2025-02-28 [2] CRAN (R 4.4.1) #>  ordr         * 0.2.0   2025-07-10 [1] local #>  pillar         1.11.0  2025-07-04 [2] CRAN (R 4.4.1) #>  pkgconfig      2.0.3   2019-09-22 [2] CRAN (R 4.4.1) #>  pkgdown        2.1.3   2025-05-25 [2] CRAN (R 4.4.1) #>  purrr          1.0.4   2025-02-05 [2] CRAN (R 4.4.1) #>  R6             2.6.1   2025-02-15 [2] CRAN (R 4.4.1) #>  ragg           1.4.0   2025-04-10 [2] CRAN (R 4.4.1) #>  RColorBrewer   1.1-3   2022-04-03 [2] CRAN (R 4.4.1) #>  Rcpp           1.1.0   2025-07-02 [2] CRAN (R 4.4.1) #>  rlang          1.1.6   2025-04-11 [2] CRAN (R 4.4.1) #>  rmarkdown      2.29    2024-11-04 [2] CRAN (R 4.4.1) #>  sass           0.4.10  2025-04-11 [2] CRAN (R 4.4.1) #>  scales         1.4.0   2025-04-24 [2] CRAN (R 4.4.1) #>  sessioninfo    1.2.3   2025-02-05 [2] CRAN (R 4.4.1) #>  stringi        1.8.7   2025-03-27 [2] CRAN (R 4.4.1) #>  stringr        1.5.1   2023-11-14 [2] CRAN (R 4.4.0) #>  systemfonts    1.2.3   2025-04-30 [2] CRAN (R 4.4.1) #>  textshaping    1.0.1   2025-05-01 [2] CRAN (R 4.4.1) #>  tibble         3.3.0   2025-06-08 [2] CRAN (R 4.4.1) #>  tidyr          1.3.1   2024-01-24 [2] CRAN (R 4.4.1) #>  tidyselect     1.2.1   2024-03-11 [2] CRAN (R 4.4.0) #>  utf8           1.2.6   2025-06-08 [2] CRAN (R 4.4.1) #>  vctrs          0.6.5   2023-12-01 [2] CRAN (R 4.4.0) #>  withr          3.0.2   2024-10-28 [2] CRAN (R 4.4.1) #>  xfun           0.52    2025-04-02 [2] CRAN (R 4.4.1) #>  yaml           2.3.10  2024-07-26 [2] CRAN (R 4.4.1) #>  #>  [1] /private/var/folders/4p/3cy0qmp15x9216qsqhh84kzm0000gn/T/RtmpuNvV7F/temp_libpathaf9f1826b41a #>  [2] /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library #>  * ── Packages attached to the search path. #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jason Cory Brunson. Author, maintainer. Emily Paul. Contributor. John Gracey. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brunson J, Gracey J (2025). ordr: 'Tidyverse' Extension Ordinations Biplots. R package version 0.2.0, https://corybrunson.github.io/ordr/, https://github.com/corybrunson/ordr.","code":"@Manual{,   title = {ordr: A 'Tidyverse' Extension for Ordinations and Biplots},   author = {Jason Cory Brunson and John Gracey},   year = {2025},   note = {R package version 0.2.0, https://corybrunson.github.io/ordr/},   url = {https://github.com/corybrunson/ordr}, }"},{"path":"/index.html","id":"ordr","dir":"","previous_headings":"","what":"A Tidyverse Extension for Ordinations and Biplots","title":"A Tidyverse Extension for Ordinations and Biplots","text":"ordr integrates ordination analysis biplot visualization tidyverse workflows.","code":""},{"path":"/index.html","id":"motivation","dir":"","previous_headings":"","what":"motivation","title":"A Tidyverse Extension for Ordinations and Biplots","text":"Wherever SVD, biplot.1","code":""},{"path":"/index.html","id":"ordination-and-biplots","dir":"","previous_headings":"motivation","what":"ordination and biplots","title":"A Tidyverse Extension for Ordinations and Biplots","text":"Ordination catch-term variety statistical techniques introduce artificial coordinate system data set way coordinates capture large amount data structure 2. branch mathematical statistics called geometric data analysis (GDA) provides theoretical basis () techniques. Ordination overlaps regression dimension reduction, can contrasted clustering classification assign continuous rather categorical values data elements 3. ordination techniques decompose numeric rectangular data set product two matrices, often using singular value decomposition (SVD). coordinates shared dimensions matrices (multiplied) artificial coordinates. cases, principal components analysis, decomposition exact; others, non-negative matrix factorization, approximate. techniques, correspondence analysis, transform data decomposition. Ordination techniques may supervised, like linear discriminant analysis, unsupervised, like multidimensional scaling. Analysis pipelines use techniques may use artificial coordinates directly, place natural coordinates, arrange compare data elements predict responses. possible rows columns original table can located, positioned, along shared coordinates. number artificial coordinates used application, regression visualization, called rank ordination 4. common application biplot, positions rows columns original table scatterplot 1, 2, 3 artificial coordinates, usually explain variation data.","code":""},{"path":"/index.html","id":"implementations-in-r","dir":"","previous_headings":"motivation","what":"implementations in R","title":"A Tidyverse Extension for Ordinations and Biplots","text":"extensive range ordination techniques implemented R, classical multidimensional scaling (stats::cmdscale()) principal components analysis (stats::prcomp() stats::princomp()) stats package distributed base R, across widely-used implementations linear discriminant analysis (MASS::lda()) correspondence analysis (ca::ca()) general-use statistical packages, highly specialized packages implement cutting-edge techniques adapt conventional techniques challenging settings. implementations come conventions, tailored research communities produced , impractical (probably unhelpful) try consolidate . Instead, ordr provides streamlined process models output methods—particular, matrix factors original data approximately decomposed artificial coordinates share—can inspected, annotated, tabulated, summarized, visualized. last point, biplot implementations R provide limited customizability. ordr adopts grammar graphics paradigm ggplot2 modularize standardize biplot elements 5. Overall, package designed follow broader syntactic conventions tidyverse, users familiar workflow can easily quickly integrate ordination models practice.","code":""},{"path":[]},{"path":"/index.html","id":"installation","dir":"","previous_headings":"usage","what":"installation","title":"A Tidyverse Extension for Ordinations and Biplots","text":"ordr now CRAN can installed using base R: development version can installed (default) main branch using remotes:","code":"install.packages(\"ordr\") remotes::install_github(\"corybrunson/ordr\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"usage","what":"example","title":"A Tidyverse Extension for Ordinations and Biplots","text":"Morphologically, Iris versicolor much closer Iris virginica Iris setosa, though every character differs Iris virginica departs direction Iris setosa.6 common illustration ordination R applies principal components analysis (PCA) Anderson’s iris measurements. data consist lengths widths petals surrounding sepals 50 three species iris: ordr provides convenience function send subset columns ordination function, wrap resulting model tibble-derived ‘tbl_ord’ class, append model diagnostics original data columns annotations appropriate matrix factors:7 Additional annotations can added using several row- column-specific dplyr-style verbs: Following broom package, tidy() method produces tibble describing model components, case principal coordinates, suitable scree plotting:  Following ggplot2, fortify() method row-binds factor tibbles additional .matrix column. used ggbiplot() redirect row- column-specific plot layers appropriate subsets:8  variables represented standard coordinates, typically PCA, rules can rescaled yield predictive biplot.9 legibility, axes limited data range offset origin:","code":"head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa summary(iris) #>   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width    #>  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   #>  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   #>  Median :5.800   Median :3.000   Median :4.350   Median :1.300   #>  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199   #>  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800   #>  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500   #>        Species   #>  setosa    :50   #>  versicolor:50   #>  virginica :50   #>                  #>                  #> (iris_pca <- ordinate(iris, cols = 1:4, model = ~ prcomp(., scale. = TRUE))) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   Species #>                            |   <fct>   #> 1 -2.26 -0.478  0.127      | 1 setosa  #> 2 -2.07  0.672  0.234      | 2 setosa  #> 3 -2.36  0.341 -0.0441 ... | 3 setosa  #> 4 -2.29  0.595 -0.0910     | 4 setosa  #> 5 -2.38 -0.645 -0.0157     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 3 ] #>      PC1     PC2    PC3 ... |   name         center scale #>                             |   <chr>         <dbl> <dbl> #> 1  0.521 -0.377   0.720     | 1 Sepal.Length   5.84 0.828 #> 2 -0.269 -0.923  -0.244 ... | 2 Sepal.Width    3.06 0.436 #> 3  0.580 -0.0245 -0.142     | 3 Petal.Length   3.76 1.77  #> 4  0.565 -0.0669 -0.634     | 4 Petal.Width    1.20 0.762 iris_meta <- data.frame(   Species = c(\"setosa\", \"versicolor\", \"virginica\"),   Colony = c(1L, 1L, 2L),   Cytotype = c(\"diploid\", \"hexaploid\", \"tetraploid\") ) (iris_pca <- left_join_rows(iris_pca, iris_meta, by = \"Species\")) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 3 ] #>     PC1    PC2     PC3 ... |   Species Colony Cytotype #>                            |   <chr>    <int> <chr>    #> 1 -2.26 -0.478  0.127      | 1 setosa       1 diploid  #> 2 -2.07  0.672  0.234      | 2 setosa       1 diploid  #> 3 -2.36  0.341 -0.0441 ... | 3 setosa       1 diploid  #> 4 -2.29  0.595 -0.0910     | 4 setosa       1 diploid  #> 5 -2.38 -0.645 -0.0157     | 5 setosa       1 diploid  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 3 ] #>      PC1     PC2    PC3 ... |   name         center scale #>                             |   <chr>         <dbl> <dbl> #> 1  0.521 -0.377   0.720     | 1 Sepal.Length   5.84 0.828 #> 2 -0.269 -0.923  -0.244 ... | 2 Sepal.Width    3.06 0.436 #> 3  0.580 -0.0245 -0.142     | 3 Petal.Length   3.76 1.77  #> 4  0.565 -0.0669 -0.634     | 4 Petal.Width    1.20 0.762 tidy(iris_pca) %T>% print() %>%   ggplot(aes(x = name, y = prop_var)) +   geom_col() +   labs(x = \"\", y = \"Proportion of inertia\") +   ggtitle(\"PCA of Anderson's iris measurements\",           \"Distribution of inertia\") #> # A tibble: 4 × 5 #>   name   sdev inertia prop_var quality #>   <fct> <dbl>   <dbl>    <dbl>   <dbl> #> 1 PC1   1.71   435.    0.730     0.730 #> 2 PC2   0.956  136.    0.229     0.958 #> 3 PC3   0.383   21.9   0.0367    0.995 #> 4 PC4   0.144    3.09  0.00518   1 ggbiplot(iris_pca, sec.axes = \"cols\", scale.factor = 2) +   geom_rows_point(aes(color = Species, shape = Species)) +   stat_rows_ellipse(aes(color = Species), alpha = .5, level = .99) +   geom_cols_vector(aes(label = name)) +   expand_limits(y = c(-3.5, NA)) +   ggtitle(\"PCA of Anderson's iris measurements\",           \"99% confidence ellipses; variables use top & right axes\") ggbiplot(iris_pca, axis.type = \"predictive\", axis.percents = FALSE) +   theme_scaffold() +   geom_rows_point(aes(color = Species, shape = Species)) +   stat_rows_center(     aes(color = Species, shape = Species),     size = 5, alpha = .5, fun.data = mean_se   ) +   stat_cols_rule(aes(label = name, center = center, scale = scale)) +   ggtitle(\"Predictive biplot of Anderson's iris measurements\",           \"Project a marker onto an axis to approximate its measurement\") aggregate(iris[, 1:4], by = iris[, \"Species\", drop = FALSE], FUN = mean) #>      Species Sepal.Length Sepal.Width Petal.Length Petal.Width #> 1     setosa        5.006       3.428        1.462       0.246 #> 2 versicolor        5.936       2.770        4.260       1.326 #> 3  virginica        6.588       2.974        5.552       2.026"},{"path":"/index.html","id":"more-methods","dir":"","previous_headings":"usage","what":"more methods","title":"A Tidyverse Extension for Ordinations and Biplots","text":"auxiliary package ordr.extra provides recovery methods several additional ordination models—room several !","code":""},{"path":[]},{"path":"/index.html","id":"contribute","dir":"","previous_headings":"acknowledgments","what":"contribute","title":"A Tidyverse Extension for Ordinations and Biplots","text":"feedback package welcome! encounter confusion errors, create issue, minimal reproducible example feasible. requests, suggestions, implementations new features, feel free create issue submit pull request. Methods additional ordination classes (see methods-*.r scripts R folder) especially welcome, new plot layers. Please try follow contributing guidelines respect Code Conduct.","code":""},{"path":"/index.html","id":"inspirations","dir":"","previous_headings":"acknowledgments","what":"inspirations","title":"A Tidyverse Extension for Ordinations and Biplots","text":"package originally inspired ggbiplot extension developed Vincent Q. Vu, Richard J Telford, Vilmantas Gegzna, among others. probably first brought biplots tidyverse framework. motivation unify variety ordination methods came several books articles Michael Greenacre, particular Biplots Practice. Several answers CrossValidated, particular amoeba ttnphns, provided theoretical insights informed design choices. Thomas Lin Pedersen’s tidygraph prequel ggraph finally induced shift downstream generation scatterplots upstream handling manipulating models. Additional design elements features informed monograph Biplots textbook Understanding Biplots John C. Gower, David J. Hand, Sugnet Gardner–Lubbe, Niël J. Le Roux, volume Principal Components Analysis . T. Jolliffe.","code":""},{"path":"/index.html","id":"exposition","dir":"","previous_headings":"acknowledgments","what":"exposition","title":"A Tidyverse Extension for Ordinations and Biplots","text":"work presented (slideshow PDF) invited panel New Developments Graphing Multivariate Data Joint Statistical Meetings, 2022 August 8 Washington DC. ’m grateful Joyce Robbins invitation organizing fun first experience, Naomi Robbins chairing event, co-panelists Ursula Laa Hengrui Luo sharing sparking exciting ideas conversations. update presented ggplot2 extenders, elicited additional valuable feedback.","code":""},{"path":"/index.html","id":"resources","dir":"","previous_headings":"acknowledgments","what":"resources","title":"A Tidyverse Extension for Ordinations and Biplots","text":"Development package benefitted use equipment support colleagues UConn Health UF Health.","code":""},{"path":"/reference/annotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Annotate factors of 'tbl_ord' objects — annotation","title":"Annotate factors of 'tbl_ord' objects — annotation","text":"functions annotate matrix factors tbl_ords additional variables, retrieve annotations. unexported annotation_*() set_annotation_*() functions assign retrieve values \"*_annotation\" attributes x, must number rows get_*(x).","code":""},{"path":"/reference/annotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Annotate factors of 'tbl_ord' objects — annotation","text":"annot data.frame number rows get_*(x).","code":""},{"path":[]},{"path":"/reference/augmentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","title":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","text":"functions return data associated cases, variables, coordinates ordination object, attach object.","code":""},{"path":"/reference/augmentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","text":"","code":"recover_aug_rows(x)  recover_aug_cols(x)  recover_aug_coord(x)  augment_ord(x, .matrix = \"dims\")"},{"path":"/reference/augmentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","text":"x object class 'tbl_ord'. .matrix character string partially matched (lowercase) several indicators one matrices matrix decomposition used ordination. standard values \"rows\", \"cols\", \"dims\" ().","code":""},{"path":"/reference/augmentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","text":"recover_aug_*() functions return tibbles numbers rows recover_*(). augment_ord() returns augmented tbl_ord wrapped model unchanged.","code":""},{"path":"/reference/augmentation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Augment factors and coordinates of 'tbl_ord' objects — augmentation","text":"recover_aug_*() S3 methods produce tibbles values associated rows, columns, artificial coordinates object class 'tbl_ord'. first field tibble name, contains row, column, coordinate names. Additional fields contain information rows, columns, coordinates extracted ordination object. function augment_ord() returns ordination either matrix factors annotated result recover_aug_*(). way augment_ord() works like generics::augment(), popularized broom package, extracting information rows columns, differs returning annotated 'tbl_ord' rather 'tbl_df' object. advantage implementing separate methods rows, columns, artificial coordinates information contained original object becomes accessible user.","code":""},{"path":[]},{"path":"/reference/biplot-geoms.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience geoms for row and column matrix factors — biplot-geoms","title":"Convenience geoms for row and column matrix factors — biplot-geoms","text":"geometric element layers (geoms) pair conventional ggplot2 geoms stat_rows() stat_cols() order render elements one matrix factor tbl_ord. understand aesthetics corresponding conventional geoms.","code":""},{"path":"/reference/biplot-geoms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience geoms for row and column matrix factors — biplot-geoms","text":"","code":"geom_rows_point(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_point(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_path(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_path(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_polygon(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   rule = \"evenodd\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_polygon(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   rule = \"evenodd\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_contour(   mapping = NULL,   data = NULL,   stat = \"contour\",   position = \"identity\",   ...,   bins = NULL,   binwidth = NULL,   breaks = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_contour(   mapping = NULL,   data = NULL,   stat = \"contour\",   position = \"identity\",   ...,   bins = NULL,   binwidth = NULL,   breaks = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_density_2d(   mapping = NULL,   data = NULL,   stat = \"density_2d\",   position = \"identity\",   ...,   contour_var = \"density\",   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_density_2d(   mapping = NULL,   data = NULL,   stat = \"density_2d\",   position = \"identity\",   ...,   contour_var = \"density\",   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_density_2d_filled(   mapping = NULL,   data = NULL,   stat = \"density_2d_filled\",   position = \"identity\",   ...,   contour_var = \"density\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_density_2d_filled(   mapping = NULL,   data = NULL,   stat = \"density_2d_filled\",   position = \"identity\",   ...,   contour_var = \"density\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_text(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   check_overlap = FALSE,   size.unit = \"mm\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_text(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   check_overlap = FALSE,   size.unit = \"mm\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_label(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   label.padding = unit(0.25, \"lines\"),   label.r = unit(0.15, \"lines\"),   label.size = 0.25,   size.unit = \"mm\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_label(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   label.padding = unit(0.25, \"lines\"),   label.r = unit(0.15, \"lines\"),   label.size = 0.25,   size.unit = \"mm\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_text_repel(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   parse = FALSE,   ...,   box.padding = 0.25,   point.padding = 1e-06,   min.segment.length = 0.5,   arrow = NULL,   force = 1,   force_pull = 1,   max.time = 0.5,   max.iter = 10000,   max.overlaps = getOption(\"ggrepel.max.overlaps\", default = 10),   nudge_x = 0,   nudge_y = 0,   xlim = c(NA, NA),   ylim = c(NA, NA),   na.rm = FALSE,   show.legend = NA,   direction = c(\"both\", \"y\", \"x\"),   seed = NA,   verbose = FALSE,   inherit.aes = TRUE )  geom_cols_text_repel(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   parse = FALSE,   ...,   box.padding = 0.25,   point.padding = 1e-06,   min.segment.length = 0.5,   arrow = NULL,   force = 1,   force_pull = 1,   max.time = 0.5,   max.iter = 10000,   max.overlaps = getOption(\"ggrepel.max.overlaps\", default = 10),   nudge_x = 0,   nudge_y = 0,   xlim = c(NA, NA),   ylim = c(NA, NA),   na.rm = FALSE,   show.legend = NA,   direction = c(\"both\", \"y\", \"x\"),   seed = NA,   verbose = FALSE,   inherit.aes = TRUE )  geom_rows_label_repel(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   parse = FALSE,   ...,   box.padding = 0.25,   label.padding = 0.25,   point.padding = 1e-06,   label.r = 0.15,   label.size = 0.25,   min.segment.length = 0.5,   arrow = NULL,   force = 1,   force_pull = 1,   max.time = 0.5,   max.iter = 10000,   max.overlaps = getOption(\"ggrepel.max.overlaps\", default = 10),   nudge_x = 0,   nudge_y = 0,   xlim = c(NA, NA),   ylim = c(NA, NA),   na.rm = FALSE,   show.legend = NA,   direction = c(\"both\", \"y\", \"x\"),   seed = NA,   verbose = FALSE,   inherit.aes = TRUE )  geom_cols_label_repel(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   parse = FALSE,   ...,   box.padding = 0.25,   label.padding = 0.25,   point.padding = 1e-06,   label.r = 0.15,   label.size = 0.25,   min.segment.length = 0.5,   arrow = NULL,   force = 1,   force_pull = 1,   max.time = 0.5,   max.iter = 10000,   max.overlaps = getOption(\"ggrepel.max.overlaps\", default = 10),   nudge_x = 0,   nudge_y = 0,   xlim = c(NA, NA),   ylim = c(NA, NA),   na.rm = FALSE,   show.legend = NA,   direction = c(\"both\", \"y\", \"x\"),   seed = NA,   verbose = FALSE,   inherit.aes = TRUE )  geom_rows_axis(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   axis_labels = TRUE,   axis_ticks = TRUE,   axis_text = TRUE,   by = NULL,   num = NULL,   tick_length = 0.025,   text_dodge = 0.03,   label_dodge = 0.03,   ...,   axis.colour = NULL,   axis.color = NULL,   axis.alpha = NULL,   label.angle = 0,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   tick.linewidth = 0.25,   tick.colour = NULL,   tick.color = NULL,   tick.alpha = NULL,   text.size = 2.6,   text.angle = 0,   text.hjust = 0.5,   text.vjust = 0.5,   text.family = NULL,   text.fontface = NULL,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_axis(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   axis_labels = TRUE,   axis_ticks = TRUE,   axis_text = TRUE,   by = NULL,   num = NULL,   tick_length = 0.025,   text_dodge = 0.03,   label_dodge = 0.03,   ...,   axis.colour = NULL,   axis.color = NULL,   axis.alpha = NULL,   label.angle = 0,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   tick.linewidth = 0.25,   tick.colour = NULL,   tick.color = NULL,   tick.alpha = NULL,   text.size = 2.6,   text.angle = 0,   text.hjust = 0.5,   text.vjust = 0.5,   text.family = NULL,   text.fontface = NULL,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_pointranges(   mapping = NULL,   data = NULL,   stat = \"center\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_pointranges(   mapping = NULL,   data = NULL,   stat = \"center\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_lineranges(   mapping = NULL,   data = NULL,   stat = \"center\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_lineranges(   mapping = NULL,   data = NULL,   stat = \"center\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_isoline(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   isoline_text = TRUE,   by = NULL,   num = NULL,   text_dodge = 0.03,   ...,   text.size = 3,   text.angle = 0,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_isoline(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   isoline_text = TRUE,   by = NULL,   num = NULL,   text_dodge = 0.03,   ...,   text.size = 3,   text.angle = 0,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_text_radiate(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_text_radiate(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_vector(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   arrow = default_arrow,   lineend = \"round\",   linejoin = \"mitre\",   vector_labels = TRUE,   ...,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_vector(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   arrow = default_arrow,   lineend = \"round\",   linejoin = \"mitre\",   vector_labels = TRUE,   ...,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_bagplot(   mapping = NULL,   data = NULL,   stat = \"bagplot\",   position = \"identity\",   ...,   bag.linewidth = sync(),   bag.linetype = sync(),   bag.colour = \"black\",   bag.color = NULL,   bag.fill = sync(),   bag.alpha = NA,   median.shape = 21L,   median.stroke = sync(),   median.size = 5,   median.colour = sync(),   median.color = NULL,   median.fill = \"white\",   median.alpha = NA,   fence.linewidth = 0.25,   fence.linetype = 0L,   fence.colour = sync(),   fence.color = NULL,   fence.fill = sync(),   fence.alpha = 0.25,   outlier.shape = sync(),   outlier.stroke = sync(),   outlier.size = sync(),   outlier.colour = sync(),   outlier.color = NULL,   outlier.fill = NA,   outlier.alpha = NA,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_bagplot(   mapping = NULL,   data = NULL,   stat = \"bagplot\",   position = \"identity\",   ...,   bag.linewidth = sync(),   bag.linetype = sync(),   bag.colour = \"black\",   bag.color = NULL,   bag.fill = sync(),   bag.alpha = NA,   median.shape = 21L,   median.stroke = sync(),   median.size = 5,   median.colour = sync(),   median.color = NULL,   median.fill = \"white\",   median.alpha = NA,   fence.linewidth = 0.25,   fence.linetype = 0L,   fence.colour = sync(),   fence.color = NULL,   fence.fill = sync(),   fence.alpha = 0.25,   outlier.shape = sync(),   outlier.stroke = sync(),   outlier.size = sync(),   outlier.colour = sync(),   outlier.color = NULL,   outlier.fill = NA,   outlier.alpha = NA,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_rule(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   axis_labels = TRUE,   axis_ticks = TRUE,   axis_text = TRUE,   by = NULL,   num = NULL,   snap_rule = TRUE,   tick_length = 0.025,   text_dodge = 0.03,   label_dodge = 0.03,   ...,   axis.colour = NULL,   axis.color = NULL,   axis.alpha = NULL,   label.angle = 0,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   tick.linewidth = 0.25,   tick.colour = NULL,   tick.color = NULL,   tick.alpha = NULL,   text.size = 2.6,   text.angle = 0,   text.hjust = 0.5,   text.vjust = 0.5,   text.family = NULL,   text.fontface = NULL,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_rule(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   axis_labels = TRUE,   axis_ticks = TRUE,   axis_text = TRUE,   by = NULL,   num = NULL,   snap_rule = TRUE,   tick_length = 0.025,   text_dodge = 0.03,   label_dodge = 0.03,   ...,   axis.colour = NULL,   axis.color = NULL,   axis.alpha = NULL,   label.angle = 0,   label.colour = NULL,   label.color = NULL,   label.alpha = NULL,   tick.linewidth = 0.25,   tick.colour = NULL,   tick.color = NULL,   tick.alpha = NULL,   text.size = 2.6,   text.angle = 0,   text.hjust = 0.5,   text.vjust = 0.5,   text.family = NULL,   text.fontface = NULL,   text.colour = NULL,   text.color = NULL,   text.alpha = NULL,   parse = FALSE,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_rows_interpolation(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   new_data = NULL,   type = c(\"centroid\", \"sequence\"),   arrow = default_arrow,   ...,   point.fill = NA,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_cols_interpolation(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   new_data = NULL,   type = c(\"centroid\", \"sequence\"),   arrow = default_arrow,   ...,   point.fill = NA,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/biplot-geoms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience geoms for row and column matrix factors — biplot-geoms","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... Additional arguments passed ggplot2::layer(). na.rm Passed ggplot2::layer(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow Arrow specification, created grid::arrow(). rule Either \"evenodd\" \"winding\". polygons holes drawn (using subgroup aesthetic) argument defines hole coordinates interpreted. See examples grid::pathGrob() explanation. bins Number contour bins. Overridden breaks. binwidth width contour bins. Overridden bins. breaks One : Numeric vector set contour breaks function takes range data binwidth input returns breaks output. function can created formula (e.g. ~ fullseq(.x, .y)). Overrides binwidth bins. default, vector length ten pretty() breaks. contour_var Character string identifying variable contour . Can one \"density\", \"ndensity\", \"count\". See section computed variables details. parse TRUE, labels parsed expressions displayed described ?plotmath. nudge_x, nudge_y Horizontal vertical adjustment nudge labels . Useful offsetting text points, particularly discrete scales. jointly specified position. check_overlap TRUE, text overlaps previous text layer plotted. check_overlap happens draw time order data. Therefore data arranged label column calling geom_text(). Note argument supported geom_label(). size.unit size aesthetic interpreted: millimetres (\"mm\", default), points (\"pt\"), centimetres (\"cm\"), inches (\"\"), picas (\"pc\"). label.padding Amount padding around label. Defaults 0.25 lines. label.r Radius rounded corners. Defaults 0.15 lines. label.size Size label border, mm. box.padding Amount padding around bounding box, unit number. Defaults 0.25. (Default unit lines, units can specified passing unit(x, \"units\")). point.padding Amount padding around labeled point, unit number. Defaults 0. (Default unit lines, units can specified passing unit(x, \"units\")). min.segment.length Skip drawing segments shorter , unit number. Defaults 0.5. (Default unit lines, units can specified passing unit(x, \"units\")). force Force repulsion overlapping text labels. Defaults 1. force_pull Force attraction text label corresponding data point. Defaults 1. max.time Maximum number seconds try resolve overlaps. Defaults 0.5. max.iter Maximum number iterations try resolve overlaps. Defaults 10000. max.overlaps Exclude text labels overlap many things. text label, count many text labels data points overlaps, exclude text label many overlaps. Defaults 10. xlim, ylim Limits x y axes. Text labels constrained limits. default, text labels constrained entire plot area. direction direction stairs: 'vh' vertical horizontal, 'hv' horizontal vertical, 'mid' step half-way adjacent x-values. seed Random seed passed set.seed. Defaults NA, means set.seed called. verbose TRUE, diagnostics repel algorithm printed axis_labels, axis_ticks, axis_text Logical; whether include labels, tick marks, text value marks along axes. , num Intervals elements number elements; specify one. tick_length Numeric; length tick marks, proportion minimum plot width height. text_dodge Numeric; orthogonal distance tick mark text axis, proportion minimum plot width height. label_dodge Numeric; orthogonal distance axis label axis, proportion minimum plot width height. axis.colour, axis.color, axis.alpha Default aesthetics axes. Set NULL inherit data's aesthetics. label.angle, label.colour, label.color, label.alpha Default aesthetics labels. Set NULL inherit data's aesthetics. tick.linewidth, tick.colour, tick.color, tick.alpha Default aesthetics tick marks. Set NULL inherit data's aesthetics. text.size, text.angle, text.hjust, text.vjust, text.family, text.fontface, text.colour, text.color, text.alpha Default aesthetics tick mark labels. Set NULL inherit data's aesthetics. isoline_text Logical; whether include text value marks along isolines. vector_labels Logical; whether include labels radiating outward vectors. bag.linetype, bag.linewidth, bag.colour, bag.color, bag.fill, bag.alpha Default aesthetics bags. Set sync() inherit data's aesthetics NULL use data's aesthetics. median.shape, median.stroke, median.size, median.colour, median.color, median.fill, median.alpha Default aesthetics medians. Set sync() inherit data's aesthetics NULL use data's aesthetics. fence.linetype, fence.linewidth, fence.colour, fence.color, fence.fill, fence.alpha Default aesthetics fences. Set sync() inherit data's aesthetics NULL use data's aesthetics. outlier.shape, outlier.stroke, outlier.size, outlier.colour, outlier.color, outlier.fill, outlier.alpha Default aesthetics outliers. Set sync() inherit data's aesthetics NULL use data's aesthetics. snap_rule Logical; whether snap rule segments grid values. new_data list (best structured data.frame) row (geom_cols_interpolation()) column (geom_rows_interpolation()) values interpolate. type Character value matched \"centroid\" \"sequence\"; type operations used visualize interpolation. point.fill Default aesthetics markers. Set NULL inherit data's aesthetics.","code":""},{"path":"/reference/biplot-geoms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience geoms for row and column matrix factors — biplot-geoms","text":"ggproto layer.","code":""},{"path":[]},{"path":"/reference/biplot-geoms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convenience geoms for row and column matrix factors — biplot-geoms","text":"","code":"# compute log-ratio analysis of Freestone primary class composition measurements glass %>%   ordinate(cols = c(SiO2, Al2O3, CaO, FeO, MgO),            model = lra, compositional = TRUE) %>%   confer_inertia(\"rows\") %>%   print() -> glass_lra #> # A tbl_ord of class 'lra': (68 x 4) x (5 x 4)' #> # 4 coordinates: LRSV1, LRSV2, ..., LRSV4 #> #  #> # Rows (principal): [ 68 x 4 | 12 ] #>    LRSV1  LRSV2     LRSV3 ... |   weight Site    Anal  Context Form  #>                               |    <dbl> <chr>   <chr> <chr>   <chr> #> 1 0.0925 0.0929  0.0156       | 1 0.0147 Bet El… 1     L14.B1… Chunk #> 2 0.0905 0.0591 -0.0439       | 2 0.0147 Bet El… 2     L14.B1… Chunk #> 3 0.0844 0.0333 -0.000492 ... | 3 0.0147 Bet El… 3     L14.B1… Chunk #> 4 0.0647 0.0211  0.0267       | 4 0.0147 Bet El… 4     L14.B1… Chunk #> 5 0.0635 0.0257  0.0239       | 5 0.0147 Bet El… 5     L14.B1… Chunk #> # ℹ 63 more rows     | # ℹ 63 more rows #> # ℹ 7 more variables: TiO2 <dbl>, #> #   MnO <dbl>, Na2O <dbl>, #> #   K2O <dbl>, P2O5 <dbl>, #> #   Cl <dbl>, SO3 <dbl> #> #  #> # Columns (standard): [ 5 x 4 | 2 ] #>      LRSV1  LRSV2  LRSV3 ... |   name   weight #>                              |   <chr>   <dbl> #> 1 -0.00548  0.338  0.237     | 1 SiO2  0.852   #> 2  4.15    -0.714 -2.50  ... | 2 Al2O3 0.0313  #> 3 -0.517   -2.95  -0.126     | 3 CaO   0.0976  #> 4  0.553    2.23  -9.57      | 4 FeO   0.00524 #> 5 -5.61     0.790 -4.47      | 5 MgO   0.0138  # row-principal biplot with ordinate-wise standard deviations glass_lra %>%   ggbiplot(aes(color = Site), sec.axes = \"cols\") +   theme_biplot() +   scale_color_brewer(type = \"qual\", palette = 6) +   geom_cols_text(stat = \"chull\", aes(label = name), color = \"#444444\") +   geom_rows_lineranges(fun.data = mean_sdl, linewidth = .75) +   geom_rows_point(alpha = .5) +   ggtitle(     \"Row-principal LRA biplot of Freestone glass measurements\",     \"Ranges 2 sample standard deviations from centroids\"   )   # principal components analysis of glass composition measurements glass[, c(5L, 7L, 8L, 10L, 11L)] %>%   princomp(cor = TRUE) %>%   as_tbl_ord() %>%   cbind_rows(site = glass$Site, form = glass$Form) %>%   augment_ord() %>%   print() -> glass_pca #> # A tbl_ord of class 'princomp': (68 x 5) x (5 x 5)' #> # 5 coordinates: Comp.1, Comp.2, ..., Comp.5 #> #  #> # Rows (principal): [ 68 x 5 | 3 ] #>   Comp.1  Comp.2 Comp.3 ... |   .element site         form  #>                             |   <chr>    <chr>        <chr> #> 1   2.01 0.585    0.940     | 1 score    Bet Eli'ezer Chunk #> 2   2.55 0.513   -1.71      | 2 score    Bet Eli'ezer Chunk #> 3   1.64 0.0977   0.131 ... | 3 score    Bet Eli'ezer Chunk #> 4   1.07 0.00734  1.20      | 4 score    Bet Eli'ezer Chunk #> 5   1.07 0.00573  1.31      | 5 score    Bet Eli'ezer Chunk #> # ℹ 63 more rows     | # ℹ 63 more rows #>  #> #  #> # Columns (standard): [ 5 x 5 | 4 ] #>   Comp.1 Comp.2  Comp.3 ... |   name  center scale .element #>                             |   <chr>  <dbl> <dbl> <chr>    #> 1  0.476  0.383  0.388      | 1 SiO2  71.7   3.16  active   #> 2  0.488 -0.492 -0.0574 ... | 2 Al2O3  2.64  0.956 active   #> 3  0.383  0.234 -0.873      | 3 FeO    0.442 0.159 active   #> 4 -0.425  0.580 -0.153      | 4 MgO    1.15  0.913 active   #> 5 -0.456 -0.469 -0.247      | 5 CaO    8.18  1.36  active   # note that column standard coordinates are unit vectors rowSums(get_cols(glass_pca) ^ 2) #>  SiO2 Al2O3   FeO   MgO   CaO  #>     1     1     1     1     1  # plot column standard coordinates with a unit circle underlaid glass_pca %>%   ggbiplot(aes(label = name), sec.axes = \"cols\") +   theme_biplot() +   geom_rows_point(aes(color = site, shape = form), elements = \"score\") +   geom_unit_circle(alpha = .5, scale.factor = 3) +   geom_cols_vector()"},{"path":"/reference/biplot-stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience stats for row and column matrix factors — biplot-stats","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"statistical transformations (stats) adapt conventional ggplot2 stats one matrix factor tbl_ord, lieu stat_rows() stat_cols(). accept parameters corresponding conventional stats.","code":""},{"path":"/reference/biplot-stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"","code":"stat_rows_density_2d(   mapping = NULL,   data = NULL,   geom = \"density_2d\",   position = \"identity\",   ...,   contour = TRUE,   contour_var = \"density\",   n = 100,   h = NULL,   adjust = c(1, 1),   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_cols_density_2d(   mapping = NULL,   data = NULL,   geom = \"density_2d\",   position = \"identity\",   ...,   contour = TRUE,   contour_var = \"density\",   n = 100,   h = NULL,   adjust = c(1, 1),   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_rows_density_2d_filled(   mapping = NULL,   data = NULL,   geom = \"density_2d_filled\",   position = \"identity\",   ...,   contour = TRUE,   contour_var = \"density\",   n = 100,   h = NULL,   adjust = c(1, 1),   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_cols_density_2d_filled(   mapping = NULL,   data = NULL,   geom = \"density_2d_filled\",   position = \"identity\",   ...,   contour = TRUE,   contour_var = \"density\",   n = 100,   h = NULL,   adjust = c(1, 1),   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_rows_ellipse(   mapping = NULL,   data = NULL,   geom = \"path\",   position = \"identity\",   ...,   type = \"t\",   level = 0.95,   segments = 51,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_cols_ellipse(   mapping = NULL,   data = NULL,   geom = \"path\",   position = \"identity\",   ...,   type = \"t\",   level = 0.95,   segments = 51,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_rows_center(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   fun.data = NULL,   fun = NULL,   fun.center = NULL,   fun.min = NULL,   fun.max = NULL,   fun.ord = NULL,   fun.args = list() )  stat_cols_center(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   fun.data = NULL,   fun = NULL,   fun.center = NULL,   fun.min = NULL,   fun.max = NULL,   fun.ord = NULL,   fun.args = list() )  stat_rows_star(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   fun.data = NULL,   fun = NULL,   fun.center = NULL,   fun.ord = NULL,   fun.args = list() )  stat_cols_star(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   fun.data = NULL,   fun = NULL,   fun.center = NULL,   fun.ord = NULL,   fun.args = list() )  stat_rows_chull(   mapping = NULL,   data = NULL,   geom = \"polygon\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_chull(   mapping = NULL,   data = NULL,   geom = \"polygon\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_peel(   mapping = NULL,   data = NULL,   geom = \"polygon\",   position = \"identity\",   num = NULL,   by = 1L,   breaks = c(0.5),   cut = c(\"above\", \"below\"),   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_peel(   mapping = NULL,   data = NULL,   geom = \"polygon\",   position = \"identity\",   num = NULL,   by = 1L,   breaks = c(0.5),   cut = c(\"above\", \"below\"),   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_cone(   mapping = NULL,   data = NULL,   geom = \"path\",   position = \"identity\",   origin = FALSE,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_cone(   mapping = NULL,   data = NULL,   geom = \"path\",   position = \"identity\",   origin = FALSE,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_depth(   mapping = NULL,   data = NULL,   geom = \"contour\",   position = \"identity\",   contour = TRUE,   contour_var = \"depth\",   notion = \"zonoid\",   notion_params = list(),   n = 100L,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_depth(   mapping = NULL,   data = NULL,   geom = \"contour\",   position = \"identity\",   contour = TRUE,   contour_var = \"depth\",   notion = \"zonoid\",   notion_params = list(),   n = 100L,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_depth_filled(   mapping = NULL,   data = NULL,   geom = \"contour_filled\",   position = \"identity\",   contour = TRUE,   contour_var = \"depth\",   notion = \"zonoid\",   notion_params = list(),   n = 100L,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_depth_filled(   mapping = NULL,   data = NULL,   geom = \"contour_filled\",   position = \"identity\",   contour = TRUE,   contour_var = \"depth\",   notion = \"zonoid\",   notion_params = list(),   n = 100L,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_scale(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   mult = 1 )  stat_cols_scale(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   show.legend = NA,   inherit.aes = TRUE,   ...,   mult = 1 )  stat_rows_spantree(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   engine = \"mlpack\",   method = \"euclidean\",   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_spantree(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   engine = \"mlpack\",   method = \"euclidean\",   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_bagplot(   mapping = NULL,   data = NULL,   geom = \"bagplot\",   position = \"identity\",   fraction = 0.5,   coef = 3,   median = TRUE,   fence = TRUE,   outliers = TRUE,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_cols_bagplot(   mapping = NULL,   data = NULL,   geom = \"bagplot\",   position = \"identity\",   fraction = 0.5,   coef = 3,   median = TRUE,   fence = TRUE,   outliers = TRUE,   show.legend = NA,   inherit.aes = TRUE,   ... )  stat_rows_rule(   mapping = NULL,   data = NULL,   geom = \"rule\",   position = \"identity\",   fun.lower = \"minpp\",   fun.upper = \"maxpp\",   fun.offset = \"minabspp\",   fun.args = list(),   referent = NULL,   show.legend = NA,   inherit.aes = TRUE,   ref_subset = NULL,   ref_elements = \"active\",   ... )  stat_cols_rule(   mapping = NULL,   data = NULL,   geom = \"rule\",   position = \"identity\",   fun.lower = \"minpp\",   fun.upper = \"maxpp\",   fun.offset = \"minabspp\",   fun.args = list(),   referent = NULL,   show.legend = NA,   inherit.aes = TRUE,   ref_subset = NULL,   ref_elements = \"active\",   ... )  stat_rows_projection(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   referent = NULL,   ref_subset = NULL,   ref_elements = \"active\",   ...,   show.legend = NA,   inherit.aes = TRUE )  stat_cols_projection(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   referent = NULL,   ref_subset = NULL,   ref_elements = \"active\",   ...,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/biplot-stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... Additional arguments passed ggplot2::layer(). contour TRUE, contour results 2d density estimation. contour_var Character string identifying variable contour . Can one \"density\", \"ndensity\", \"count\". See section computed variables details. n Number grid points direction. h Bandwidth (vector length two). NULL, estimated using MASS::bandwidth.nrd(). adjust multiplicative bandwidth adjustment used 'h' 'NULL'. makes possible adjust bandwidth still using bandwidth estimator. example, adjust = 1/2 means use half default bandwidth. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). type type ellipse. default \"t\" assumes multivariate t-distribution, \"norm\" assumes multivariate normal distribution. \"euclid\" draws circle radius equal level, representing euclidean distance center. ellipse probably appear circular unless coord_fixed() applied. level level draw ellipse, , type=\"euclid\", radius circle drawn. segments number segments used drawing ellipse. fun.data function given complete data return data frame variables ymin, y, ymax. fun.center Deprecated alias fun. fun.min, fun, fun.max Alternatively, supply three individual functions passed vector values return single number. fun.ord Alternatively ggplot2::stat_summary_bin() parameters, supply summary function takes matrix input returns named column summary vector. Overridden fun.data fun, used together fun.min fun.max. fun.args Optional additional arguments passed functions. num positive integer; number hulls peel. Pass Inf hulls. positive integer; frequency include consecutive hulls, pairs num. breaks numeric vector fractions (0 1) data contain hull; overridden num. cut Character; one \"\" \"\", indicating whether hull contain least breaks data, respectively. origin Logical; whether include origin transformed data. Defaults FALSE. notion Character; name depth function (passed ddalpha::depth.()). notion_params List additional parameters passed via ... ddalpha::depth.(). mult Numeric value used scale coordinates. engine single character string specifying package implementation use; \"mlpack\", \"vegan\", \"ade4\". method Passed stats::dist() engine \"vegan\" \"ade4\", ignored \"mlpack\". fraction Fraction data include bag. coef Scale factor fence relative bag. median, fence, outliers Logical indicators whether include median, fence, outliers composite output. fun.lower, fun.upper, fun.offset Functions used determine limits rules translations axes projections referent onto axes onto normal vectors. referent reference data set; see Details. ref_elements, ref_subset Analogues elements subset applied referent.","code":""},{"path":"/reference/biplot-stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"ggproto layer.","code":""},{"path":"/reference/biplot-stats.html","id":"ordination-aesthetics","dir":"Reference","previous_headings":"","what":"Ordination aesthetics","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"statistical transformation compatible convenience function ord_aes(). transformations (e.g. stat_center()) commute projection lower (1 2)-dimensional biplot space. detect aesthetics form ..coord[0-9]+, ..coord1 ..coord2 converted x y remaining ignored. transformations (e.g. stat_spantree()) yield different results lower-dimensional biplot computed versus projection. stat layer detects aesthetics, transformation performed projection, results first two dimensions returned x y. small number transformations (stat_rule()) incompatible ordination aesthetics accept ord_aes() without warning.","code":""},{"path":[]},{"path":"/reference/biplot-stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convenience stats for row and column matrix factors — biplot-stats","text":"","code":"iris_pca <- ordinate(iris, prcomp, cols = seq(4), scale. = TRUE) # NB: Non-standard aesthetics are handled as in version > 3.5.1; see: # https://github.com/tidyverse/ggplot2/issues/6191 # This prevents `scale_color_discrete(aesthetics = ...)` from synching them. ggbiplot(iris_pca) +   stat_rows_bagplot(     aes(fill = Species),     median_gp = list(color = sync()),     fence_gp = list(linewidth = 0.25),     outlier_gp = list(shape = \"asterisk\")   ) +   scale_color_discrete(name = \"Species\", aesthetics = c(\"color\", \"fill\")) +   geom_cols_vector(aes(label = name))  ggbiplot(iris_pca) +   stat_rows_bagplot(     aes(fill = Species, color = Species),     median_gp = list(color = sync()),     fence_gp = list(linewidth = 0.25),     outlier_gp = list(shape = \"asterisk\")   ) +   geom_cols_vector(aes(label = name))   # scaled PCA of Anderson iris measurements iris[, -5] %>%   princomp(cor = TRUE) %>%   as_tbl_ord() %>%   mutate_rows(species = iris$Species) %>%   print() -> iris_pca #> # A tbl_ord of class 'princomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: Comp.1, Comp.2, ..., Comp.4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>   Comp.1 Comp.2  Comp.3 ... |   species #>                             |   <fct>   #> 1  -2.26  0.480  0.128      | 1 setosa  #> 2  -2.08 -0.674  0.235      | 2 setosa  #> 3  -2.36 -0.342 -0.0442 ... | 3 setosa  #> 4  -2.30 -0.597 -0.0913     | 4 setosa  #> 5  -2.39  0.647 -0.0157     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 0 ] #>   Comp.1 Comp.2 Comp.3 ... |  #>                            |  #> 1  0.521 0.377   0.720     |  #> 2 -0.269 0.923  -0.244 ... |  #> 3  0.580 0.0245 -0.142     |  #> 4  0.565 0.0669 -0.634     |  # row-principal biplot with depth median-based stars iris_pca %>%   ggbiplot(aes(color = species)) +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   stat_rows_star(alpha = .5, fun.ord = \"depth_median\") +   geom_rows_point(alpha = .5) +   stat_rows_center(fun.ord = \"depth_median\", size = 4, shape = 1L) +   ggtitle(     \"Row-principal PCA biplot of Anderson iris measurements\",     \"Segments connect each observation to its within-species depth median\"   )   # correspondence analysis of combined female and male hair and eye color data HairEyeColor %>%   rowSums(dims = 2L) %>%   MASS::corresp(nf = 2L) %>%   as_tbl_ord() %>%   augment_ord() %>%   print() -> hec_ca #> # A tbl_ord of class 'correspondence': (4 x 2) x (4 x 2)' #> # 2 coordinates: Can1 and Can2 #> #  #> # Rows (standard): [ 4 x 2 | 1 ] #>     Can1   Can2 |   name  #>                 |   <chr> #> 1 -1.10   1.44  | 1 Black #> 2 -0.324 -0.219 | 2 Brown #> 3 -0.283 -2.14  | 3 Red   #> 4  1.83   0.467 | 4 Blond #> #  #> # Columns (standard): [ 4 x 2 | 1 ] #>     Can1   Can2 |   name  #>                 |   <chr> #> 1 -1.08   0.592 | 1 Brown #> 2  1.20   0.556 | 2 Blue  #> 3 -0.465 -1.12  | 3 Hazel #> 4  0.354 -2.27  | 4 Green # inertia across artificial coordinates (all singular values < 1) get_inertia(hec_ca) #>       Can1       Can2  #> 0.20877265 0.02222661  # in row-principal biplot, row coordinates are weighted averages of columns # (and vice-versa) hec_ca %>%   confer_inertia(\"rows\") %>%   ggbiplot(aes(color = .matrix, fill = .matrix, shape = .matrix)) +   theme_bw() +   stat_cols_chull(alpha = .1) +   geom_cols_point() +   geom_rows_point() +   ggtitle(\"Row-principal CA of hair & eye color\")   # centered principal components analysis of U.S. personal expenditure data USPersonalExpenditure %>%   prcomp() %>%   as_tbl_ord() %>%   augment_ord() %>%   # allow radiating text to exceed plotting window   ggbiplot(aes(label = name), clip = \"off\",            sec.axes = \"cols\", scale.factor = 50) +   geom_rows_label(size = 3) +   # omit labels in the conical hull without the origin   geom_cols_vector(vector_labels = FALSE) +   stat_cols_cone(linetype = \"dotted\") +   geom_cols_vector(stat = \"cone\", vector_labels = TRUE, color = \"transparent\") +   ggtitle(     \"U.S. Personal Expenditure data, 1940-1960\",     \"Row-principal biplot of centered PCA\"   )  # compute row-principal components of scaled iris measurements iris[, -5] %>%   prcomp(scale = TRUE) %>%   as_tbl_ord() %>%   mutate_rows(species = iris$Species) %>%   print() -> iris_pca #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   species #>                            |   <fct>   #> 1 -2.26 -0.478  0.127      | 1 setosa  #> 2 -2.07  0.672  0.234      | 2 setosa  #> 3 -2.36  0.341 -0.0441 ... | 3 setosa  #> 4 -2.29  0.595 -0.0910     | 4 setosa  #> 5 -2.38 -0.645 -0.0157     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 0 ] #>      PC1     PC2    PC3 ... |  #>                             |  #> 1  0.521 -0.377   0.720     |  #> 2 -0.269 -0.923  -0.244 ... |  #> 3  0.580 -0.0245 -0.142     |  #> 4  0.565 -0.0669 -0.634     |  # row-principal biplot with centroids and confidence elliptical disks iris_pca %>%   ggbiplot(aes(color = species)) +   theme_bw() +   geom_rows_point() +   geom_polygon(     aes(fill = species),     color = NA, alpha = .25, stat = \"rows_ellipse\"   ) +   geom_cols_vector(color = \"#444444\") +   scale_color_brewer(     type = \"qual\", palette = 2,     aesthetics = c(\"color\", \"fill\")   ) +   ggtitle(     \"Row-principal PCA biplot of Anderson iris measurements\",     \"Overlaid with 95% confidence disks\"   )   # hull peeling with breaks below judge_pca <- ordinate(USJudgeRatings, princomp, cols = -c(1, 12)) ggbiplot(judge_pca, axis.type = \"predictive\") +   geom_cols_axis() +   geom_rows_point(elements = \"score\") +   stat_rows_peel(     aes(alpha = after_stat(hull)), color = \"black\", elements = \"score\",     breaks = c(.9, .5, .1), cut = \"below\"   ) #> Warning: Using alpha for a discrete variable is not advised.   # hull peeling by groups iris_pca <- ordinate(iris, cols = 1:4, model = prcomp) ggbiplot(iris_pca) +   geom_rows_point(aes(color = Species), shape = \"circle open\") +   stat_rows_peel(     aes(fill = Species, alpha = after_stat(hull)),     num = 3   ) #> Warning: Using alpha for a discrete variable is not advised.   # unscaled PCA iris_pca <- ordinate(iris, cols = 1:4, model = prcomp) # biplot canvas iris_biplot <-    iris_pca %>%   ggbiplot(aes(color = Species, label = name), axis.type = \"predictive\") +   geom_rows_point() +   geom_cols_axis(aes(center = center)) # print select cases top_cases <- c(1, 51, 101) iris[top_cases, ] #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species #> 1            5.1         3.5          1.4         0.2     setosa #> 51           7.0         3.2          4.7         1.4 versicolor #> 101          6.3         3.3          6.0         2.5  virginica # subset variables length_vars <- c(1, 3) iris[, length_vars] %>%   aggregate(by = iris[, \"Species\", drop = FALSE], FUN = mean) #>      Species Sepal.Length Petal.Length #> 1     setosa        5.006        1.462 #> 2 versicolor        5.936        4.260 #> 3  virginica        6.588        5.552  # project all cases onto all axes iris_biplot + stat_rows_projection()  # project all cases onto select axes iris_biplot + stat_rows_projection(ref_subset = length_vars) #> `subset` will be applied after data are restricted to active elements. #> This message is displayed once per session.   # project select cases onto all axes iris_biplot + stat_rows_projection(subset = top_cases)  # project select cases onto select axes iris_biplot + stat_rows_projection(subset = top_cases, ref_subset = length_vars)   # project select cases onto manually provided axes iris_cols <- as.data.frame(get_cols(iris_pca))[c(1, 2), ] iris_biplot + stat_rows_projection(subset = top_cases, referent = iris_cols)   # project selected cases onto selected axes in full-dimensional space iris_pca %>%   ggbiplot(ord_aes(iris_pca, color = Species, label = name),            axis.type = \"predictive\") +   geom_rows_point() +   geom_cols_axis(aes(center = center)) +   stat_rows_projection(subset = top_cases, ref_subset = length_vars)   # default (standardized) linear discriminant analysis glass_lda <- MASS::lda(Site ~ SiO2 + Al2O3 + FeO + MgO + CaO, glass) # bestow 'tbl_ord' class & augment observation, centroid, and variable fields as_tbl_ord(glass_lda) %>%   augment_ord() %>%   print() -> glass_lda #> # A tbl_ord of class 'lda': (72 x 3) x (5 x 3)' #> # 3 coordinates: LD1, LD2, LD3 #> #  #> # Rows (principal): [ 72 x 3 | 5 ] #>     LD1    LD2      LD3 |   name         prior counts grouping #>                         |   <chr>        <dbl>  <int> <chr>    #> 1  1.82 -1.21  -0.672   | 1 Apollonia    0.132      9 Apollon… #> 2 -5.62  0.364 -0.00398 | 2 Banias       0.265     18 Banias   #> 3  2.47  1.63   0.0833  | 3 Bet Eli'ez…  0.397     27 Bet Eli… #> 4  1.31 -2.84   0.277   | 4 Dor          0.206     14 Dor      #> 5  2.99  2.03  -1.22    | 5 1           NA         NA Bet Eli… #> # ℹ 67 more rows | # ℹ 67 more rows #> # ℹ 1 more variable: .element <chr> #> #  #> # Columns (standard): [ 5 x 3 | 2 ] #>        LD1    LD2    LD3 |   name  .element #>                          |   <chr> <chr>    #> 1  0.00681 0.618   0.468 | 1 SiO2  active   #> 2  2.05    1.04   -0.660 | 2 Al2O3 active   #> 3 -1.93    0.165   2.44  | 3 FeO   active   #> 4 -1.76    1.82   -0.599 | 4 MgO   active   #> 5 -0.275   0.0942  1.42  | 5 CaO   active   # row-standard biplot glass_lda %>%   confer_inertia(1) %>%   ggbiplot(aes(shape = grouping)) +   theme_bw() + theme_biplot() +   geom_rows_point(size = 4) +   geom_rows_point(elements = \"score\") +   stat_cols_rule(     aes(label = name), color = \"#888888\", num = 8L,     ref_elements = \"score\", fun.offset = function(x) minabspp(x, p = .1),     text.size = 2.5, label_dodge = .04   ) +   scale_shape_manual(values = c(2L, 3L, 0L, 5L)) +   ggtitle(     \"LDA of Freestone glass measurements\",     \"Row-standard biplot of standardized LDA\"   )  # contribution LDA of sites on measurements glass_lda <-   lda_ord(Site ~ SiO2 + Al2O3 + FeO + MgO + CaO, glass,           axes.scale = \"contribution\") # bestow 'tbl_ord' class & augment observation, centroid, and variable fields as_tbl_ord(glass_lda) %>%   augment_ord() %>%   print() -> glass_lda #> # A tbl_ord of class 'lda_ord': (72 x 3) x (5 x 3)' #> # 3 coordinates: LD1, LD2, LD3 #> #  #> # Rows (principal): [ 72 x 3 | 5 ] #>     LD1    LD2      LD3 |   name         prior counts grouping #>                         |   <chr>        <dbl>  <int> <chr>    #> 1  1.82 -1.21  -0.672   | 1 Apollonia    0.132      9 Apollon… #> 2 -5.62  0.364 -0.00398 | 2 Banias       0.265     18 Banias   #> 3  2.47  1.63   0.0833  | 3 Bet Eli'ez…  0.397     27 Bet Eli… #> 4  1.31 -2.84   0.277   | 4 Dor          0.206     14 Dor      #> 5  2.99  2.03  -1.22    | 5 1           NA         NA Bet Eli… #> # ℹ 67 more rows | # ℹ 67 more rows #> # ℹ 1 more variable: .element <chr> #> #  #> # Columns (standard): [ 5 x 3 | 2 ] #>       LD1    LD2     LD3 |   name  .element #>                          |   <chr> <chr>    #> 1  0.166   0.871  0.160  | 1 SiO2  active   #> 2  0.663   0.164  0.0442 | 2 Al2O3 active   #> 3 -0.142   0.112  0.192  | 3 FeO   active   #> 4 -0.680   0.367 -0.0694 | 4 MgO   active   #> 5 -0.0804 -0.151  0.941  | 5 CaO   active   # symmetric biplot glass_lda %>%   confer_inertia(.5) %>%   ggbiplot(aes(shape = grouping)) +   theme_bw() + theme_biplot() +   geom_rows_point() +   stat_rows_density_2d(elements = \"score\", alpha = .5, color = \"#444444\") +   stat_cols_rule(     aes(label = name), geom = \"axis\", color = \"#888888\", num = 8L,     ref_elements = \"active\", fun.offset = function(x) minabspp(x, p = .1),     label_dodge = 0.04, text.size = 2.5, text_dodge = .025   ) +   scale_shape_manual(values = c(16L, 17L, 15L, 18L)) +   ggtitle(     \"LDA of Freestone glass measurements\",     \"Symmetric biplot of contribution LDA\"   )   if (FALSE) { # \\dontrun{ # classical multidimensional scaling of road distances between European cities euro_mds <- ordinate(eurodist, cmdscale_ord, k = 11) # monoplot of city locations euro_plot <- euro_mds %>%   negate_ord(\"PCo2\") %>%   ggbiplot() +   geom_cols_text(aes(label = name), size = 3) print(euro_plot) # biplot with minimal spanning tree based on plotting window distances euro_plot +   stat_cols_spantree(     engine = \"mlpack\",     alpha = .5, linetype = \"dotted\"   ) # biplot with minimal spanning tree based on full-dimensional distances euro_plot +   stat_cols_spantree(     ord_aes(euro_mds), engine = \"mlpack\",     alpha = .5, linetype = \"dotted\"   ) } # }"},{"path":"/reference/conference.html","id":null,"dir":"Reference","previous_headings":"","what":"Confer inertia to factors of a 'tbl_ord' object — conference","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"Re-distribute inertia rows columns ordination.","code":""},{"path":"/reference/conference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"","code":"recover_conference(x)  # Default S3 method recover_conference(x)  get_conference(x)  revert_conference(x)  confer_inertia(x, p)"},{"path":"/reference/conference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"x tbl_ord. p Numeric vector length 1 2. length 1, proportion inertia assigned cases, remainder 1 - p assigned variables. length 2, proportions inertia assigned cases variables, respectively.","code":""},{"path":"/reference/conference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"recover_conference() returns (statically implemented) distribution inertia rows columns stored model. confer_inertia() returns tbl_ord specified distribution inertia wrapped model unchanged. get_conference() returns distribution currently conferred.","code":""},{"path":"/reference/conference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"inertia singular value decomposition \\(X=UDV'\\) consists squares singular values (diagonal elements \\(D\\)), represents variance, likened physical inertia, directions orthogonal singular vectors (columns \\(U\\) \\(V\\)). Biplots superimpose projections rows columns \\(X\\) onto coordinate vectors, scaled proportion total inertia: \\(UD^p\\) \\(VD^q\\). biplot balanced \\(p+q=1\\). Read Orlov (2013) conferring inertia PCA. recover_conference(), like recoverers, S3 method exported convenience intended used directly. Note: case \"inertia\" attribute rectangular matrix, one may able confer entirely cases (p = 1) entirely variables (p = 0).","code":""},{"path":"/reference/conference.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"Orlov K (2013) Answer \"Algebra LDA. Fisher discrimination power variable Linear Discriminant Analysis\". CrossValidated, accessed 2019-07-26. https://stats.stackexchange.com//83114/68743","code":""},{"path":[]},{"path":"/reference/conference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confer inertia to factors of a 'tbl_ord' object — conference","text":"","code":"# illustrative ordination: correspendence analysis of hair & eye data haireye_ca <- ordinate(   as.data.frame(rowSums(HairEyeColor, dims = 2L)),   cols = everything(), model = MASS::corresp ) print(haireye_ca) #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.10  | 1 Black #> 2 -0.324 | 2 Brown #> 3 -0.283 | 3 Red   #> 4  1.83  | 4 Blond #> #  #> # Columns (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.08  | 1 Brown #> 2  1.20  | 2 Blue  #> 3 -0.465 | 3 Hazel #> 4  0.354 | 4 Green  # check distribution of inertia get_conference(haireye_ca) #> [1] 0 0 # confer inertia to rows, then to columns confer_inertia(haireye_ca, \"rows\") #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (principal): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -0.505 | 1 Black #> 2 -0.148 | 2 Brown #> 3 -0.130 | 3 Red   #> 4  0.835 | 4 Blond #> #  #> # Columns (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.08  | 1 Brown #> 2  1.20  | 2 Blue  #> 3 -0.465 | 3 Hazel #> 4  0.354 | 4 Green confer_inertia(haireye_ca, \"columns\") #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.10  | 1 Black #> 2 -0.324 | 2 Brown #> 3 -0.283 | 3 Red   #> 4  1.83  | 4 Blond #> #  #> # Columns (principal): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -0.492 | 1 Brown #> 2  0.547 | 2 Blue  #> 3 -0.213 | 3 Hazel #> 4  0.162 | 4 Green # confer inertia symmetrically (haireye_ca <- confer_inertia(haireye_ca, \"symmetric\")) #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (symmetric): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -0.746 | 1 Black #> 2 -0.219 | 2 Brown #> 3 -0.192 | 3 Red   #> 4  1.24  | 4 Blond #> #  #> # Columns (symmetric): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -0.728 | 1 Brown #> 2  0.810 | 2 Blue  #> 3 -0.315 | 3 Hazel #> 4  0.239 | 4 Green # check redistributed inertia get_conference(haireye_ca) #> [1] 0.5 0.5 # restore default distribution of inertia revert_conference(haireye_ca) #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.10  | 1 Black #> 2 -0.324 | 2 Brown #> 3 -0.283 | 3 Red   #> 4  1.83  | 4 Blond #> #  #> # Columns (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.08  | 1 Brown #> 2  1.20  | 2 Blue  #> 3 -0.465 | 3 Hazel #> 4  0.354 | 4 Green"},{"path":"/reference/coord_scaffold.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience coordinate system for scaffolding axes — coord_scaffold","title":"Convenience coordinate system for scaffolding axes — coord_scaffold","text":"2- (3-) dimensional biplots require coordinates lie scale may additionally benefit square plotting window. CoordRect provides control coordinate window aspect ratios, convenience CoordScaffold system also fixes coordinate aspect ratio 1 gives user control plotting window.","code":""},{"path":"/reference/coord_scaffold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience coordinate system for scaffolding axes — coord_scaffold","text":"","code":"coord_scaffold(   window_ratio = 1,   xlim = NULL,   ylim = NULL,   expand = TRUE,   clip = \"on\" )"},{"path":"/reference/coord_scaffold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience coordinate system for scaffolding axes — coord_scaffold","text":"window_ratio aspect ratio plotting window xlim, ylim Limits x y axes. expand TRUE, default, adds small expansion factor limits ensure data axes overlap. FALSE, limits taken exactly data xlim/ylim. clip drawing clipped extent plot panel? setting \"\" (default) means yes, setting \"\" means . cases, default \"\" changed, setting clip = \"\" can cause unexpected results. allows drawing data points anywhere plot, including plot margins. limits set via xlim ylim data points fall outside limits, data points may show places axes, legend, plot title, plot margins.","code":""},{"path":"/reference/coord_scaffold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convenience coordinate system for scaffolding axes — coord_scaffold","text":"","code":"# resize the plot to see that the specified aspect ratio is maintained p <- ggplot(mtcars, aes(mpg, hp/10)) + geom_point() p + coord_scaffold()  p + coord_scaffold(window_ratio = 2)   # prevent rescaling in response to `theme()` aspect ratio p <- ggplot(mtcars, aes(mpg, hp/5)) + geom_point() p + coord_equal() + theme(aspect.ratio = 1)  p + coord_scaffold() + theme(aspect.ratio = 1)   # NB: `theme(aspect.ratio = )` overrides `Coord*$aspect`: p + coord_fixed(ratio = 1) + theme(aspect.ratio = 1)  p + coord_scaffold(window_ratio = 2) + theme(aspect.ratio = 1)"},{"path":"/reference/dplyr-verbs.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr verbs for tbl_ord factors — dplyr-verbs","title":"dplyr verbs for tbl_ord factors — dplyr-verbs","text":"functions adapt dplyr verbs factors tbl_ord. raw verbs defined tbl_ords; instead, verb two analogues, corresponding two matrix factors. rely common workhorse function, takes composition dplyr verb annotation_*, applied factor, removes variables corresponding coordinates already annotated, assigns new \"*_annotation\" attribute .data (see annotation). Note functions generics extended classes.","code":""},{"path":"/reference/dplyr-verbs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr verbs for tbl_ord factors — dplyr-verbs","text":"","code":"pull_factor(.data, var = -1, .matrix)  pull_rows(.data, var = -1)  pull_cols(.data, var = -1)  rename_rows(.data, ...)  rename_cols(.data, ...)  select_rows(.data, ...)  select_cols(.data, ...)  mutate_rows(.data, ...)  mutate_cols(.data, ...)  transmute_rows(.data, ...)  transmute_cols(.data, ...)  cbind_rows(.data, ..., elements = \"all\")  cbind_cols(.data, ..., elements = \"all\")  left_join_rows(.data, ...)  left_join_cols(.data, ...)"},{"path":"/reference/dplyr-verbs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr verbs for tbl_ord factors — dplyr-verbs","text":".data object class 'tbl_ord'. var variable specified dplyr::pull(). .matrix character string partially matched (lowercase) several indicators one matrices matrix decomposition used ordination. standard values \"rows\", \"cols\", \"dims\" (). ... Comma-separated unquoted expressions , e.g., dplyr::select(). elements Character vector; elements factor render graphical elements. One \"\" (default), \"active\", supplementary element type defined specific class methods (e.g. \"score\" 'factanal', 'lda_ord', 'cancord_ord' \"intraset\" \"interset\" 'cancor_ord').","code":""},{"path":"/reference/dplyr-verbs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr verbs for tbl_ord factors — dplyr-verbs","text":"tbl_ord; wrapped model unchanged.","code":""},{"path":"/reference/dplyr-verbs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr verbs for tbl_ord factors — dplyr-verbs","text":"","code":"# illustrative ordination: LDA of iris data (iris_lda <- ordinate(iris, cols = 1:4, lda_ord, grouping = iris$Species)) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 2 more variables: #> #   .element <chr>, Species <fct> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active    # extract a coordinate or annotation head(pull_rows(iris_lda, Species)) #> [1] <NA>   <NA>   <NA>   setosa setosa setosa #> Levels: setosa versicolor virginica pull_cols(iris_lda, LD2) #> [1] -0.02410215 -2.16452123  0.93192121 -2.83918785  # rename an annotation rename_cols(iris_lda, species = name) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 2 more variables: #> #   .element <chr>, Species <fct> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   species      .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active    # select annotations select_rows(iris_lda, species = name, .element) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 2 ] #>     LD1    LD2 |   species    .element #>                |   <chr>      <chr>    #> 1  7.61 -0.215 | 1 setosa     active   #> 2 -1.83  0.728 | 2 versicolor active   #> 3 -5.78 -0.513 | 3 virginica  active   #> 4  8.06 -0.300 | 4 NA         score    #> 5  7.13  0.787 | 5 NA         score    #> # ℹ 148 more rows | # ℹ 148 more rows #>  #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active    # create, modify, and delete annotations mutate_cols(iris_lda, vec.length = sqrt(LD1^2 + LD2^2)) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 2 more variables: #> #   .element <chr>, Species <fct> #> #  #> # Columns (standard): [ 4 x 2 | 3 ] #>      LD1     LD2 |   name         .element vec.length #>                  |   <chr>        <chr>         <dbl> #> 1  0.829 -0.0241 | 1 Sepal.Length active        0.830 #> 2  1.53  -2.16   | 2 Sepal.Width  active        2.65  #> 3 -2.20   0.932  | 3 Petal.Length active        2.39  #> 4 -2.81  -2.84   | 4 Petal.Width  active        3.99  transmute_cols(iris_lda, vec.length = sqrt(LD1^2 + LD2^2)) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 2 more variables: #> #   .element <chr>, Species <fct> #> #  #> # Columns (standard): [ 4 x 2 | 1 ] #>      LD1     LD2 |   vec.length #>                  |        <dbl> #> 1  0.829 -0.0241 | 1      0.830 #> 2  1.53  -2.16   | 2      2.65  #> 3 -2.20   0.932  | 3      2.39  #> 4 -2.81  -2.84   | 4      3.99   # bind data frames of annotations iris_medians <-   stats::aggregate(iris[, 1:4], median, by = iris[, 5, drop = FALSE]) # TODO: Requirement of `.elements` for matching is fragile. iris_lda %>%   # retain '.element' in order to match by `elements`   select_rows(.element) %>%   cbind_rows(iris_medians, elements = \"active\") #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   .element Species    Sepal.Length #>                |   <chr>    <fct>             <dbl> #> 1  7.61 -0.215 | 1 active   setosa              5   #> 2 -1.83  0.728 | 2 active   versicolor          5.9 #> 3 -5.78 -0.513 | 3 active   virginica           6.5 #> 4  8.06 -0.300 | 4 score    NA                 NA   #> 5  7.13  0.787 | 5 score    NA                 NA   #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 3 more variables: #> #   Sepal.Width <dbl>, #> #   Petal.Length <dbl>, #> #   Petal.Width <dbl> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active   iris_lda %>%   select_rows(name, Species) %>%   left_join_rows(iris_medians, by = c(\"name\" = \"Species\")) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 6 ] #>     LD1    LD2 |   name       Species Sepal.Length #>                |   <chr>      <fct>          <dbl> #> 1  7.61 -0.215 | 1 setosa     NA               5   #> 2 -1.83  0.728 | 2 versicolor NA               5.9 #> 3 -5.78 -0.513 | 3 virginica  NA               6.5 #> 4  8.06 -0.300 | 4 NA         setosa          NA   #> 5  7.13  0.787 | 5 NA         setosa          NA   #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 3 more variables: #> #   Sepal.Width <dbl>, #> #   Petal.Length <dbl>, #> #   Petal.Width <dbl> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active"},{"path":"/reference/draw-key.html","id":null,"dir":"Reference","previous_headings":"","what":"Biplot key drawing functions — draw-key","title":"Biplot key drawing functions — draw-key","text":"key drawing functions supplement built ggplot2 producing legends suitable biplots.","code":""},{"path":"/reference/draw-key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Biplot key drawing functions — draw-key","text":"","code":"draw_key_line(data, params, size)  draw_key_crosslines(data, params, size)  draw_key_crosspoint(data, params, size)"},{"path":"/reference/draw-key.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Biplot key drawing functions — draw-key","text":"data single row data frame containing scaled aesthetics display key params list additional parameters supplied geom. size Width height key mm.","code":""},{"path":"/reference/draw-key.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Biplot key drawing functions — draw-key","text":"grid grob.","code":""},{"path":"/reference/draw-key.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Biplot key drawing functions — draw-key","text":"draw_key_line() horizontal counterpart ggplot2::draw_key_vline(). draw_key_crosslines() superimposes two keys, draw_key_crosspoint() additionally superimposes oversized ggplot2::draw_key_point().","code":""},{"path":[]},{"path":"/reference/draw-key.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Biplot key drawing functions — draw-key","text":"","code":"# scaled PCA of Anderson iris data with ranges and confidence intervals iris[, -5] %>%   prcomp(scale = TRUE) %>%   as_tbl_ord() %>%   confer_inertia(1) %>%   augment_ord() %>%   mutate_rows(species = iris$Species) %>%   ggbiplot(aes(color = species)) +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_rows_lineranges(fun.data = mean_sdl, linewidth = .75) +   geom_rows_density_2d(contour = TRUE, alpha = .5) +   geom_cols_vector(aes(label = name), color = \"#444444\", size = 3) +   ggtitle(     \"Row-principal PCA biplot of Anderson iris data\",     \"Ranges 2 sample standard deviations from centroids\"   ) #> Warning: Duplicated aesthetics after name standardisation: contour"},{"path":"/reference/format.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a tbl_ord for printing — format","title":"Format a tbl_ord for printing — format","text":"methods base::format() base::print() render (usually ) tidy readout tbl_ord consistent across original ordination classes.","code":""},{"path":"/reference/format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a tbl_ord for printing — format","text":"","code":"# S3 method for class 'tbl_ord' format(   x,   width = NULL,   ...,   n = NULL,   max_extra_cols = NULL,   max_footer_lines = NULL )  # S3 method for class 'tbl_ord' print(   x,   width = NULL,   ...,   n = NULL,   max_extra_cols = NULL,   max_footer_lines = NULL )"},{"path":"/reference/format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format a tbl_ord for printing — format","text":"x tbl_ord. width Width text output generate. defaults NULL, means use width option. ... Additional arguments. n Number(s) rows show matrix factor, handled tibble::format.tbl(). length 1, apply matrix factors. pass NULL one factor, sure pass list, e.g. n = list(6, NULL). max_extra_cols Number extra columns print abbreviated information , width small entire tibble. NULL, max_extra_cols option used. previously defined n_extra argument soft-deprecated. max_footer_lines Maximum number footer lines. NULL, max_footer_lines option used.","code":""},{"path":"/reference/format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format a tbl_ord for printing — format","text":"format() method returns vector strings elegantly printed print() method, returns tbl_ord invisibly.","code":""},{"path":"/reference/format.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Format a tbl_ord for printing — format","text":"format print methods class 'tbl_ord' adapted class 'tbl_df' class 'tbl_graph' tidygraph package. Note: format() function tedius easily modularized without invoking recoverers, annotation, augmentation multiple times, thereby significantly reducing performance.","code":""},{"path":"/reference/format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format a tbl_ord for printing — format","text":"","code":"iris_pca <- ordinate(iris[1:4], prcomp)  # single value applies to both factors print(iris_pca, n = 10) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>      PC1     PC2     PC3 ... |  #>                              |  #>  1 -2.68 -0.319   0.0279     |  #>  2 -2.71  0.177   0.210      |  #>  3 -2.89  0.145  -0.0179     |  #>  4 -2.75  0.318  -0.0316     |  #>  5 -2.73 -0.327  -0.0901 ... |  #>  6 -2.28 -0.741  -0.169      |  #>  7 -2.82  0.0895 -0.258      |  #>  8 -2.63 -0.163   0.0219     |  #>  9 -2.89  0.578  -0.0208     |  #> 10 -2.67  0.114   0.198      |  #> # ℹ 140 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1     PC2     PC3 ... |   name         center #>                               |   <chr>         <dbl> #> 1  0.361  -0.657   0.582      | 1 Sepal.Length   5.84 #> 2 -0.0845 -0.730  -0.598  ... | 2 Sepal.Width    3.06 #> 3  0.857   0.173  -0.0762     | 3 Petal.Length   3.76 #> 4  0.358   0.0755 -0.546      | 4 Petal.Width    1.20  # double values apply to factors in order print(iris_pca, n = c(6, 2)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2     PC3 ... |  #>                            |  #> 1 -2.68 -0.319  0.0279     |  #> 2 -2.71  0.177  0.210      |  #> 3 -2.89  0.145 -0.0179 ... |  #> 4 -2.75  0.318 -0.0316     |  #> 5 -2.73 -0.327 -0.0901     |  #> 6 -2.28 -0.741 -0.169      |  #> # ℹ 144 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1    PC2    PC3 ... |   name         center #>                             |   <chr>         <dbl> #> 1  0.361  -0.657  0.582 ... | 1 Sepal.Length   5.84 #> 2 -0.0845 -0.730 -0.598     | 2 Sepal.Width    3.06 #> # ℹ 2 more rows     | # ℹ 2 more rows #>   # use `list()` to pass `NULL` (for default) to only one factor print(iris_pca, n = list(2, NULL)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2    PC3 ... |  #>                           |  #> 1 -2.68 -0.319 0.0279 ... |  #> 2 -2.71  0.177 0.210      |  #> # ℹ 148 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1     PC2     PC3 ... |   name         center #>                               |   <chr>         <dbl> #> 1  0.361  -0.657   0.582      | 1 Sepal.Length   5.84 #> 2 -0.0845 -0.730  -0.598  ... | 2 Sepal.Width    3.06 #> 3  0.857   0.173  -0.0762     | 3 Petal.Length   3.76 #> 4  0.358   0.0755 -0.546      | 4 Petal.Width    1.20 print(iris_pca, n = list(NULL, 2)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2     PC3 ... |  #>                            |  #> 1 -2.68 -0.319  0.0279     |  #> 2 -2.71  0.177  0.210      |  #> 3 -2.89  0.145 -0.0179 ... |  #> 4 -2.75  0.318 -0.0316     |  #> 5 -2.73 -0.327 -0.0901     |  #> # ℹ 145 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1    PC2    PC3 ... |   name         center #>                             |   <chr>         <dbl> #> 1  0.361  -0.657  0.582 ... | 1 Sepal.Length   5.84 #> 2 -0.0845 -0.730 -0.598     | 2 Sepal.Width    3.06 #> # ℹ 2 more rows     | # ℹ 2 more rows #>"},{"path":"/reference/geom_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"geom_interpolation() renders geometric construction interpolates new data matrix (row column) element entries artificial coordinates.","code":""},{"path":"/reference/geom_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"","code":"geom_interpolation(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   new_data = NULL,   type = c(\"centroid\", \"sequence\"),   arrow = default_arrow,   ...,   point.fill = NA,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/geom_interpolation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. new_data list (best structured data.frame) row (geom_cols_interpolation()) column (geom_rows_interpolation()) values interpolate. type Character value matched \"centroid\" \"sequence\"; type operations used visualize interpolation. arrow Specification arrows, created grid::arrow(), else NULL arrows. ... Additional arguments passed ggplot2::layer(). point.fill Default aesthetics markers. Set NULL inherit data's aesthetics. na.rm Passed ggplot2::layer(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders().","code":""},{"path":"/reference/geom_interpolation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"Interpolation answers following question: Given new data element might appeared row (respectively, column) singular-value-decomposed data matrix, expect marker element appear biplot? solution vector sum column (row) units weighted values new row (column). Gower, Gardner–Lubbe, & le Roux (2011) provide two visualizations calculation: tail--head sequence weighted units (type = \"sequence\"), centroid weighted units scaled number units (type = \"centroid\"). WARNING: layer appropriate axes standard coordinates (usually confer_inertia(p = \"rows\")) interpolative calibration (ggbiplot(axis.type = \"interpolative\")).","code":""},{"path":"/reference/geom_interpolation.html","id":"biplot-layers","dir":"Reference","previous_headings":"","what":"Biplot layers","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"ggbiplot() uses ggplot2::fortify() internally produce single data frame .matrix column distinguishing subjects (\"rows\") variables (\"cols\"). stat layers stat_rows() stat_cols() simply filter data frame one two. geom layers geom_rows_*() geom_cols_*() call corresponding stat order render plot elements corresponding factor matrix. geom_dims_*() selects default matrix based common practice, e.g. points rows arrows columns.","code":""},{"path":"/reference/geom_interpolation.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"geom_interpolation() requires custom interpolate aesthetic, tells internals columns new_data parameter contain variables used interpolation. Except rare cases, new_data contain rows columns ordinated data interpolate set name (procured augment_ord()). geom_interpolation() additionally understands following aesthetics (required aesthetics bold): alpha colour linetype size fill shape stroke center, scale group","code":""},{"path":"/reference/geom_interpolation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"Gower JC, Gardner–Lubbe S, & le Roux NJ (2011) Understanding Biplots. Wiley, ISBN: 978-0-470-01255-0. https://www.wiley.com/go/biplots","code":""},{"path":[]},{"path":"/reference/geom_interpolation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render interpolation of new rows from columns (or vice-versa) — geom_interpolation","text":"","code":"iris[, -5] %>%   prcomp(scale = TRUE) %>%   as_tbl_ord() %>%   print() -> iris_pca #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2     PC3 ... |  #>                            |  #> 1 -2.26 -0.478  0.127      |  #> 2 -2.07  0.672  0.234      |  #> 3 -2.36  0.341 -0.0441 ... |  #> 4 -2.29  0.595 -0.0910     |  #> 5 -2.38 -0.645 -0.0157     |  #> # ℹ 145 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 0 ] #>      PC1     PC2    PC3 ... |  #>                             |  #> 1  0.521 -0.377   0.720     |  #> 2 -0.269 -0.923  -0.244 ... |  #> 3  0.580 -0.0245 -0.142     |  #> 4  0.565 -0.0669 -0.634     |  iris_pca <- mutate_rows(iris_pca, species = iris$Species) iris_pca <- augment_ord(iris_pca)  # sample of one of each species, with some missing measurements new_data <- iris[c(42, 61, 110), seq(5, 1), drop = FALSE] new_data[3L, \"Sepal.Width\"] <- NA new_data[1L, \"Petal.Length\"] <- NA print(new_data) #>        Species Petal.Width Petal.Length Sepal.Width Sepal.Length #> 42      setosa         0.3           NA         2.3          4.5 #> 61  versicolor         1.0          3.5         2.0          5.0 #> 110  virginica         2.5          6.1          NA          7.2  # centroid interpolation method iris_pca %>%   augment_ord() %>%   mutate_rows(obs = dplyr::row_number()) %>%   mutate_cols(measure = name) %>%   ggbiplot() +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_origin(marker = \"cross\", alpha = .5) +   geom_cols_interpolation(     aes(center = center, scale = scale, interpolate = name), size = 3,     new_data = new_data, type = \"centroid\", alpha = .5   ) +   geom_rows_text(aes(label = obs, color = species), alpha = .5, size = 3)   # missing an entire variable new_data$Petal.Length <- NULL  # sequence interpolation method iris_pca %>%   augment_ord() %>%   mutate_rows(obs = dplyr::row_number()) %>%   mutate_cols(measure = name) %>%   ggbiplot() +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_origin(marker = \"circle\", alpha = .5) +   geom_cols_interpolation(     aes(center = center, scale = scale, interpolate = name,         linetype = measure),     new_data = new_data, type = \"sequence\", alpha = .5   ) +   geom_rows_text(aes(label = obs, color = species), alpha = .5, size = 3)"},{"path":"/reference/geom_origin.html","id":null,"dir":"Reference","previous_headings":"","what":"Marker or unit circle at the origin — geom_origin","title":"Marker or unit circle at the origin — geom_origin","text":"geom_origin() renders symbol, either set crosshairs circle, origin. geom_unit_circle() renders unit circle, centered origin radius 1.","code":""},{"path":"/reference/geom_origin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marker or unit circle at the origin — geom_origin","text":"","code":"geom_origin(   mapping = NULL,   data = NULL,   marker = \"crosshairs\",   radius = unit(0.04, \"snpc\"),   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE )  geom_unit_circle(   mapping = NULL,   data = NULL,   segments = 60,   scale.factor = 1,   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE )"},{"path":"/reference/geom_origin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marker or unit circle at the origin — geom_origin","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). marker symbol drawn origin; matched \"crosshairs\" \"circle\". radius grid::unit() object sets radius crosshairs circle. ... Additional arguments passed ggplot2::layer(). na.rm Passed ggplot2::layer(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). segments number segments used drawing circle. scale.factor circle radius; remain default value 1 passed value ggbiplot(). (imperfect fix may changed future version.)","code":""},{"path":"/reference/geom_origin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marker or unit circle at the origin — geom_origin","text":"ggproto layer.","code":""},{"path":"/reference/geom_origin.html","id":"biplot-layers","dir":"Reference","previous_headings":"","what":"Biplot layers","title":"Marker or unit circle at the origin — geom_origin","text":"ggbiplot() uses ggplot2::fortify() internally produce single data frame .matrix column distinguishing subjects (\"rows\") variables (\"cols\"). stat layers stat_rows() stat_cols() simply filter data frame one two. geom layers geom_rows_*() geom_cols_*() call corresponding stat order render plot elements corresponding factor matrix. geom_dims_*() selects default matrix based common practice, e.g. points rows arrows columns.","code":""},{"path":"/reference/geom_origin.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Marker or unit circle at the origin — geom_origin","text":"geom_origin() accepts aesthetics. geom_unit_circle() understands following aesthetics (none required): linetype linewidth colour alpha","code":""},{"path":[]},{"path":"/reference/geom_origin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marker or unit circle at the origin — geom_origin","text":"","code":"ggplot(seals, aes(delta_long, delta_lat)) +   theme_void() +   geom_origin() +   geom_point(alpha = .25)  # center each group separately iris %>%   split(~ Species) %>%   lapply(subset, select = -c(Species)) %>%   lapply(scale, center = TRUE, scale = FALSE) %>%   lapply(as.data.frame) %>%   unsplit(iris$Species) %>%   transform(Species = iris$Species) ->   iris_ctr ggplot(iris_ctr, aes(Petal.Width, Petal.Length)) +   coord_equal() +   facet_wrap(vars(Species)) +   geom_unit_circle() +   geom_point()  # scale group mean differences uniformly iris_ctr %>%   subset(select = -c(Species)) %>%   scale(center = FALSE, scale = TRUE) %>%   transform(Species = iris$Species) %>%   ggplot(aes(Petal.Width, Petal.Length)) +   coord_equal() +   facet_wrap(vars(Species)) +   geom_unit_circle() +   geom_point()"},{"path":"/reference/ggbiplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Biplots following the grammar of graphics — ggbiplot","title":"Biplots following the grammar of graphics — ggbiplot","text":"Build biplot visualization ordination data wrapped tbl_ord object.","code":""},{"path":"/reference/ggbiplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Biplots following the grammar of graphics — ggbiplot","text":"","code":"ggbiplot(   ordination = NULL,   mapping = aes(x = 1, y = 2),   axis.type = \"interpolative\",   xlim = NULL,   ylim = NULL,   expand = TRUE,   clip = \"on\",   axis.percents = TRUE,   sec.axes = NULL,   scale.factor = \"inertia\",   scale_rows = NULL,   scale_cols = NULL,   ... )  ord_aes(ordination, ...)"},{"path":"/reference/ggbiplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Biplots following the grammar of graphics — ggbiplot","text":"ordination tbl_ord. mapping List default aesthetic mappings use biplot. default assigns first two coordinates aesthetics x y. assignments must supplied layer added plot. axis.type Character, partially matched; whether build \"interpolative\" (default) \"predictive\" biplot. latter requires x y mapped shared coordinates, shared coordinates mapped , inertia conferred entirely onto one matrix factor. NB: option implemented linear techniques (ED, SVD, & PCA). xlim, ylim Limits x y axes. expand TRUE, default, adds small expansion factor limits ensure data axes overlap. FALSE, limits taken exactly data xlim/ylim. clip drawing clipped extent plot panel? setting \"\" (default) means yes, setting \"\" means . cases, default \"\" changed, setting clip = \"\" can cause unexpected results. allows drawing data points anywhere plot, including plot margins. limits set via xlim ylim data points fall outside limits, data points may show places axes, legend, plot title, plot margins. axis.percents Whether concatenate default axis labels inertia percentages. sec.axes Matrix factor character specify secondary set axes. scale.factor Either numeric value, used scale secondary axes primary axes, name harmonizing function (currently \"range\" \"inertia\"); ignored sec.axes specified. scale_rows, scale_cols Either character name numeric variable get_*(ordination) numeric vector length nrow(get_*(ordination)), used scale coordinates matrix factors. ... Additional arguments passed ggplot2::fortify(); see fortify.tbl_ord().","code":""},{"path":"/reference/ggbiplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Biplots following the grammar of graphics — ggbiplot","text":"ggplot object.","code":""},{"path":"/reference/ggbiplot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Biplots following the grammar of graphics — ggbiplot","text":"ggbiplot() produces ggplot object tbl_ord object ordination. baseline object default unadorned \"ggplot\"-class object p following differences ggplot2::ggplot() returns: p$mapping augmented .matrix = .matrix, expects either .matrix = \"rows\" .matrix = \"cols\" biplot. p$coordinates defaulted ggplot2::coord_equal() order faithfully render geometry ordination. optional parameters xlim, ylim, expand, clip passed coord_equal() default ggplot2 defaults. x y mapped coordinates ordination, axis.percents TRUE, p$labels$x p$labels$y defaulted coordinate names concatenated percentages inertia captured coordinates. p assigned class \"ggbiplot\" addition \"ggplot\". serves functional purpose currently. Furthermore, user may feed single integer values x y aesthetics, interpreted corresponding coordinates ordination. Currently 2-dimensional biplots supported, x y must take coordinate values. ord_aes() convenience function generates full-rank set coordinate aesthetics ..coord1, ..coord2, etc. mapped shared coordinates ordination object, along additional aesthetics processed internally ggplot2::aes(). axis.type parameter controls whether biplot interpolative predictive, though predictive biplots still experimental limited linear methods like PCA. Gower & Hand (1996) Gower, Gardner–Lubbe, & le Roux (2011) thoroughly explain construction interpretation predictive biplots.","code":""},{"path":"/reference/ggbiplot.html","id":"biplot-layers","dir":"Reference","previous_headings":"","what":"Biplot layers","title":"Biplots following the grammar of graphics — ggbiplot","text":"ggbiplot() uses ggplot2::fortify() internally produce single data frame .matrix column distinguishing subjects (\"rows\") variables (\"cols\"). stat layers stat_rows() stat_cols() simply filter data frame one two. geom layers geom_rows_*() geom_cols_*() call corresponding stat order render plot elements corresponding factor matrix. geom_dims_*() selects default matrix based common practice, e.g. points rows arrows columns.","code":""},{"path":"/reference/ggbiplot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Biplots following the grammar of graphics — ggbiplot","text":"Gower JC & Hand DJ (1996) Biplots. Chapman & Hall, ISBN: 0-412-71630-5. Gower JC, Gardner–Lubbe S, & le Roux NJ (2011) Understanding Biplots. Wiley, ISBN: 978-0-470-01255-0. https://www.wiley.com/go/biplots","code":""},{"path":[]},{"path":"/reference/ggbiplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Biplots following the grammar of graphics — ggbiplot","text":"","code":"# compute PCA of Anderson iris measurements iris[, -5] %>%   princomp(cor = TRUE) %>%   as_tbl_ord() %>%   confer_inertia(1) %>%   mutate_rows(species = iris$Species) %>%   mutate_cols(measure = gsub(\"\\\\.\", \" \", tolower(names(iris)[-5]))) %>%   print() -> iris_pca #> # A tbl_ord of class 'princomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: Comp.1, Comp.2, ..., Comp.4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>   Comp.1 Comp.2  Comp.3 ... |   species #>                             |   <fct>   #> 1  -2.26  0.480  0.128      | 1 setosa  #> 2  -2.08 -0.674  0.235      | 2 setosa  #> 3  -2.36 -0.342 -0.0442 ... | 3 setosa  #> 4  -2.30 -0.597 -0.0913     | 4 setosa  #> 5  -2.39  0.647 -0.0157     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 1 ] #>   Comp.1 Comp.2 Comp.3 ... |   measure      #>                            |   <chr>        #> 1  0.521 0.377   0.720     | 1 sepal length #> 2 -0.269 0.923  -0.244 ... | 2 sepal width  #> 3  0.580 0.0245 -0.142     | 3 petal length #> 4  0.565 0.0669 -0.634     | 4 petal width   # row-principal biplot with range-harmonized secondary axis iris_pca %>%   ggbiplot(aes(color = species), sec.axes = \"cols\", scale.factor = \"range\") +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_rows_point() +   geom_cols_vector(aes(label = measure), color = \"#444444\") +   ggtitle(     \"Row-principal PCA biplot of Anderson iris measurements\",     \"Variable loadings scaled to secondary axes\"   ) +   expand_limits(y = c(-1, 3.5))   # row-principal biplot with manually rescaled secondary axis iris_pca %>%   ggbiplot(aes(color = species), sec.axes = \"cols\", scale.factor = 2) +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_rows_point() +   geom_cols_vector(aes(label = measure), color = \"#444444\") +   ggtitle(     \"Row-principal PCA biplot of Anderson iris measurements\",     \"Variable loadings scaled to secondary axes\"   ) +   expand_limits(y = c(-1, 3.5))  # Performance measures can be regressed on the artificial coordinates of # ordinated vehicle specs. Because the ordination of specs ignores performance, # these coordinates will probably not be highly predictive. The gradient of each # performance measure along the artificial axes is visualized by projecting the # regression coefficients onto the ordination biplot.  # scaled principal components analysis of vehicle specs mtcars_specs_pca <- ordinate(   mtcars, cols = c(cyl, disp, hp, drat, wt, vs, carb),   model = ~ princomp(., cor = TRUE) ) # data frame of vehicle performance measures mtcars %>%   subset(select = c(mpg, qsec)) %>%   as.matrix() %>%   print() -> mtcars_perf #>                      mpg  qsec #> Mazda RX4           21.0 16.46 #> Mazda RX4 Wag       21.0 17.02 #> Datsun 710          22.8 18.61 #> Hornet 4 Drive      21.4 19.44 #> Hornet Sportabout   18.7 17.02 #> Valiant             18.1 20.22 #> Duster 360          14.3 15.84 #> Merc 240D           24.4 20.00 #> Merc 230            22.8 22.90 #> Merc 280            19.2 18.30 #> Merc 280C           17.8 18.90 #> Merc 450SE          16.4 17.40 #> Merc 450SL          17.3 17.60 #> Merc 450SLC         15.2 18.00 #> Cadillac Fleetwood  10.4 17.98 #> Lincoln Continental 10.4 17.82 #> Chrysler Imperial   14.7 17.42 #> Fiat 128            32.4 19.47 #> Honda Civic         30.4 18.52 #> Toyota Corolla      33.9 19.90 #> Toyota Corona       21.5 20.01 #> Dodge Challenger    15.5 16.87 #> AMC Javelin         15.2 17.30 #> Camaro Z28          13.3 15.41 #> Pontiac Firebird    19.2 17.05 #> Fiat X1-9           27.3 18.90 #> Porsche 914-2       26.0 16.70 #> Lotus Europa        30.4 16.90 #> Ford Pantera L      15.8 14.50 #> Ferrari Dino        19.7 15.50 #> Maserati Bora       15.0 14.60 #> Volvo 142E          21.4 18.60 # regress performance measures on principal components lm(mtcars_perf ~ get_rows(mtcars_specs_pca)) %>%   as_tbl_ord() %>%   augment_ord() %>%   print() -> mtcars_pca_lm #> # A tbl_ord of class 'mlm': (32 x 8) x (2 x 8)' #> # 8 coordinates: (Intercept), Comp.1, ..., Comp.7 #> #  #> # Rows: [ 32 x 8 | 1 ] #>   `(Intercept)` Comp.1 Comp.2 ... |   name              #>                                   |   <chr>             #> 1             1 -0.398 -1.12      | 1 Mazda RX4         #> 2             1 -0.294 -1.06      | 2 Mazda RX4 Wag     #> 3             1 -2.54   0.465 ... | 3 Datsun 710        #> 4             1 -0.601  1.75      | 4 Hornet 4 Drive    #> 5             1  1.61   0.837     | 5 Hornet Sportabout #> # ℹ 27 more rows     | # ℹ 27 more rows #>  #> #  #> # Columns: [ 2 x 8 | 1 ] #>   `(Intercept)` Comp.1 Comp.2 ... |   name  #>                                   |   <chr> #> 1          20.1 -2.41  -0.415 ... | 1 mpg   #> 2          17.8 -0.459  0.929     | 2 qsec  # regression biplot ggbiplot(mtcars_specs_pca, aes(label = name),          sec.axes = \"rows\", scale.factor = .5) +   theme_minimal() +   geom_rows_text(size = 3) +   geom_cols_vector(data = mtcars_pca_lm) +   expand_limits(x = c(-2.5, 2))   # multidimensional scaling based on a scaled cosine distance of vehicle specs cosine_dist <- function(x) {   x <- as.matrix(x)   num <- x %*% t(x)   denom_rt <- as.matrix(rowSums(x^2))   denom <- sqrt(denom_rt %*% t(denom_rt))   as.dist(1 - num / denom) } mtcars %>%   subset(select = c(cyl, disp, hp, drat, wt, vs, carb)) %>%   scale() %>%   cosine_dist() %>%   cmdscale() %>%   as.data.frame() ->   mtcars_specs_cmds # names must be consistent with `cmdscale_ord()` below names(mtcars_specs_cmds) <- c(\"PCo1\", \"PCo2\") # regress performance measures on principal coordinates lm(mtcars_perf ~ as.matrix(mtcars_specs_cmds)) %>%   as_tbl_ord() %>%   augment_ord() %>%   print() -> mtcars_cmds_lm #> # A tbl_ord of class 'mlm': (32 x 3) x (2 x 3)' #> # 3 coordinates: (Intercept), PCo1, PCo2 #> #  #> # Rows: [ 32 x 3 | 1 ] #>   `(Intercept)`   PCo1   PCo2 |   name              #>                               |   <chr>             #> 1             1 -0.238 -0.666 | 1 Mazda RX4         #> 2             1 -0.190 -0.685 | 2 Mazda RX4 Wag     #> 3             1 -0.934  0.224 | 3 Datsun 710        #> 4             1 -0.247  0.984 | 4 Hornet 4 Drive    #> 5             1  0.834  0.316 | 5 Hornet Sportabout #> # ℹ 27 more rows | # ℹ 27 more rows #>  #> #  #> # Columns: [ 2 x 3 | 1 ] #>   `(Intercept)`  PCo1  PCo2 |   name  #>                             |   <chr> #> 1          20.1 -6.19 0.160 | 1 mpg   #> 2          17.8 -1.31 2.38  | 2 qsec  # multidimensional scaling using `cmdscale_ord()` mtcars %>%   subset(select = c(cyl, disp, hp, drat, wt, vs, carb)) %>%   scale() %>%   cosine_dist() %>%   cmdscale_ord() %>%   as_tbl_ord() %>%   augment_ord() %>%   print() -> mtcars_specs_cmds_ord #> # A tbl_ord of class 'cmds_ord': (32 x 2) x (32 x 2)' #> # 2 coordinates: PCo1 and PCo2 #> #  #> # Rows (symmetric): [ 32 x 2 | 1 ] #>     PCo1   PCo2 |   name              #>                 |   <chr>             #> 1 -0.238 -0.666 | 1 Mazda RX4         #> 2 -0.190 -0.685 | 2 Mazda RX4 Wag     #> 3 -0.934  0.224 | 3 Datsun 710        #> 4 -0.247  0.984 | 4 Hornet 4 Drive    #> 5  0.834  0.316 | 5 Hornet Sportabout #> # ℹ 27 more rows | # ℹ 27 more rows #>  #> #  #> # Columns (symmetric): [ 32 x 2 | 1 ] #>     PCo1   PCo2 |   name              #>                 |   <chr>             #> 1 -0.238 -0.666 | 1 Mazda RX4         #> 2 -0.190 -0.685 | 2 Mazda RX4 Wag     #> 3 -0.934  0.224 | 3 Datsun 710        #> 4 -0.247  0.984 | 4 Hornet 4 Drive    #> 5  0.834  0.316 | 5 Hornet Sportabout #> # ℹ 27 more rows | # ℹ 27 more rows #>  # regression biplot ggbiplot(mtcars_specs_cmds_ord, aes(label = name),          sec.axes = \"rows\", scale.factor = 3) +   theme_minimal() +   geom_rows_text(size = 3) +   geom_cols_vector(data = mtcars_cmds_lm) +   expand_limits(x = c(-2.25, 1.25), y = c(-2, 1.5))  # PCA of iris data iris_pca <- ordinate(iris, cols = 1:4, prcomp, scale = TRUE)  # row-principal predictive biplot iris_pca %>%   ggbiplot(axis.type = \"predictive\") +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_cols_axis(aes(label = name, center = center, scale = scale)) +   geom_rows_point(aes(color = Species), alpha = .5) +   ggtitle(\"Predictive biplot of Anderson iris measurements\")   # with two calibrated axes iris_pca %>%   ggbiplot(axis.type = \"predictive\") +   theme_bw() +   scale_color_brewer(type = \"qual\", palette = 2) +   geom_origin() +   stat_cols_rule(     subset = c(2, 4), fontface = \"bold\", text.fontface = \"plain\",     aes(label = name, center = center, scale = scale)   ) +   geom_rows_point(aes(color = Species), alpha = .5) +   expand_limits(x = c(-5, 5), y = c(-5, 5)) +   ggtitle(\"Predictive biplot of Anderson iris measurements\")"},{"path":"/reference/glass.html","id":null,"dir":"Reference","previous_headings":"","what":"Glass composition data — glass","title":"Glass composition data — glass","text":"Sites, types, compositions glass samples archaeological sites Israel.","code":""},{"path":"/reference/glass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Glass composition data — glass","text":"","code":"data(glass)"},{"path":"/reference/glass.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Glass composition data — glass","text":"tibble 68 cases 16 variables: Site site sample found Anal analysis identifier Context furnace identifier Form type sample SiO2, TiO2, Al2O3, FeO, MnO, MgO, CaO, Na2O, K2O, P2O5, Cl, SO3 normalized weight percent oxide component","code":""},{"path":"/reference/glass.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Glass composition data — glass","text":"Freestone &al (2000), Table 2.","code":""},{"path":"/reference/glass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Glass composition data — glass","text":"Chunks unformed glass several furnaces found primary Byzantine-era site Bet Eli'ezer, along samples sites weaker evidence glass-making (Apollonia Dor) Islamic-era site (Banias), analyzed using X-ray spectrometry determine major components. Baxter & Freestone (2006) used data illustrate log-ratio analysis.","code":""},{"path":"/reference/glass.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Glass composition data — glass","text":"Freestone IC, Gorin-Rosen Y, & Hughes MJ (2000) \"Primary glass Israel production glass Late Antiquity early Islamic period\". La route du verre: Ateliers primaires et secondaires du second millénaire av. J.-C. au Moyen Âge: 65–83. https://pascal-francis.inist.fr/vibad/index.php?action=getRecordDetail&idt=1158762 Baxter MJ & Freestone IC (2006) \"Log-Ratio Compositional Data Analysis Archaeometry\". Archaeometry, 48(3): 511–531. doi:10.1111/j.1475-4754.2006.00270.x","code":""},{"path":"/reference/glass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Glass composition data — glass","text":"","code":"# subset glass data to one site and major components head(glass) #> # A tibble: 6 × 16 #>   Site       Anal  Context Form   SiO2  TiO2 Al2O3   FeO   MnO   MgO   CaO  Na2O #>   <chr>      <chr> <chr>   <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1 Bet Eli'e… 1     L14.B1… Chunk  76.0 NA     3.29  0.45   0.1  0.57  5.96  12.1 #> 2 Bet Eli'e… 2     L14.B1… Chunk  73.6  0.16  3.7   0.85  NA    0.68  6.65  13.0 #> 3 Bet Eli'e… 3     L14.B1… Chunk  75.0  0.13  3.36  0.53  NA    0.58  7.27  11.4 #> 4 Bet Eli'e… 4     L14.B1… Chunk  76.0 NA     3.06  0.35   0.1  0.61  7.63  11.3 #> 5 Bet Eli'e… 5     L14.B1… Chunk  75.9 NA     3.13  0.33  NA    0.65  7.49  11.4 #> 6 Bet Eli'e… 6     L14.B1… Chunk  74.4  0.14  3.33  0.45  NA    0.62  7.2   12.6 #> # ℹ 4 more variables: K2O <dbl>, P2O5 <dbl>, Cl <dbl>, SO3 <dbl> glass_main <- subset(   glass,   Site == \"Bet Eli'ezer\",   select = c(\"SiO2\", \"Na2O\", \"CaO\", \"Al2O3\", \"MgO\", \"K2O\") ) # format as a data frame with row names glass_main <- as.data.frame(glass_main) rownames(glass_main) <- subset(glass, Site == \"Bet Eli'ezer\")$Anal  # perform log-ratio analysis glass_lra <- lra(glass_main, compositional = TRUE, weighted = FALSE) # inspect LRA row and column coordinates head(glass_lra$row.coords) #>         LRSV1       LRSV2      LRSV3      LRSV4      LRSV5 #> 1 -0.04710674 -0.71421468 -0.1481599  2.0743704  1.4967846 #> 2  1.06477553  0.29251672  0.7714624  0.8939097 -0.9176510 #> 3  0.18390009 -0.41583336 -0.6223075 -0.6353946 -0.2492736 #> 4 -0.50865018  0.05740889 -0.5126957 -1.0951873  0.7896664 #> 5 -0.86538619  0.38109842 -0.6578733 -0.1765439  0.1192224 #> 6 -1.37184826 -0.53735808 -0.3574370  1.4192209 -1.3690434 glass_lra$column.coords #>            LRSV1      LRSV2      LRSV3      LRSV4       LRSV5 #> SiO2  -0.3208528 -0.4140707 -1.1214862  0.3234513  1.83391575 #> Na2O  -0.5797004 -1.0229552  1.7646198  0.7054758  0.07701303 #> CaO   -1.1181033 -0.2446487 -0.3429045 -1.7573115 -0.69589148 #> Al2O3  0.6587363 -0.6516092 -1.0691711  1.0070705 -1.40860005 #> MgO   -0.5349928  2.0542100  0.1946826  0.6532841 -0.17123886 #> K2O    1.8949130  0.2790737  0.5742595 -0.9319702  0.36480160 # inspect singular values of LRA glass_lra$sv #> [1] 0.06502356 0.04802956 0.03826908 0.03063650 0.01432346  # plot samples and measurements in a biplot biplot(   x = glass_lra$row.coords %*% diag(glass_lra$sv),   y = glass_lra$column.coords,   xlab = \"Sample (principal coord.)\", ylab = \"\" ) mtext(\"Component (standard coord.)\", side = 4L, line = 3L)"},{"path":"/reference/lda-ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Augmented implementation of linear discriminant analysis — lda-ord","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"function replicates MASS::lda() options defaults retain elements useful tbl_ord class biplot calculations.","code":""},{"path":"/reference/lda-ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"","code":"lda_ord(x, ...)  # S3 method for class 'formula' lda_ord(formula, data, ..., subset, na.action)  # S3 method for class 'data.frame' lda_ord(x, ...)  # S3 method for class 'matrix' lda_ord(x, grouping, ..., subset, na.action)  # Default S3 method lda_ord(   x,   grouping,   prior = proportions,   tol = 1e-04,   method = c(\"moment\", \"mle\", \"mve\", \"t\"),   CV = FALSE,   nu = 5,   ...,   ret.x = TRUE,   ret.grouping = TRUE,   axes.scale = \"unstandardized\" )  # S3 method for class 'lda_ord' predict(   object,   newdata,   prior = object$prior,   dimen,   method = c(\"plug-in\", \"predictive\", \"debiased\"),   ... )  # S3 method for class 'lda_ord' model.frame(formula, ...)"},{"path":"/reference/lda-ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"x (required formula given principal argument.)     matrix data frame Matrix containing explanatory variables. ... arguments passed methods. formula formula form groups ~ x1 + x2 + ...  ,     response grouping factor right hand side specifies     (non-factor) discriminators. data optional data frame, list environment variables     specified formula preferentially taken. subset index vector specifying cases used training     sample.  (NOTE: given, argument must named.) na.action function specify action taken NAs found.     default action procedure fail.  alternative     na.omit, leads rejection cases missing values     required variable.  (NOTE: given, argument must named.) grouping (required formula principal argument given.)     factor specifying class observation. prior prior probabilities class membership.  unspecified,     class proportions training set used.  present,     probabilities specified order factor     levels. tol tolerance decide matrix singular; reject variables     linear combinations unit-variance variables whose variance     less tol^2. method \"moment\" standard estimators mean variance,     \"mle\" MLEs, \"mve\" use cov.mve,     \"t\" robust estimates based \\(t\\) distribution. CV true, returns results (classes posterior probabilities)     leave-one-cross-validation. Note prior estimated,     proportions whole dataset used. nu degrees freedom method = \"t\". ret.x, ret.grouping Logical; whether retain attributes data matrix (x) class assignments (grouping) LDA performed. Methods like predict() access objects name parent environment, retaining attributes prevents errors arise objects reassigned. axes.scale Character string indicating left-transform scaling value rendering biplots using ggbiplot(). Options include \"unstandardized\", \"standardized\", \"contribution\". object object  class \"lda\" newdata data frame cases classified , object   formula, data frame columns names   variables used.  vector interpreted   row vector.  newdata missing, attempt   made retrieve data used fit lda object. dimen dimension space used. less min(p, ng-1), first dimen discriminant components used (except method=\"predictive\"), dimensions returned x.","code":""},{"path":"/reference/lda-ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"Output MASS::lda() additional preceding class 'lda_ord' three attributes: input data x, ret.x = TRUE class assignments grouping, ret.grouping = TRUE parameter axes.scale 'unstandardized', matrix axes.scale encodes transformation row space","code":""},{"path":"/reference/lda-ord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"Linear discriminant analysis relies eigendecomposition product \\(W^{-1}B\\) inverse within-class covariance matrix \\(W\\) -class covariance matrix \\(B\\). eigendecomposition can motivated right (\\(V\\)) half singular value decomposition matrix Mahalanobis distances cases \"sphering\" (linearly transforming within-class covariance identity matrix). LDA traditionally represented biplots, exceptions (Gardner & le Roux, 2005; Greenacre, 2010, p. 109–117). LDA implemented MASS::lda() MASS package, variables transformed sphering matrix \\(S\\) (Venables & Ripley, 2003, p. 331–333). returned element scaling contains unstandardized discriminant coefficients, define discriminant scores cases centroids linear combinations original variables. discriminant coefficients constitute one several possible choices axes biplot representation LDA. slightly modified function lda_ord() provides additional options: standardized discriminant coefficients obtained (re)scaling coefficients variable standard deviations. coefficients indicate contributions variables discriminant scores controlling variances (Orlov, 2013). variables' contributions Mahalanobis variance along discriminant axis obtained transforming coefficients inverse sphering matrix \\(S\\). contribution biplot derives eigendecomposition Mahalanobis distance matrix, projections centroids cases onto variable axes approximate variable values centering sphering (Greenacre, 2013). Finally, contrast MASS::lda(), lda_ord() defaults ret.x ret.grouping TRUE, elements can used compute annotate case scores supplementary elements.","code":""},{"path":"/reference/lda-ord.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"Gardner S & le Roux NJ (2005) \"Extensions Biplot Methodology Discriminant Analysis\". Journal Classification 22(1): 59–86. doi:10.1007/s00357-005-0006-7  https://link.springer.com/article/10.1007/s00357-005-0006-7 Greenacre MJ (2010) Biplots Practice. Fundacion BBVA, ISBN: 978-84-923846. https://www.fbbva.es/microsite/multivariate-statistics/biplots.html Venables WN & Ripley BD (2003) Modern Applied Statistics S, Fourth Edition. Springer Science & Business Media, ISBN: 0387954570, 9780387954578. https://www.mimuw.edu.pl/~pokar/StatystykaMgr/Books/VenablesRipley_ModernAppliedStatisticsS02.pdf Orlov K (2013) Answer \"Algebra LDA. Fisher discrimination power variable Linear Discriminant Analysis\". CrossValidated, accessed 2019-07-26. https://stats.stackexchange.com//83114/68743 Greenacre M (2013) \"Contribution Biplots\". Journal Computational Graphical Statistics, 22(1): 107–122. https://www.tandfonline.com/doi/full/10.1080/10618600.2012.702494","code":""},{"path":[]},{"path":"/reference/lda-ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augmented implementation of linear discriminant analysis — lda-ord","text":"","code":"# Anderson iris species data centroid iris_centroid <- t(apply(iris[, 1:4], 2, mean)) # unstandardized discriminant coefficients: the discriminant axes are linear # combinations of the centered variables iris_lda <- lda_ord(iris[, 1:4], iris[, 5], axes.scale = \"unstandardized\") # linear combinations of centered variables print(sweep(iris_lda$means, 2, iris_centroid, \"-\") %*% get_cols(iris_lda)) #>                  LD1        LD2 #> setosa      7.607600 -0.2151330 #> versicolor -1.825049  0.7278996 #> virginica  -5.782550 -0.5127666 # discriminant centroids print(get_rows(iris_lda, elements = \"active\")) #>                  LD1        LD2 #> setosa      7.607600 -0.2151330 #> versicolor -1.825049  0.7278996 #> virginica  -5.782550 -0.5127666  # unstandardized coefficient LDA biplot iris_lda %>%   as_tbl_ord() %>%   augment_ord() %>%   ggbiplot() +   theme_bw() +   coord_scaffold() +   geom_rows_point(aes(color = grouping), elements = \"score\", alpha = 1/3) +   geom_rows_point(aes(color = grouping), size = 3) +   geom_cols_vector(aes(label = name), color = \"#888888\", size = 3) +   scale_color_brewer(type = \"qual\", palette = 2) +   ggtitle(\"Unstandardized coefficient biplot of iris LDA\")   # standardized discriminant coefficients: permit comparisons across the # variables iris_lda <- lda_ord(iris[, 1:4], iris[, 5], axes.scale = \"standardized\") # standardized variable contributions to discriminant axes iris_lda %>%   as_tbl_ord() %>%   augment_ord() %>%   fortify(.matrix = \"cols\") %>%   dplyr::mutate(variable = name) %>%   tidyr::gather(discriminant, coefficient, LD1, LD2) %>%   ggplot(aes(x = discriminant, y = coefficient, fill = variable)) +   geom_bar(position = \"dodge\", stat = \"identity\") +   labs(y = \"Standardized coefficient\", x = \"Linear discriminant\") +   theme_bw() +   coord_flip()  # standardized coefficient LDA biplot iris_lda %>%   as_tbl_ord() %>%   augment_ord() %>%   ggbiplot() +   theme_bw() +   coord_scaffold() +   geom_rows_point(aes(color = grouping), elements = \"score\", alpha = 1/3) +   geom_rows_point(aes(color = grouping), size = 3) +   geom_cols_vector(aes(label = name), color = \"#888888\", size = 3) +   scale_color_brewer(type = \"qual\", palette = 2) +   ggtitle(\"Standardized coefficient biplot of iris LDA\")   # variable contributions (de-sphered discriminant coefficients): recover the # inner product relationship with the centered class centroids iris_lda <- lda_ord(iris[, 1:4], iris[, 5], axes.scale = \"contribution\") # symmetric square root of within-class covariance C_W_eig <- eigen(cov(iris[, 1:4] - iris_lda$means[iris[, 5], ])) C_W_sqrtinv <-   C_W_eig$vectors %*% diag(1/sqrt(C_W_eig$values)) %*% t(C_W_eig$vectors) # product of matrix factors (scores and loadings) print(get_rows(iris_lda, elements = \"active\") %*% t(get_cols(iris_lda))) #>                  [,1]      [,2]      [,3]       [,4] #> setosa      0.3061785  2.593874 -5.861269 -3.9959956 #> versicolor -0.1774657 -1.154286  1.457859  0.5653316 #> virginica  -0.1287128 -1.439587  4.403411  3.4306640 # \"asymmetric\" square roots of Mahalanobis distances between variables print(sweep(iris_lda$means, 2, iris_centroid, \"-\") %*% C_W_sqrtinv) #>                  [,1]      [,2]      [,3]       [,4] #> setosa      0.3103442  2.629165 -5.941014 -4.0503629 #> versicolor -0.1798802 -1.169991  1.477693  0.5730232 #> virginica  -0.1304640 -1.459174  4.463321  3.4773397 # contribution LDA biplot iris_lda %>%   as_tbl_ord() %>%   augment_ord() %>%   ggbiplot() +   theme_bw() +   coord_scaffold() +   geom_rows_point(aes(color = grouping), elements = \"score\", alpha = 1/3) +   geom_rows_point(aes(color = grouping), size = 3) +   geom_cols_vector(aes(label = name), color = \"#888888\", size = 3) +   scale_color_brewer(type = \"qual\", palette = 2) +   ggtitle(\"Contribution biplot of iris LDA\")"},{"path":"/reference/lra-ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-ratio analysis — lra-ord","title":"Log-ratio analysis — lra-ord","text":"Represent log-ratios variables based values population cases.","code":""},{"path":"/reference/lra-ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-ratio analysis — lra-ord","text":"","code":"lra(x, compositional = FALSE, weighted = TRUE)  # S3 method for class 'lra' print(x, nd = length(x$sv), n = 6L, ...)  # S3 method for class 'lra' screeplot(x, main = deparse1(substitute(x)), ...)  # S3 method for class 'lra' biplot(   x,   choices = c(1L, 2L),   scale = c(0, 0),   main = deparse1(substitute(x)),   var.axes = FALSE,   ... )  # S3 method for class 'lra' plot(x, main = deparse1(substitute(x)), ...)"},{"path":"/reference/lra-ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-ratio analysis — lra-ord","text":"x numeric matrix rectangular data set. compositional Logical; whether normalize rows x sum 1. weighted Logical; whether weight rows columns sums. nd Integer; number shared dimensions include print. n Integer; number rows factor print. main, var.axes, ... Parameters passed plotting methods (case main, force()d. choices Integer; length-2 vector specifying components plot. scale Numeric; values 0 1 control inertia conferred unto points: Row (= 1L) column (= 2L) coordinates scaled sv ^ scale[[]]. single value scale passed, assigned rows 1 - scale assigned columns.","code":""},{"path":"/reference/lra-ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-ratio analysis — lra-ord","text":"Given \\(n * p\\) data matrix setting \\(r=min(n,p)\\), lra() returns list class \"lra\" containing three elements: sv \\(r-1\\) singular values row.coords \\(n * (r-1)\\) matrix row standard coordinates. column.coords \\(p * (r-1)\\) matrix column standard coordinates. row.weights weights used scale row coordinates. column.weights weights used scale column coordinates.","code":""},{"path":"/reference/lra-ord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log-ratio analysis — lra-ord","text":"Log-ratio analysis (LRA) based double-centering log-transformed data, usually weighted row column totals. technique suitable positive-valued variables common scale (e.g. percentages). distances variables' coordinates (full-dimensional space) pairwise log-ratios. distances cases' coordinates called log-ratio distances, total variance weighted sum squares. LRA implemented standard R distributions useful member ordination toolkit. minimal implementation following Greenacre's (2010) exposition Chapter 7.","code":""},{"path":"/reference/lra-ord.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Log-ratio analysis — lra-ord","text":"Greenacre MJ (2010) Biplots Practice. Fundacion BBVA, ISBN: 978-84-923846. https://www.fbbva.es/microsite/multivariate-statistics/biplots.html","code":""},{"path":"/reference/lra-ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-ratio analysis — lra-ord","text":"","code":"# U.S. 1973 violent crime arrests head(USArrests) #>            Murder Assault UrbanPop Rape #> Alabama      13.2     236       58 21.2 #> Alaska       10.0     263       48 44.5 #> Arizona       8.1     294       80 31.0 #> Arkansas      8.8     190       50 19.5 #> California    9.0     276       91 40.6 #> Colorado      7.9     204       78 38.7 # row and column subsets state_examples <- c(\"Hawaii\", \"Mississippi\", \"North Dakota\") arrests <- c(1L, 2L, 4L)  # pairwise log-ratios of violent crime arrests for two states arrest_pairs <- combn(arrests, 2L) arrest_ratios <-   USArrests[, arrest_pairs[1L, ]] / USArrests[, arrest_pairs[2L, ]] colnames(arrest_ratios) <- paste(   colnames(USArrests)[arrest_pairs[1L, ]], \"/\",   colnames(USArrests)[arrest_pairs[2L, ]], sep = \"\" ) arrest_logratios <- log(arrest_ratios) arrest_logratios[state_examples, ] #>              Murder/Assault Murder/Rape Assault/Rape #> Hawaii            -2.160935 -1.33797578    0.8229588 #> Mississippi       -2.778009 -0.06025919    2.7177496 #> North Dakota      -4.029806 -2.21101790    1.8187881  # non-compositional log-ratio analysis (arrests_lra <- lra(USArrests[, arrests])) #> Singular values: 0.11758785 0.06383505  #>  #> Row scores (6 of 50): #>                 LRSV1      LRSV2 #> Alabama    -0.6800120  0.9296011 #> Alaska      0.9299899 -0.6245772 #> Arizona    -0.3298496 -1.3115817 #> Arkansas   -0.3513443  0.2773231 #> California  0.5516590 -1.0042801 #> Colorado    1.2291066 -0.6388469 #>  #> Column scores: #>             LRSV1      LRSV2 #> Murder   0.283086  4.9570302 #> Assault -0.370595 -0.1805698 #> Rape     2.876702 -0.3660163 screeplot(arrests_lra)  biplot(arrests_lra, scale = c(1, 0), cex = c(2/3, 1))   # compositional log-ratio analysis (arrests_lra <- lra(USArrests[, arrests], compositional = TRUE)) #> Singular values: 0.12786989 0.07009419  #>  #> Row scores (6 of 50): #>                 LRSV1      LRSV2 #> Alabama    -0.8599661  1.0266703 #> Alaska      0.6256391 -0.5908842 #> Arizona    -0.5965504 -1.0524702 #> Arkansas   -0.5672002  0.3924046 #> California  0.2531761 -0.8868744 #> Colorado    0.9102533 -0.6422862 #>  #> Column scores: #>              LRSV1      LRSV2 #> Murder   0.6072392  4.9382810 #> Assault -0.3999883 -0.1533148 #> Rape     2.7051937 -0.5351457 biplot(arrests_lra, scale = c(1, 0), cex = c(2/3, 1))"},{"path":"/reference/methods-cancor.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for canonical correlations — methods-cancor","title":"Functionality for canonical correlations — methods-cancor","text":"methods extract data , attribute new data , objects class \"cancor_ord\". class introduced package identify objects returned cancor_ord(), wraps stats::cancor().","code":""},{"path":"/reference/methods-cancor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for canonical correlations — methods-cancor","text":"","code":"# S3 method for class 'cancor_ord' as_tbl_ord(x)  # S3 method for class 'cancor_ord' recover_rows(x)  # S3 method for class 'cancor_ord' recover_cols(x)  # S3 method for class 'cancor_ord' recover_inertia(x)  # S3 method for class 'cancor_ord' recover_coord(x)  # S3 method for class 'cancor_ord' recover_conference(x)  # S3 method for class 'cancor_ord' recover_supp_rows(x)  # S3 method for class 'cancor_ord' recover_supp_cols(x)  # S3 method for class 'cancor_ord' recover_aug_rows(x)  # S3 method for class 'cancor_ord' recover_aug_cols(x)  # S3 method for class 'cancor_ord' recover_aug_coord(x)"},{"path":"/reference/methods-cancor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for canonical correlations — methods-cancor","text":"x ordination object.","code":""},{"path":"/reference/methods-cancor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for canonical correlations — methods-cancor","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-cancor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for canonical correlations — methods-cancor","text":"canonical coefficients (loadings) obtained directly underlying singular value decomposition constitute active elements. canonical scores returned, structure correlations made available supplementary elements. ordr takes rows columns intraset correlations $xstructure $ystructure, intertia conferred; interset correlations can obtained conferring inertia onto . biplot canonical coefficients can interpreted approximating \\(X\\)-\\(Y\\) inner product matrix, inversely weighted \\(X\\) \\(Y\\) variances. canonical scores structure coefficients available supplementary points returned cancor_ord(). can used create biplots case scores linear combinations loadings (coefficients, standard coordinates, overlaid scores) intraset interset correlations respect either data set (correlations inertia conferred entirely onto rows onto columns). Greenacre (1984) ter Braak (1990) describe families, though ter Braak recommends first.","code":""},{"path":"/reference/methods-cancor.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functionality for canonical correlations — methods-cancor","text":"Greenacre MJ (1984) Theory applications correspondence analysis. London: Academic Press, ISBN 0-12-299050-1. http://www.carme-n.org/?sec=books5 ter Braak CJF (1990) \"Interpreting canonical correlation analysis biplots structure correlations weights\". Psychometrika 55(3), 519–531. doi:10.1007/BF02294765","code":""},{"path":[]},{"path":"/reference/methods-cancor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for canonical correlations — methods-cancor","text":"","code":"# data frame of life-cycle savings across countries class(LifeCycleSavings) #> [1] \"data.frame\" head(LifeCycleSavings) #>              sr pop15 pop75     dpi ddpi #> Australia 11.43 29.35  2.87 2329.68 2.87 #> Austria   12.07 23.32  4.41 1507.99 3.93 #> Belgium   13.17 23.80  4.43 2108.47 3.82 #> Bolivia    5.75 41.89  1.67  189.13 0.22 #> Brazil    12.88 42.19  0.83  728.47 4.56 #> Canada     8.79 31.72  2.85 2982.88 2.43 savings_pop <- LifeCycleSavings[, c(\"pop15\", \"pop75\")] savings_oec <- LifeCycleSavings[, c(\"sr\", \"dpi\", \"ddpi\")]  # canonical correlation analysis with scores and correlations included savings_cca <- cancor_ord(savings_pop, savings_oec, scores = TRUE) savings_cca <- augment_ord(as_tbl_ord(savings_cca)) head(get_cols(savings_cca)) #>                CanCor1       CanCor2 #> sr        0.0084710221  3.337936e-02 #> dpi       0.0001307398 -7.588232e-05 #> ddpi      0.0041706000 -1.226790e-02 #> Australia 0.1710832312 -2.319485e-02 #> Austria   0.0734979335  4.751571e-02 #> Belgium   0.1608639281  4.001665e-02 head(get_cols(savings_cca, elements = \"score\")) #>                  [,1]        [,2] #> Australia  0.17108323 -0.02319485 #> Austria    0.07349793  0.04751571 #> Belgium    0.16086393  0.04001665 #> Bolivia   -0.16793935 -0.01784978 #> Brazil    -0.01892735  0.12597599 #> Canada     0.23228391 -0.15548481 get_rows(savings_cca, elements = \"structure\") #>                        [,1]         [,2] #> Australia       0.080362286  0.057700356 #> Austria         0.210217920 -0.124760455 #> Belgium         0.206817659 -0.147353276 #> Bolivia        -0.092264868 -0.084150385 #> Brazil         -0.135862036  0.123644726 #> Canada          0.057796606 -0.022939696 #> Chile          -0.088730206  0.079629867 #> China          -0.166969430  0.072566104 #> Colombia       -0.165216418 -0.097415107 #> Costa Rica     -0.170435473 -0.154462094 #> Denmark         0.176845172 -0.039655162 #> Ecuador        -0.155885659 -0.119302333 #> Finland         0.069795922  0.242551458 #> France          0.208472809 -0.263277199 #> Germany         0.158742664  0.151532042 #> Greece          0.125534708  0.132936978 #> Guatamala      -0.169084041 -0.026584891 #> Honduras       -0.194762607  0.002903451 #> Iceland         0.047939457 -0.166484319 #> India          -0.121520306  0.121679633 #> Ireland         0.128086354 -0.351472861 #> Italy           0.154042705  0.073862843 #> Japan           0.054980076  0.392359096 #> Korea          -0.127870350  0.119119726 #> Luxembourg      0.190986112  0.107308952 #> Malta           0.031839649  0.046276615 #> Norway          0.150257208 -0.027393904 #> Netherlands     0.141122714  0.126852315 #> New Zealand     0.065255149 -0.138477036 #> Nicaragua      -0.143341921 -0.078506548 #> Panama         -0.130344329 -0.022294782 #> Paraguay       -0.115957618  0.102960459 #> Peru           -0.132192367 -0.065939607 #> Philippines    -0.158835442 -0.099269419 #> Portugal        0.082942570  0.077033191 #> South Africa    0.028063135  0.117469052 #> South Rhodesia -0.008726758  0.316030295 #> Spain           0.095030764  0.116017873 #> Sweden          0.233670507 -0.090503487 #> Switzerland     0.175588765  0.046093670 #> Turkey         -0.134906511  0.014013696 #> Tunisia        -0.153181646 -0.117626373 #> United Kingdom  0.213105839 -0.135964931 #> United States   0.103413900 -0.104736278 #> Venezuela      -0.170813415 -0.047071960 #> Zambia         -0.176876085  0.083089347 #> Jamaica        -0.082330658 -0.071878093 #> Uruguay         0.084180403  0.140938007 #> Libya          -0.089205403 -0.253474726 #> Malaysia       -0.189777503 -0.013574829 #> pop15          -0.982982070 -0.183701522 #> pop75           0.969792868 -0.243929894 get_cols(savings_cca, elements = \"structure\") #>                        [,1]         [,2] #> Australia       0.171083231 -0.023194852 #> Austria         0.073497933  0.047515706 #> Belgium         0.160863928  0.040016653 #> Bolivia        -0.167939348 -0.017849776 #> Brazil         -0.018927351  0.125975993 #> Canada          0.232283907 -0.155484806 #> Chile          -0.139411775 -0.255757534 #> China          -0.076484519  0.102650369 #> Colombia       -0.151091771 -0.085279284 #> Costa Rica     -0.077686953  0.096990052 #> Denmark         0.243481179  0.131320249 #> Ecuador        -0.165124499 -0.121601972 #> Finland         0.090745497  0.001878991 #> France          0.173067145  0.005743865 #> Germany         0.199609498 -0.002473117 #> Greece         -0.011860145  0.020302710 #> Guatamala      -0.172745183 -0.132399004 #> Honduras       -0.133371832  0.007517853 #> Iceland         0.021555892 -0.308262763 #> India          -0.148002154  0.082042157 #> Ireland         0.015276247  0.062608327 #> Italy           0.075166369  0.135021917 #> Japan           0.135063656  0.315449149 #> Korea          -0.157194180 -0.146916393 #> Luxembourg      0.172163609 -0.052380163 #> Malta           0.001285777  0.178757532 #> Norway          0.151317894 -0.064297624 #> Netherlands     0.141333968  0.070216617 #> New Zealand     0.049912057  0.028959254 #> Nicaragua      -0.127549491 -0.004188327 #> Panama         -0.115291450 -0.131956928 #> Paraguay       -0.192048922 -0.154676750 #> Peru           -0.079612027  0.192610337 #> Philippines    -0.105817455  0.197786992 #> Portugal       -0.029527899  0.088439216 #> South Africa   -0.053665283  0.102841084 #> South Rhodesia -0.088475821  0.207635702 #> Spain          -0.023934583  0.088441591 #> Sweden          0.259747311 -0.251047443 #> Switzerland     0.232635276  0.046153127 #> Turkey         -0.135546685 -0.087375693 #> Tunisia        -0.181107771 -0.131757959 #> United Kingdom  0.069402362 -0.094341425 #> United States   0.355173128 -0.274111611 #> Venezuela      -0.055636386  0.046803247 #> Zambia         -0.045547784  0.353236545 #> Jamaica        -0.084487974 -0.089413410 #> Uruguay        -0.055961815  0.034464260 #> Libya          -0.081137138 -0.110362124 #> Malaysia       -0.149477671 -0.116250539 #> sr              0.491037858  0.855775971 #> dpi             0.954517196 -0.263726650 #> ddpi            0.047337701  0.140773707  # biplot of interset and intraset correlations with the population data # NB: `contour = TRUE` is not automatically set as in `geom_density_2d()` savings_cca %>%   confer_inertia(\"cols\") %>%   ggbiplot(aes(label = name, color = .matrix)) +   theme_bw() + theme_scaffold() +   geom_unit_circle() +   geom_rows_density_2d(elements = \"score\", color = \"grey\", contour = TRUE) +   geom_rows_vector(arrow = NULL, elements = \"structure\") +   geom_cols_vector(arrow = NULL, elements = \"structure\", linetype = \"dashed\") +   geom_rows_text(elements = \"structure\", hjust = \"outward\") +   geom_cols_text(elements = \"structure\", hjust = \"outward\") +   scale_color_brewer(limits = c(\"rows\", \"cols\"), type = \"qual\") +   expand_limits(x = c(-1, 1), y = c(-1, 1)) #> Warning: Duplicated aesthetics after name standardisation: contour #> Warning: The following aesthetics were dropped during statistical transformation: label. #> ℹ This can happen when ggplot fails to infer the correct grouping structure in #>   the data. #> ℹ Did you forget to specify a `group` aesthetic or to convert a numerical #>   variable into a factor?   # situate country scores along financial variables savings_cca %>%   confer_inertia(\"rows\") %>%   ggbiplot(aes(label = name)) +   theme_scaffold() +   geom_cols_axis(elements = \"active\") +   geom_rows_text(elements = \"score\")"},{"path":"/reference/methods-cmds.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for classical multidimensional scaling objects — methods-cmds","title":"Functionality for classical multidimensional scaling objects — methods-cmds","text":"methods extract data , attribute new data , objects class \"cmds_ord\". class introduced package identify objects returned cmdscale_ord(), wraps stats::cmdscale().","code":""},{"path":"/reference/methods-cmds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for classical multidimensional scaling objects — methods-cmds","text":"","code":"# S3 method for class 'cmds_ord' as_tbl_ord(x)  # S3 method for class 'cmds_ord' recover_rows(x)  # S3 method for class 'cmds_ord' recover_cols(x)  # S3 method for class 'cmds_ord' recover_inertia(x)  # S3 method for class 'cmds_ord' recover_coord(x)  # S3 method for class 'cmds_ord' recover_conference(x)  # S3 method for class 'cmds_ord' recover_aug_rows(x)  # S3 method for class 'cmds_ord' recover_aug_cols(x)  # S3 method for class 'cmds_ord' recover_aug_coord(x)"},{"path":"/reference/methods-cmds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for classical multidimensional scaling objects — methods-cmds","text":"x ordination object.","code":""},{"path":"/reference/methods-cmds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for classical multidimensional scaling objects — methods-cmds","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-cmds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for classical multidimensional scaling objects — methods-cmds","text":"","code":"# 'dist' object (matrix of road distances) of large American cities class(UScitiesD) #> [1] \"dist\" print(UScitiesD) #>               Atlanta Chicago Denver Houston LosAngeles Miami NewYork #> Chicago           587                                                 #> Denver           1212     920                                         #> Houston           701     940    879                                  #> LosAngeles       1936    1745    831    1374                          #> Miami             604    1188   1726     968       2339               #> NewYork           748     713   1631    1420       2451  1092         #> SanFrancisco     2139    1858    949    1645        347  2594    2571 #> Seattle          2182    1737   1021    1891        959  2734    2408 #> Washington.DC     543     597   1494    1220       2300   923     205 #>               SanFrancisco Seattle #> Chicago                            #> Denver                             #> Houston                            #> LosAngeles                         #> Miami                              #> NewYork                            #> SanFrancisco                       #> Seattle                678         #> Washington.DC         2442    2329  # use multidimensional scaling to infer artificial planar coordinates UScitiesD %>%   cmdscale_ord(k = 2) %>%   as_tbl_ord() %>%   print() -> usa_mds #> # A tbl_ord of class 'cmds_ord': (10 x 2) x (10 x 2)' #> # 2 coordinates: PCo1 and PCo2 #> #  #> # Rows (symmetric): [ 10 x 2 | 0 ] #>      PCo1   PCo2 |  #>                  |  #>  1  -719.  143.  |  #>  2  -382. -341.  |  #>  3   482.  -25.3 |  #>  4  -161.  573.  |  #>  5  1204.  390.  |  #>  6 -1134.  582.  |  #>  7 -1072. -519.  |  #>  8  1421.  113.  |  #>  9  1342. -580.  |  #> 10  -980. -335.  |  #> #  #> # Columns (symmetric): [ 10 x 2 | 0 ] #>      PCo1   PCo2 |  #>                  |  #>  1  -719.  143.  |  #>  2  -382. -341.  |  #>  3   482.  -25.3 |  #>  4  -161.  573.  |  #>  5  1204.  390.  |  #>  6 -1134.  582.  |  #>  7 -1072. -519.  |  #>  8  1421.  113.  |  #>  9  1342. -580.  |  #> 10  -980. -335.  |   # recover (equivalent) matrices of row and column artificial coordinates get_rows(usa_mds) #>             PCo1       PCo2 #>  [1,]  -718.7594  142.99427 #>  [2,]  -382.0558 -340.83962 #>  [3,]   481.6023  -25.28504 #>  [4,]  -161.4663  572.76991 #>  [5,]  1203.7380  390.10029 #>  [6,] -1133.5271  581.90731 #>  [7,] -1072.2357 -519.02423 #>  [8,]  1420.6033  112.58920 #>  [9,]  1341.7225 -579.73928 #> [10,]  -979.6220 -335.47281 get_cols(usa_mds) #>             PCo1       PCo2 #>  [1,]  -718.7594  142.99427 #>  [2,]  -382.0558 -340.83962 #>  [3,]   481.6023  -25.28504 #>  [4,]  -161.4663  572.76991 #>  [5,]  1203.7380  390.10029 #>  [6,] -1133.5271  581.90731 #>  [7,] -1072.2357 -519.02423 #>  [8,]  1420.6033  112.58920 #>  [9,]  1341.7225 -579.73928 #> [10,]  -979.6220 -335.47281  # augment ordination with point names (usa_mds <- augment_ord(usa_mds)) #> # A tbl_ord of class 'cmds_ord': (10 x 2) x (10 x 2)' #> # 2 coordinates: PCo1 and PCo2 #> #  #> # Rows (symmetric): [ 10 x 2 | 1 ] #>      PCo1   PCo2 |    name          #>                  |    <chr>         #>  1  -719.  143.  |  1 Atlanta       #>  2  -382. -341.  |  2 Chicago       #>  3   482.  -25.3 |  3 Denver        #>  4  -161.  573.  |  4 Houston       #>  5  1204.  390.  |  5 LosAngeles    #>  6 -1134.  582.  |  6 Miami         #>  7 -1072. -519.  |  7 NewYork       #>  8  1421.  113.  |  8 SanFrancisco  #>  9  1342. -580.  |  9 Seattle       #> 10  -980. -335.  | 10 Washington.DC #> #  #> # Columns (symmetric): [ 10 x 2 | 1 ] #>      PCo1   PCo2 |    name          #>                  |    <chr>         #>  1  -719.  143.  |  1 Atlanta       #>  2  -382. -341.  |  2 Chicago       #>  3   482.  -25.3 |  3 Denver        #>  4  -161.  573.  |  4 Houston       #>  5  1204.  390.  |  5 LosAngeles    #>  6 -1134.  582.  |  6 Miami         #>  7 -1072. -519.  |  7 NewYork       #>  8  1421.  113.  |  8 SanFrancisco  #>  9  1342. -580.  |  9 Seattle       #> 10  -980. -335.  | 10 Washington.DC  # reorient biplot to conventional compass usa_mds %>%   negate_ord(c(1, 2)) %>%   ggbiplot() +   geom_cols_text(aes(label = name), size = 3) +   ggtitle(\"MDS biplot of distances between U.S. cities\")"},{"path":"/reference/methods-correspondence.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","title":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","text":"methods extract data , attribute new data , objects class \"correspondence\" MASS package.","code":""},{"path":"/reference/methods-correspondence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","text":"","code":"# S3 method for class 'correspondence' as_tbl_ord(x)  # S3 method for class 'correspondence' recover_rows(x)  # S3 method for class 'correspondence' recover_cols(x)  # S3 method for class 'correspondence' recover_inertia(x)  # S3 method for class 'correspondence' recover_conference(x)  # S3 method for class 'correspondence' recover_coord(x)  # S3 method for class 'correspondence' recover_aug_rows(x)  # S3 method for class 'correspondence' recover_aug_cols(x)  # S3 method for class 'correspondence' recover_aug_coord(x)"},{"path":"/reference/methods-correspondence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","text":"x ordination object.","code":""},{"path":"/reference/methods-correspondence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-correspondence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for correspondence analysis ('correspondence') objects — methods-correspondence","text":"","code":"# table of hair and eye color data collapsed by sex data(quine, package = \"MASS\") class(quine) #> [1] \"data.frame\" head(quine) #>   Eth Sex Age Lrn Days #> 1   A   M  F0  SL    2 #> 2   A   M  F0  SL   11 #> 3   A   M  F0  SL   14 #> 4   A   M  F0  AL    5 #> 5   A   M  F0  AL    5 #> 6   A   M  F0  AL   13  # use correspondence analysis to construct row and column profiles (quine_ca <- MASS::corresp(~ Age + Eth, data = quine)) #> First canonical correlation(s): 0.05317534  #>  #>  Age scores: #>         F0         F1         F2         F3  #> -0.3344445  1.4246090 -1.0320002 -0.4612728  #>  #>  Eth scores: #>          A          N  #> -1.0563816  0.9466276  (quine_ca <- as_tbl_ord(quine_ca)) #> # A tbl_ord of class 'correspondence': (4 x 1) x (2 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 0 ] #>     Can1 |  #>          |  #> 1 -0.334 |  #> 2  1.42  |  #> 3 -1.03  |  #> 4 -0.461 |  #> #  #> # Columns (standard): [ 2 x 1 | 0 ] #>     Can1 |  #>          |  #> 1 -1.06  |  #> 2  0.947 |   # recover row and column profiles get_rows(quine_ca) #>          Can1 #> F0 -0.3344445 #> F1  1.4246090 #> F2 -1.0320002 #> F3 -0.4612728 get_cols(quine_ca) #>         Can1 #> A -1.0563816 #> N  0.9466276  # augment profiles with names, masses, distances, and inertias (quine_ca <- augment_ord(quine_ca)) #> # A tbl_ord of class 'correspondence': (4 x 1) x (2 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -0.334 | 1 F0    #> 2  1.42  | 2 F1    #> 3 -1.03  | 3 F2    #> 4 -0.461 | 4 F3    #> #  #> # Columns (standard): [ 2 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.06  | 1 A     #> 2  0.947 | 2 N"},{"path":"/reference/methods-eigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for eigen-decompositions — methods-eigen","title":"Functionality for eigen-decompositions — methods-eigen","text":"methods extract data , attribute new data , objects class \"eigen\" returned base::eigen() parameter .values set FALSE class \"eigen_ord\" returned eigen_ord().","code":""},{"path":"/reference/methods-eigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for eigen-decompositions — methods-eigen","text":"","code":"# S3 method for class 'eigen' as_tbl_ord(x)  # S3 method for class 'eigen' recover_rows(x)  # S3 method for class 'eigen' recover_cols(x)  # S3 method for class 'eigen' recover_inertia(x)  # S3 method for class 'eigen' recover_coord(x)  # S3 method for class 'eigen' recover_conference(x)  # S3 method for class 'eigen_ord' recover_aug_rows(x)  # S3 method for class 'eigen_ord' recover_aug_cols(x)  # S3 method for class 'eigen' recover_aug_coord(x)  # S3 method for class 'eigen_ord' as_tbl_ord(x)  # S3 method for class 'eigen_ord' recover_rows(x)  # S3 method for class 'eigen_ord' recover_cols(x)  # S3 method for class 'eigen_ord' recover_inertia(x)  # S3 method for class 'eigen_ord' recover_coord(x)  # S3 method for class 'eigen_ord' recover_conference(x)  # S3 method for class 'eigen_ord' recover_aug_rows(x)  # S3 method for class 'eigen_ord' recover_aug_cols(x)  # S3 method for class 'eigen_ord' recover_aug_coord(x)"},{"path":"/reference/methods-eigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for eigen-decompositions — methods-eigen","text":"x ordination object.","code":""},{"path":"/reference/methods-eigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for eigen-decompositions — methods-eigen","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-eigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for eigen-decompositions — methods-eigen","text":"base::eigen() usually returns object class \"eigen\", contains numerical eigendecomposition without annotations row column names. facilitate downstream analysis, eigen_ord() returns modified 'eigen' object row names taken (available) original data column names indicating integer index eigenvector.","code":""},{"path":[]},{"path":"/reference/methods-eigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for eigen-decompositions — methods-eigen","text":"","code":"# eigendecompose covariance matrix of ability tests gi_eigen <- eigen(ability.cov$cov)  # recover eigenvectors get_rows(gi_eigen) #>              EV1         EV2         EV3         EV4         EV5          EV6 #> [1,] -0.22869031 -0.02614951  0.55367919  0.65291077 -0.42125795 -0.191586979 #> [2,] -0.08380792 -0.08365448  0.08175861  0.04179166 -0.21588953  0.964851729 #> [3,] -0.62773627 -0.73872033 -0.12880737 -0.18084446 -0.01592981 -0.103390720 #> [4,] -0.09460078 -0.08807900 -0.01657141  0.54566079  0.81513697  0.144305927 #> [5,] -0.36706353  0.30009148  0.67111717 -0.47373359  0.31556525  0.028394942 #> [6,] -0.63477493  0.59059089 -0.46849833  0.13071747 -0.10793510  0.005954517 identical(get_cols(gi_eigen), get_rows(gi_eigen)) #> [1] TRUE  # wrap as a 'tbl_ord' as_tbl_ord(gi_eigen) #> # A tbl_ord of class 'eigen': (6 x 6) x (6 x 6)' #> # 6 coordinates: EV1, EV2, ..., EV6 #> #  #> # Rows (standard): [ 6 x 6 | 0 ] #>       EV1     EV2     EV3 ... |  #>                               |  #> 1 -0.229  -0.0261  0.554      |  #> 2 -0.0838 -0.0837  0.0818     |  #> 3 -0.628  -0.739  -0.129  ... |  #> 4 -0.0946 -0.0881 -0.0166     |  #> 5 -0.367   0.300   0.671      |  #> 6 -0.635   0.591  -0.468      |  #> #  #> # Columns (standard): [ 6 x 6 | 0 ] #>       EV1     EV2     EV3 ... |  #>                               |  #> 1 -0.229  -0.0261  0.554      |  #> 2 -0.0838 -0.0837  0.0818     |  #> 3 -0.628  -0.739  -0.129  ... |  #> 4 -0.0946 -0.0881 -0.0166     |  #> 5 -0.367   0.300   0.671      |  #> 6 -0.635   0.591  -0.468      |   # same eigendecomposition, preserving names gi_eigen <- eigen_ord(ability.cov$cov)  # wrap as a 'tbl_ord' and augment with dimension names augment_ord(as_tbl_ord(gi_eigen)) #> # A tbl_ord of class 'eigen_ord': (6 x 6) x (6 x 6)' #> # 6 coordinates: EV1, EV2, ..., EV6 #> #  #> # Rows (standard): [ 6 x 6 | 1 ] #>       EV1     EV2     EV3 ... |   name    #>                               |   <chr>   #> 1 -0.229  -0.0261  0.554      | 1 general #> 2 -0.0838 -0.0837  0.0818     | 2 picture #> 3 -0.628  -0.739  -0.129  ... | 3 blocks  #> 4 -0.0946 -0.0881 -0.0166     | 4 maze    #> 5 -0.367   0.300   0.671      | 5 reading #> 6 -0.635   0.591  -0.468      | 6 vocab   #> #  #> # Columns (standard): [ 6 x 6 | 1 ] #>       EV1     EV2     EV3 ... |   name    #>                               |   <chr>   #> 1 -0.229  -0.0261  0.554      | 1 general #> 2 -0.0838 -0.0837  0.0818     | 2 picture #> 3 -0.628  -0.739  -0.129  ... | 3 blocks  #> 4 -0.0946 -0.0881 -0.0166     | 4 maze    #> 5 -0.367   0.300   0.671      | 5 reading #> 6 -0.635   0.591  -0.468      | 6 vocab    # decomposition returns pure eigenvectors get_conference(gi_eigen) #> [1] 0 0"},{"path":"/reference/methods-factanal.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for factor analysis ('factanal') objects — methods-factanal","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"methods extract data , attribute new data , objects class \"factanal\" returned stats::factanal().","code":""},{"path":"/reference/methods-factanal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"","code":"# S3 method for class 'factanal' as_tbl_ord(x)  # S3 method for class 'factanal' recover_rows(x)  # S3 method for class 'factanal' recover_cols(x)  # S3 method for class 'factanal' recover_inertia(x)  # S3 method for class 'factanal' recover_coord(x)  # S3 method for class 'factanal' recover_conference(x)  # S3 method for class 'factanal' recover_supp_rows(x)  # S3 method for class 'factanal' recover_aug_rows(x)  # S3 method for class 'factanal' recover_aug_cols(x)  # S3 method for class 'factanal' recover_aug_coord(x)"},{"path":"/reference/methods-factanal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"x ordination object.","code":""},{"path":"/reference/methods-factanal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-factanal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"Factor analysis data matrix relies eigendecomposition correlation matrix, whose eigenvectors (weighting) comprise variable loadings. reason, row column recoverers retrieve loadings inertia evenly distributed . computed returned stats::factanal(), case scores accessible supplementary elements. Redistribution inertia commutes score calculations.","code":""},{"path":[]},{"path":"/reference/methods-factanal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for factor analysis ('factanal') objects — methods-factanal","text":"","code":"# data frame of Swiss fertility and socioeconomic indicators class(swiss) #> [1] \"data.frame\" head(swiss) #>              Fertility Agriculture Examination Education Catholic #> Courtelary        80.2        17.0          15        12     9.96 #> Delemont          83.1        45.1           6         9    84.84 #> Franches-Mnt      92.5        39.7           5         5    93.40 #> Moutier           85.8        36.5          12         7    33.77 #> Neuveville        76.9        43.5          17        15     5.16 #> Porrentruy        76.1        35.3           9         7    90.57 #>              Infant.Mortality #> Courtelary               22.2 #> Delemont                 22.2 #> Franches-Mnt             20.2 #> Moutier                  20.3 #> Neuveville               20.6 #> Porrentruy               26.6 # perform factor analysis swiss_fa <- factanal(~ ., factors = 2L, data = swiss, scores = \"regression\")  # wrap as a 'tbl_ord' object (swiss_fa <- as_tbl_ord(swiss_fa)) #> # A tbl_ord of class 'factanal': (47 x 2) x (6 x 2)' #> # 2 coordinates: Factor1 and Factor2 #> #  #> # Rows (principal): [ 47 x 2 | 0 ] #>   Factor1 Factor2 |  #>                   |  #> 1  0.0791  -0.634 |  #> 2 -0.179    1.08  |  #> 3 -0.588    1.20  |  #> 4 -0.424   -0.158 |  #> 5  0.382   -0.668 |  #> # ℹ 42 more rows |  #>  #> #  #> # Columns (principal): [ 6 x 2 | 0 ] #>   Factor1 Factor2 |  #>                   |  #> 1 -0.652   0.393  |  #> 2 -0.631   0.333  |  #> 3  0.685  -0.510  |  #> 4  0.997  -0.0313 |  #> 5 -0.124   0.961  |  #> 6 -0.0947  0.175  |   # recover loadings get_rows(swiss_fa, elements = \"active\") #>      Factor1 Factor2 get_cols(swiss_fa) #>                      Factor1     Factor2 #> Fertility        -0.65238512  0.39335226 #> Agriculture      -0.63054439  0.33275063 #> Examination       0.68498141 -0.51036433 #> Education         0.99700850 -0.03128268 #> Catholic         -0.12417831  0.96118093 #> Infant.Mortality -0.09466294  0.17483734 # recover scores head(get_rows(swiss_fa, elements = \"score\")) #>                  Factor1    Factor2 #> Courtelary    0.07912746 -0.6344915 #> Delemont     -0.17926953  1.0783941 #> Franches-Mnt -0.58784929  1.2004233 #> Moutier      -0.42433417 -0.1583409 #> Neuveville    0.38211185 -0.6682790 #> Porrentruy   -0.37286722  1.0884740  # augment column loadings with uniquenesses (swiss_fa <- augment_ord(swiss_fa)) #> # A tbl_ord of class 'factanal': (47 x 2) x (6 x 2)' #> # 2 coordinates: Factor1 and Factor2 #> #  #> # Rows (principal): [ 47 x 2 | 2 ] #>   Factor1 Factor2 |   .element name         #>                   |   <chr>    <chr>        #> 1  0.0791  -0.634 | 1 score    Courtelary   #> 2 -0.179    1.08  | 2 score    Delemont     #> 3 -0.588    1.20  | 3 score    Franches-Mnt #> 4 -0.424   -0.158 | 4 score    Moutier      #> 5  0.382   -0.668 | 5 score    Neuveville   #> # ℹ 42 more rows | # ℹ 42 more rows #>  #> #  #> # Columns (principal): [ 6 x 2 | 3 ] #>   Factor1 Factor2 |   name           uniqueness .element #>                   |   <chr>               <dbl> <chr>    #> 1 -0.652   0.393  | 1 Fertility          0.420  active   #> 2 -0.631   0.333  | 2 Agriculture        0.492  active   #> 3  0.685  -0.510  | 3 Examination        0.270  active   #> 4  0.997  -0.0313 | 4 Education          0.005  active   #> 5 -0.124   0.961  | 5 Catholic           0.0607 active   #> 6 -0.0947  0.175  | 6 Infant.Mortal…     0.960  active    # symmetric biplot swiss_fa %>%   ggbiplot() +   theme_bw() +   geom_cols_vector(aes(color = uniqueness, label = name)) +   expand_limits(x = c(-2, 2.5), y = c(-1.5, 2))"},{"path":"/reference/methods-kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","title":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","text":"methods extract data , attribute new data , objects class \"kmeans\" returned stats::kmeans().","code":""},{"path":"/reference/methods-kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","text":"","code":"# S3 method for class 'kmeans' as_tbl_ord(x)  # S3 method for class 'kmeans' recover_rows(x)  # S3 method for class 'kmeans' recover_cols(x)  # S3 method for class 'kmeans' recover_coord(x)  # S3 method for class 'kmeans' recover_aug_rows(x)  # S3 method for class 'kmeans' recover_aug_cols(x)  # S3 method for class 'kmeans' recover_aug_coord(x)"},{"path":"/reference/methods-kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","text":"x ordination object.","code":""},{"path":"/reference/methods-kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for k-means clustering ('kmeans') objects — methods-kmeans","text":"","code":"# data frame of Anderson iris species measurements class(iris) #> [1] \"data.frame\" head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa # compute 3-means clustering on scaled iris measurements set.seed(5601L) iris %>%   subset(select = -Species) %>%   scale() %>%   kmeans(centers = 3) %>%   print() -> iris_km #> K-means clustering with 3 clusters of sizes 50, 53, 47 #>  #> Cluster means: #>   Sepal.Length Sepal.Width Petal.Length Petal.Width #> 1  -1.01119138  0.85041372   -1.3006301  -1.2507035 #> 2  -0.05005221 -0.88042696    0.3465767   0.2805873 #> 3   1.13217737  0.08812645    0.9928284   1.0141287 #>  #> Clustering vector: #>   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  #>   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1  #>  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  #>   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1  #>  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  #>   1   1   1   1   1   1   1   1   1   1   3   3   3   2   2   2   3   2   2   2  #>  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  #>   2   2   2   2   2   3   2   2   2   2   3   2   2   2   2   3   3   3   2   2  #>  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100  #>   2   2   2   2   2   3   3   2   2   2   2   2   2   2   2   2   2   2   2   2  #> 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  #>   3   2   3   3   3   3   2   3   3   3   3   3   3   2   2   3   3   3   3   2  #> 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  #>   3   2   3   2   3   3   2   3   3   3   3   3   3   2   2   3   3   3   2   3  #> 141 142 143 144 145 146 147 148 149 150  #>   3   3   2   3   3   3   2   3   3   2  #>  #> Within cluster sum of squares by cluster: #> [1] 47.35062 44.08754 47.45019 #>  (between_SS / total_SS =  76.7 %) #>  #> Available components: #>  #> [1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\" #> [6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"        # visualize clusters using PCA iris %>%   subset(select = -Species) %>%   prcomp() %>%   as_tbl_ord() %>%   mutate_rows(cluster = iris_km$cluster) %>%   ggbiplot() +   geom_rows_point(aes(color = factor(as.character(as.integer(cluster)),                                      levels = as.character(seq(3L))))) +   scale_color_brewer(type = \"qual\", name = \"cluster\")   # wrap as a 'tbl_ord' object (iris_km_ord <- as_tbl_ord(iris_km)) #> # A tbl_ord of class 'kmeans': (150 x 3) x (4 x 3)' #> # 3 coordinates: 1, 2, 3 #> #  #> # Rows: [ 150 x 3 | 0 ] #>     `1`   `2`   `3` |  #>                     |  #> 1     1     0     0 |  #> 2     1     0     0 |  #> 3     1     0     0 |  #> 4     1     0     0 |  #> 5     1     0     0 |  #> # ℹ 145 more rows |  #>  #> #  #> # Columns: [ 4 x 3 | 0 ] #>      `1`     `2`    `3` |  #>                         |  #> 1 -1.01  -0.0501 1.13   |  #> 2  0.850 -0.880  0.0881 |  #> 3 -1.30   0.347  0.993  |  #> 4 -1.25   0.281  1.01   |   # augment everything with names, observations with cluster assignment (iris_km_ord <- augment_ord(iris_km_ord)) #> # A tbl_ord of class 'kmeans': (150 x 3) x (4 x 3)' #> # 3 coordinates: 1, 2, 3 #> #  #> # Rows: [ 150 x 3 | 2 ] #>     `1`   `2`   `3` |   name  cluster #>                     |   <chr> <fct>   #> 1     1     0     0 | 1 1     1       #> 2     1     0     0 | 2 2     1       #> 3     1     0     0 | 3 3     1       #> 4     1     0     0 | 4 4     1       #> 5     1     0     0 | 5 5     1       #> # ℹ 145 more rows | # ℹ 145 more rows #>  #> #  #> # Columns: [ 4 x 3 | 1 ] #>      `1`     `2`    `3` |   name         #>                         |   <chr>        #> 1 -1.01  -0.0501 1.13   | 1 Sepal.Length #> 2  0.850 -0.880  0.0881 | 2 Sepal.Width  #> 3 -1.30   0.347  0.993  | 3 Petal.Length #> 4 -1.25   0.281  1.01   | 4 Petal.Width   # summarize clusters with standard deviation iris_km_ord %>%   tidy() %>%   transform(sdev = sqrt(withinss / size)) #>   name size withinss inertia prop_var quality      sdev #> 1    1   50 47.35062      NA       NA      NA 0.9731456 #> 2    2   53 44.08754      NA       NA      NA 0.9120529 #> 3    3   47 47.45019      NA       NA      NA 1.0047779  # discriminate between clusters 2 and 3 iris_km_ord %>%   ggbiplot(aes(x = `2`, y = `3`), color = factor(.cluster)) +   geom_jitter(stat = \"rows\", aes(shape = cluster), width = .2, height = .2) +   geom_cols_axis(aes(color = `1`, label = name),                  text.size = 2, text_dodge = .1,                  size = 3, label.alpha = .5) +   scale_x_continuous(expand = expansion(mult = .8)) +   scale_y_continuous(expand = expansion(mult = .5)) +   ggtitle(     \"Measurement loadings onto clusters 2 and 3\",     \"Color indicates loadings onto cluster 1\"   )"},{"path":"/reference/methods-lda.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"methods extract data , attribute new data , objects class \"lda\" \"lda_ord\" returned MASS::lda() lda_ord().","code":""},{"path":"/reference/methods-lda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"","code":"# S3 method for class 'lda' as_tbl_ord(x)  # S3 method for class 'lda_ord' as_tbl_ord(x)  # S3 method for class 'lda' recover_rows(x)  # S3 method for class 'lda_ord' recover_rows(x)  # S3 method for class 'lda' recover_cols(x)  # S3 method for class 'lda_ord' recover_cols(x)  # S3 method for class 'lda' recover_inertia(x)  # S3 method for class 'lda_ord' recover_inertia(x)  # S3 method for class 'lda' recover_coord(x)  # S3 method for class 'lda_ord' recover_coord(x)  # S3 method for class 'lda' recover_conference(x)  # S3 method for class 'lda_ord' recover_conference(x)  # S3 method for class 'lda' recover_aug_rows(x)  # S3 method for class 'lda_ord' recover_aug_rows(x)  # S3 method for class 'lda' recover_aug_cols(x)  # S3 method for class 'lda_ord' recover_aug_cols(x)  # S3 method for class 'lda' recover_aug_coord(x)  # S3 method for class 'lda_ord' recover_aug_coord(x)  # S3 method for class 'lda' recover_supp_rows(x)  # S3 method for class 'lda_ord' recover_supp_rows(x)"},{"path":"/reference/methods-lda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"x ordination object.","code":""},{"path":"/reference/methods-lda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-lda.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"See lda-ord details.","code":""},{"path":[]},{"path":"/reference/methods-lda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for linear discriminant analysis ('lda') objects — methods-lda","text":"","code":"# data frame of Anderson iris species measurements class(iris) #> [1] \"data.frame\" head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa  # default (unstandardized discriminant) coefficients lda_ord(iris[, 1:4], iris[, 5]) %>%   as_tbl_ord() %>%   print() -> iris_lda #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 0 ] #>     LD1    LD2 |  #>                |  #> 1  7.61 -0.215 |  #> 2 -1.83  0.728 |  #> 3 -5.78 -0.513 |  #> 4  8.06 -0.300 |  #> 5  7.13  0.787 |  #> # ℹ 148 more rows |  #>  #> #  #> # Columns (standard): [ 4 x 2 | 0 ] #>      LD1     LD2 |  #>                  |  #> 1  0.829 -0.0241 |  #> 2  1.53  -2.16   |  #> 3 -2.20   0.932  |  #> 4 -2.81  -2.84   |   # recover centroid coordinates and measurement discriminant coefficients get_rows(iris_lda, elements = \"active\") #>                  LD1        LD2 #> setosa      7.607600 -0.2151330 #> versicolor -1.825049  0.7278996 #> virginica  -5.782550 -0.5127666 head(get_rows(iris_lda, elements = \"score\")) #>           LD1        LD2 #> [1,] 8.061800 -0.3004206 #> [2,] 7.128688  0.7866604 #> [3,] 7.489828  0.2653845 #> [4,] 6.813201  0.6706311 #> [5,] 8.132309 -0.5144625 #> [6,] 7.701947 -1.4617210 get_cols(iris_lda) #>                     LD1         LD2 #> Sepal.Length  0.8293776 -0.02410215 #> Sepal.Width   1.5344731 -2.16452123 #> Petal.Length -2.2012117  0.93192121 #> Petal.Width  -2.8104603 -2.83918785  # augment ordination with centroid and measurement names augment_ord(iris_lda) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 5 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 1 more variable: .element <chr> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active"},{"path":"/reference/methods-lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for linear model objects — methods-lm","title":"Functionality for linear model objects — methods-lm","text":"methods extract data , attribute new data , objects class \"lm\", \"glm\", \"mlm\" returned stats::lm() stats::glm().","code":""},{"path":"/reference/methods-lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for linear model objects — methods-lm","text":"","code":"# S3 method for class 'lm' as_tbl_ord(x)  # S3 method for class 'lm' recover_rows(x)  # S3 method for class 'lm' recover_cols(x)  # S3 method for class 'lm' recover_coord(x)  # S3 method for class 'lm' recover_aug_rows(x)  # S3 method for class 'lm' recover_aug_cols(x)  # S3 method for class 'lm' recover_aug_coord(x)  # S3 method for class 'glm' recover_aug_rows(x)  # S3 method for class 'mlm' recover_rows(x)  # S3 method for class 'mlm' recover_cols(x)  # S3 method for class 'mlm' recover_coord(x)  # S3 method for class 'mlm' recover_aug_rows(x)  # S3 method for class 'mlm' recover_aug_cols(x)  # S3 method for class 'mlm' recover_aug_coord(x)"},{"path":"/reference/methods-lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for linear model objects — methods-lm","text":"x ordination object.","code":""},{"path":"/reference/methods-lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for linear model objects — methods-lm","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for linear model objects — methods-lm","text":"","code":"# Motor Trend design and performance data head(mtcars) #>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 #> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 # regression analysis of performance measures on design specifications mtcars_centered <- scale(mtcars, scale = FALSE) mtcars_centered %>%   as.data.frame() %>%   lm(formula = mpg ~ wt + cyl) %>%   print() -> mtcars_lm #>  #> Call: #> lm(formula = mpg ~ wt + cyl, data = .) #>  #> Coefficients: #> (Intercept)           wt          cyl   #>   5.574e-15   -3.191e+00   -1.508e+00   #>   # wrap as a 'tbl_ord' object (mtcars_lm_ord <- as_tbl_ord(mtcars_lm)) #> # A tbl_ord of class 'lm': (32 x 3) x (1 x 3)' #> # 3 coordinates: (Intercept), wt, cyl #> #  #> # Rows: [ 32 x 3 | 0 ] #>   `(Intercept)`       wt    cyl |  #>                                 |  #> 1             1 -0.597   -0.188 |  #> 2             1 -0.342   -0.188 |  #> 3             1 -0.897   -2.19  |  #> 4             1 -0.00225 -0.188 |  #> 5             1  0.223    1.81  |  #> # ℹ 27 more rows |  #>  #> #  #> # Columns: [ 1 x 3 | 0 ] #>   `(Intercept)`    wt   cyl |  #>                             |  #> 1      5.57e-15 -3.19 -1.51 |  # augment everything with names, predictors with observation stats augment_ord(mtcars_lm_ord) #> # A tbl_ord of class 'lm': (32 x 3) x (1 x 3)' #> # 3 coordinates: (Intercept), wt, cyl #> #  #> # Rows: [ 32 x 3 | 7 ] #>   `(Intercept)`       wt    cyl |   name      hat sigma  cooksd wt.res #>                                 |   <chr>   <dbl> <dbl>   <dbl>  <dbl> #> 1             1 -0.597   -0.188 | 1 Mazda… 0.0548  2.60 5.08e-3 -1.28  #> 2             1 -0.342   -0.188 | 2 Mazda… 0.0376  2.61 4.44e-4 -0.465 #> 3             1 -0.897   -2.19  | 3 Datsu… 0.0798  2.52 5.68e-2 -3.45  #> 4             1 -0.00225 -0.188 | 4 Horne… 0.0321  2.61 1.80e-3  1.02  #> 5             1  0.223    1.81  | 5 Horne… 0.0912  2.58 2.35e-2  2.05  #> # ℹ 27 more rows | # ℹ 27 more rows #> # ℹ 2 more variables: .fit <dbl>, #> #   .se.fit <dbl> #> #  #> # Columns: [ 1 x 3 | 1 ] #>   `(Intercept)`    wt   cyl |   name  #>                             |   <chr> #> 1      5.57e-15 -3.19 -1.51 | 1 mpg   # calculate influences as the squares of weighted residuals mutate_rows(augment_ord(mtcars_lm_ord), influence = wt.res^2) #> # A tbl_ord of class 'lm': (32 x 3) x (1 x 3)' #> # 3 coordinates: (Intercept), wt, cyl #> #  #> # Rows: [ 32 x 3 | 8 ] #>   `(Intercept)`       wt    cyl |   name      hat sigma  cooksd wt.res #>                                 |   <chr>   <dbl> <dbl>   <dbl>  <dbl> #> 1             1 -0.597   -0.188 | 1 Mazda… 0.0548  2.60 5.08e-3 -1.28  #> 2             1 -0.342   -0.188 | 2 Mazda… 0.0376  2.61 4.44e-4 -0.465 #> 3             1 -0.897   -2.19  | 3 Datsu… 0.0798  2.52 5.68e-2 -3.45  #> 4             1 -0.00225 -0.188 | 4 Horne… 0.0321  2.61 1.80e-3  1.02  #> 5             1  0.223    1.81  | 5 Horne… 0.0912  2.58 2.35e-2  2.05  #> # ℹ 27 more rows | # ℹ 27 more rows #> # ℹ 3 more variables: .fit <dbl>, #> #   .se.fit <dbl>, influence <dbl> #> #  #> # Columns: [ 1 x 3 | 1 ] #>   `(Intercept)`    wt   cyl |   name  #>                             |   <chr> #> 1      5.57e-15 -3.19 -1.51 | 1 mpg    # regression biplot with performance isolines mtcars_lm_ord %>%   augment_ord() %>%   mutate_cols(center = attr(mtcars_centered, \"scaled:center\")[name]) %>%   mutate_rows(influence = wt.res^2) %T>% print() %>%   ggbiplot(aes(x = wt, y = cyl, intercept = `(Intercept)`)) +   #theme_biplot() +   geom_origin(marker = \"circle\", radius = unit(0.02, \"snpc\")) +   geom_rows_point(aes(color = influence)) +   geom_cols_vector() +   geom_cols_isoline(aes(center = center), by = .5, hjust = -.1) +   ggtitle(     \"Weight isolines with data colored by importance\",     \"Regressing gas mileage onto weight and number of cylinders\"   ) #> # A tbl_ord of class 'lm': (32 x 3) x (1 x 3)' #> # 3 coordinates: (Intercept), wt, cyl #> #  #> # Rows: [ 32 x 3 | 8 ] #>   `(Intercept)`       wt    cyl |   name      hat sigma  cooksd wt.res #>                                 |   <chr>   <dbl> <dbl>   <dbl>  <dbl> #> 1             1 -0.597   -0.188 | 1 Mazda… 0.0548  2.60 5.08e-3 -1.28  #> 2             1 -0.342   -0.188 | 2 Mazda… 0.0376  2.61 4.44e-4 -0.465 #> 3             1 -0.897   -2.19  | 3 Datsu… 0.0798  2.52 5.68e-2 -3.45  #> 4             1 -0.00225 -0.188 | 4 Horne… 0.0321  2.61 1.80e-3  1.02  #> 5             1  0.223    1.81  | 5 Horne… 0.0912  2.58 2.35e-2  2.05  #> # ℹ 27 more rows | # ℹ 27 more rows #> # ℹ 3 more variables: .fit <dbl>, #> #   .se.fit <dbl>, influence <dbl> #> #  #> # Columns: [ 1 x 3 | 2 ] #>   `(Intercept)`    wt   cyl |   name  center #>                             |   <chr>  <dbl> #> 1      5.57e-15 -3.19 -1.51 | 1 mpg     20.1"},{"path":"/reference/methods-lra.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for log-ratio analysis ('lra') objects — methods-lra","title":"Functionality for log-ratio analysis ('lra') objects — methods-lra","text":"methods extract data , attribute new data , objects class \"lra\", class introduced package organize singular value decomposition double-centered log-transformed data matrix output lra().","code":""},{"path":"/reference/methods-lra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for log-ratio analysis ('lra') objects — methods-lra","text":"","code":"# S3 method for class 'lra' as_tbl_ord(x)  # S3 method for class 'lra' recover_rows(x)  # S3 method for class 'lra' recover_cols(x)  # S3 method for class 'lra' recover_inertia(x)  # S3 method for class 'lra' recover_coord(x)  # S3 method for class 'lra' recover_conference(x)  # S3 method for class 'lra' recover_aug_rows(x)  # S3 method for class 'lra' recover_aug_cols(x)  # S3 method for class 'lra' recover_aug_coord(x)"},{"path":"/reference/methods-lra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for log-ratio analysis ('lra') objects — methods-lra","text":"x ordination object.","code":""},{"path":"/reference/methods-lra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for log-ratio analysis ('lra') objects — methods-lra","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-lra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for log-ratio analysis ('lra') objects — methods-lra","text":"","code":"# data frame of violent crime arrests in the United States class(USArrests) #> [1] \"data.frame\" head(USArrests) #>            Murder Assault UrbanPop Rape #> Alabama      13.2     236       58 21.2 #> Alaska       10.0     263       48 44.5 #> Arizona       8.1     294       80 31.0 #> Arkansas      8.8     190       50 19.5 #> California    9.0     276       91 40.6 #> Colorado      7.9     204       78 38.7 # get state abbreviation data state <- data.frame(   name = state.name,   abb = state.abb )  # compute (non-compositional, unweighted) log-ratio analysis USArrests %>%   subset(select = -UrbanPop) %>%   lra() %>%   as_tbl_ord() %>%   print() -> arrests_lra #> # A tbl_ord of class 'lra': (50 x 2) x (3 x 2)' #> # 2 coordinates: LRSV1 and LRSV2 #> #  #> # Rows (standard): [ 50 x 2 | 0 ] #>    LRSV1  LRSV2 |  #>                 |  #> 1 -0.680  0.930 |  #> 2  0.930 -0.625 |  #> 3 -0.330 -1.31  |  #> 4 -0.351  0.277 |  #> 5  0.552 -1.00  |  #> # ℹ 45 more rows |  #>  #> #  #> # Columns (standard): [ 3 x 2 | 0 ] #>    LRSV1  LRSV2 |  #>                 |  #> 1  0.283  4.96  |  #> 2 -0.371 -0.181 |  #> 3  2.88  -0.366 |   # augment log-ratio profiles with names and join state abbreviations arrests_lra %>%   augment_ord() %>%   left_join_rows(state, by = \"name\") %>%   print() -> arrests_lra #> # A tbl_ord of class 'lra': (50 x 2) x (3 x 2)' #> # 2 coordinates: LRSV1 and LRSV2 #> #  #> # Rows (standard): [ 50 x 2 | 3 ] #>    LRSV1  LRSV2 |   name       weight abb   #>                 |   <chr>       <dbl> <chr> #> 1 -0.680  0.930 | 1 Alabama    0.0271 AL    #> 2  0.930 -0.625 | 2 Alaska     0.0318 AK    #> 3 -0.330 -1.31  | 3 Arizona    0.0333 AZ    #> 4 -0.351  0.277 | 4 Arkansas   0.0219 AR    #> 5  0.552 -1.00  | 5 California 0.0326 CA    #> # ℹ 45 more rows | # ℹ 45 more rows #>  #> #  #> # Columns (standard): [ 3 x 2 | 2 ] #>    LRSV1  LRSV2 |   name    weight #>                 |   <chr>    <dbl> #> 1  0.283  4.96  | 1 Murder  0.0390 #> 2 -0.371 -0.181 | 2 Assault 0.855  #> 3  2.88  -0.366 | 3 Rape    0.106   # recover state and arrest profiles head(get_rows(arrests_lra)) #>                 LRSV1      LRSV2 #> Alabama    -0.6800120  0.9296011 #> Alaska      0.9299899 -0.6245772 #> Arizona    -0.3298496 -1.3115817 #> Arkansas   -0.3513443  0.2773231 #> California  0.5516590 -1.0042801 #> Colorado    1.2291066 -0.6388469 get_cols(arrests_lra) #>             LRSV1      LRSV2 #> Murder   0.283086  4.9570302 #> Assault -0.370595 -0.1805698 #> Rape     2.876702 -0.3660163 # initially, inertia is conferred on neither factor get_conference(arrests_lra) #> [1] 0 0  # row-principal biplot arrests_lra %>%   confer_inertia(\"rows\") %>%   ggbiplot(aes(color = .matrix), sec.axes = \"cols\", scale.factor = 1/20) +   scale_color_manual(values = c(\"tomato4\", \"turquoise4\")) +   theme_bw() + theme_biplot() +   geom_rows_text(aes(label = abb), size = 3, alpha = .75) +   geom_cols_polygon(fill = NA, linetype = \"dashed\") +   geom_cols_text(aes(label = name, size = weight), fontface = \"bold\") +   scale_size_area(guide = \"none\") +   ggtitle(     \"Violent crime arrest rates\",     \"Non-compositional LRA\"   ) +   coord_scaffold() +   guides(color = \"none\")"},{"path":"/reference/methods-mca.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"methods extract data , attribute new data , objects class \"mca\" MASS package.","code":""},{"path":"/reference/methods-mca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"","code":"# S3 method for class 'mca' as_tbl_ord(x)  # S3 method for class 'mca' recover_rows(x)  # S3 method for class 'mca' recover_cols(x)  # S3 method for class 'mca' recover_inertia(x)  # S3 method for class 'mca' recover_conference(x)  # S3 method for class 'mca' recover_coord(x)  # S3 method for class 'mca' recover_supp_rows(x)  # S3 method for class 'mca' recover_aug_rows(x)  # S3 method for class 'mca' recover_aug_cols(x)  # S3 method for class 'mca' recover_aug_coord(x)"},{"path":"/reference/methods-mca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"x ordination object.","code":""},{"path":"/reference/methods-mca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-mca.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"Multiple correspondence analysis (MCA) relies singular value decomposition indicator matrix \\(X\\) table several categorical variables, scaled column totals. MASS::mca() returns SVD factors \\(UD\\) \\(V\\) row weights $fs, inertia conferred, column coordinates $cs. row coordinates $rs obtained \\(XV\\) accessible supplementary elements.","code":""},{"path":[]},{"path":"/reference/methods-mca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for multiple correspondence analysis ('mca') objects — methods-mca","text":"","code":"# table of admissions and rejections from UC Berkeley class(UCBAdmissions) #> [1] \"table\" ucb_admissions <- as.data.frame(UCBAdmissions) ucb_admissions <-   ucb_admissions[rep(seq(nrow(ucb_admissions)), ucb_admissions$Freq), -4L] head(ucb_admissions) #>        Admit Gender Dept #> 1   Admitted   Male    A #> 1.1 Admitted   Male    A #> 1.2 Admitted   Male    A #> 1.3 Admitted   Male    A #> 1.4 Admitted   Male    A #> 1.5 Admitted   Male    A # perform multiple correspondence analysis ucb_admissions %>%   MASS::mca() %>%   as_tbl_ord() %>%   # augment profiles with names, masses, distances, and inertias   augment_ord() %>%   print() -> admissions_mca #> # A tbl_ord of class 'mca': (9052 x 2) x (10 x 2)' #> # 2 coordinates: Dim1 and Dim2 #> #  #> # Rows (principal): [ 9052 x 2 | 2 ] #>       Dim1     Dim2 |   name  .element #>                     |   <chr> <chr>    #> 1 -0.01000 -0.00261 | 1 1     active   #> 2 -0.01000 -0.00261 | 2 1.1   active   #> 3 -0.01000 -0.00261 | 3 1.2   active   #> 4 -0.01000 -0.00261 | 4 1.3   active   #> 5 -0.01000 -0.00261 | 5 1.4   active   #> # ℹ 9,047 more rows | # ℹ 9,047 more rows #>  #> #  #> # Columns (standard): [ 10 x 2 | 4 ] #>        Dim1      Dim2 |    name        factor level .element #>                       |    <chr>       <chr>  <chr> <chr>    #>  1 -0.00533 -0.00483  |  1 Admit.Admi… Admit  Admi… active   #>  2  0.00338  0.00306  |  2 Admit.Reje… Admit  Reje… active   #>  3 -0.00397  0.00266  |  3 Gender.Male Gender Male  active   #>  4  0.00582 -0.00390  |  4 Gender.Fem… Gender Fema… active   #>  5 -0.00748 -0.000829 |  5 Dept.A      Dept   A     active   #>  6 -0.00838  0.00295  |  6 Dept.B      Dept   B     active   #>  7  0.00395 -0.00851  |  7 Dept.C      Dept   C     active   #>  8  0.00160 -0.000439 |  8 Dept.D      Dept   D     active   #>  9  0.00561 -0.00450  |  9 Dept.E      Dept   E     active   #> 10  0.00519  0.0138   | 10 Dept.F      Dept   F     active    # recover row and column coordinates and row weights head(get_rows(admissions_mca, elements = \"score\")) #>             Dim1         Dim2 #> 1   -0.005592325 -0.001001186 #> 1.1 -0.005592325 -0.001001186 #> 1.2 -0.005592325 -0.001001186 #> 1.3 -0.005592325 -0.001001186 #> 1.4 -0.005592325 -0.001001186 #> 1.5 -0.005592325 -0.001001186 get_cols(admissions_mca) #>                        Dim1          Dim2 #> Admit.Admitted -0.005329295 -0.0048307823 #> Admit.Rejected  0.003375284  0.0030595536 #> Gender.Male    -0.003971450  0.0026563610 #> Gender.Female   0.005824072 -0.0038955136 #> Dept.A         -0.007476230 -0.0008291371 #> Dept.B         -0.008381159  0.0029516575 #> Dept.C          0.003949742 -0.0085082718 #> Dept.D          0.001600698 -0.0004388113 #> Dept.E          0.005610973 -0.0045007472 #> Dept.F          0.005193103  0.0137723160 head(get_rows(admissions_mca)) #>             Dim1         Dim2 #> 1   -0.009997779 -0.002609712 #> 1.1 -0.009997779 -0.002609712 #> 1.2 -0.009997779 -0.002609712 #> 1.3 -0.009997779 -0.002609712 #> 1.4 -0.009997779 -0.002609712 #> 1.5 -0.009997779 -0.002609712  # column-standard biplot of factor levels admissions_mca %>%   ggbiplot() +   theme_bw() + theme_biplot() +   geom_origin() +   #geom_rows_point(stat = \"unique\") +   geom_cols_point(aes(color = factor, shape = factor)) +   geom_cols_text_repel(aes(label = level, color = factor),                        show.legend = FALSE) +   scale_color_brewer(palette = \"Dark2\") +   scale_size_area(guide = \"none\") +   labs(color = \"Factor level\", shape = \"Factor level\")"},{"path":"/reference/methods-prcomp.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"methods extract data , attribute new data , objects class \"prcomp\" returned stats::prcomp().","code":""},{"path":"/reference/methods-prcomp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"","code":"# S3 method for class 'prcomp' as_tbl_ord(x)  # S3 method for class 'prcomp' recover_rows(x)  # S3 method for class 'prcomp' recover_cols(x)  # S3 method for class 'prcomp' recover_inertia(x)  # S3 method for class 'prcomp' recover_coord(x)  # S3 method for class 'prcomp' recover_conference(x)  # S3 method for class 'prcomp' recover_aug_rows(x)  # S3 method for class 'prcomp' recover_aug_cols(x)  # S3 method for class 'prcomp' recover_aug_coord(x)"},{"path":"/reference/methods-prcomp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"x ordination object.","code":""},{"path":"/reference/methods-prcomp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-prcomp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"Emily Paul","code":""},{"path":"/reference/methods-prcomp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for principal components analysis ('prcomp') objects — methods-prcomp","text":"","code":"# data frame of Anderson iris species measurements class(iris) #> [1] \"data.frame\" head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa  # compute scaled row-principal components of scaled measurements iris[, -5] %>%   prcomp(scale = TRUE) %>%   as_tbl_ord() %>%   print() -> iris_pca #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2     PC3 ... |  #>                            |  #> 1 -2.26 -0.478  0.127      |  #> 2 -2.07  0.672  0.234      |  #> 3 -2.36  0.341 -0.0441 ... |  #> 4 -2.29  0.595 -0.0910     |  #> 5 -2.38 -0.645 -0.0157     |  #> # ℹ 145 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 0 ] #>      PC1     PC2    PC3 ... |  #>                             |  #> 1  0.521 -0.377   0.720     |  #> 2 -0.269 -0.923  -0.244 ... |  #> 3  0.580 -0.0245 -0.142     |  #> 4  0.565 -0.0669 -0.634     |   # recover observation principal coordinates and measurement standard coordinates head(get_rows(iris_pca)) #>            PC1        PC2         PC3          PC4 #> [1,] -2.257141 -0.4784238  0.12727962  0.024087508 #> [2,] -2.074013  0.6718827  0.23382552  0.102662845 #> [3,] -2.356335  0.3407664 -0.04405390  0.028282305 #> [4,] -2.291707  0.5953999 -0.09098530 -0.065735340 #> [5,] -2.381863 -0.6446757 -0.01568565 -0.035802870 #> [6,] -2.068701 -1.4842053 -0.02687825  0.006586116 get_cols(iris_pca) #>                     PC1         PC2        PC3        PC4 #> Sepal.Length  0.5210659 -0.37741762  0.7195664  0.2612863 #> Sepal.Width  -0.2693474 -0.92329566 -0.2443818 -0.1235096 #> Petal.Length  0.5804131 -0.02449161 -0.1421264 -0.8014492 #> Petal.Width   0.5648565 -0.06694199 -0.6342727  0.5235971  # augment measurements with names and scaling parameters (iris_pca <- augment_ord(iris_pca)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>     PC1    PC2     PC3 ... |  #>                            |  #> 1 -2.26 -0.478  0.127      |  #> 2 -2.07  0.672  0.234      |  #> 3 -2.36  0.341 -0.0441 ... |  #> 4 -2.29  0.595 -0.0910     |  #> 5 -2.38 -0.645 -0.0157     |  #> # ℹ 145 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 3 ] #>      PC1     PC2    PC3 ... |   name         center scale #>                             |   <chr>         <dbl> <dbl> #> 1  0.521 -0.377   0.720     | 1 Sepal.Length   5.84 0.828 #> 2 -0.269 -0.923  -0.244 ... | 2 Sepal.Width    3.06 0.436 #> 3  0.580 -0.0245 -0.142     | 3 Petal.Length   3.76 1.77  #> 4  0.565 -0.0669 -0.634     | 4 Petal.Width    1.20 0.762"},{"path":"/reference/methods-princomp.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for principal components analysis ('princomp') objects — methods-princomp","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"methods extract data , attribute new data , objects class \"princomp\" returned stats::princomp().","code":""},{"path":"/reference/methods-princomp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"","code":"# S3 method for class 'princomp' as_tbl_ord(x)  # S3 method for class 'princomp' recover_rows(x)  # S3 method for class 'princomp' recover_cols(x)  # S3 method for class 'princomp' recover_inertia(x)  # S3 method for class 'princomp' recover_coord(x)  # S3 method for class 'princomp' recover_conference(x)  # S3 method for class 'princomp' recover_supp_rows(x)  # S3 method for class 'princomp' recover_aug_rows(x)  # S3 method for class 'princomp' recover_aug_cols(x)  # S3 method for class 'princomp' recover_aug_coord(x)"},{"path":"/reference/methods-princomp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"x ordination object.","code":""},{"path":"/reference/methods-princomp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":"/reference/methods-princomp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"Principal components analysis (PCA), performed stats::princomp(), relies eigenvalue decomposition (EVD) covariance matrix \\(X^TX\\) data set \\(X\\). stats::princomp() returns EVD factor \\(V\\) loadings $loadings. scores $scores obtained \\(XV\\) accessible supplementary elements.","code":""},{"path":[]},{"path":"/reference/methods-princomp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"Emily Paul, John Gracey","code":""},{"path":"/reference/methods-princomp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for principal components analysis ('princomp') objects — methods-princomp","text":"","code":"# data frame of Anderson iris species measurements class(iris) #> [1] \"data.frame\" head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa  # compute unscaled row-principal components of scaled measurements iris[, -5] %>%   princomp() %>%   as_tbl_ord() %>%   print() -> iris_pca #> # A tbl_ord of class 'princomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: Comp.1, Comp.2, ..., Comp.4 #> #  #> # Rows (principal): [ 150 x 4 | 0 ] #>   Comp.1 Comp.2  Comp.3 ... |  #>                             |  #> 1  -2.68  0.319  0.0279     |  #> 2  -2.71 -0.177  0.210      |  #> 3  -2.89 -0.145 -0.0179 ... |  #> 4  -2.75 -0.318 -0.0316     |  #> 5  -2.73  0.327 -0.0901     |  #> # ℹ 145 more rows     |  #>  #> #  #> # Columns (standard): [ 4 x 4 | 0 ] #>    Comp.1  Comp.2  Comp.3 ... |  #>                               |  #> 1  0.361   0.657   0.582      |  #> 2 -0.0845  0.730  -0.598  ... |  #> 3  0.857  -0.173  -0.0762     |  #> 4  0.358  -0.0755 -0.546      |   # recover observation principal coordinates and measurement standard coordinates head(get_rows(iris_pca)) #>         Comp.1     Comp.2      Comp.3       Comp.4 #> [1,] -2.684126  0.3193972  0.02791483  0.002262437 #> [2,] -2.714142 -0.1770012  0.21046427  0.099026550 #> [3,] -2.888991 -0.1449494 -0.01790026  0.019968390 #> [4,] -2.745343 -0.3182990 -0.03155937 -0.075575817 #> [5,] -2.728717  0.3267545 -0.09007924 -0.061258593 #> [6,] -2.280860  0.7413304 -0.16867766 -0.024200858 get_cols(iris_pca) #>                   Comp.1      Comp.2      Comp.3     Comp.4 #> Sepal.Length  0.36138659  0.65658877  0.58202985  0.3154872 #> Sepal.Width  -0.08452251  0.73016143 -0.59791083 -0.3197231 #> Petal.Length  0.85667061 -0.17337266 -0.07623608 -0.4798390 #> Petal.Width   0.35828920 -0.07548102 -0.54583143  0.7536574  # augment measurement coordinates with names and scaling parameters (iris_pca <- augment_ord(iris_pca)) #> # A tbl_ord of class 'princomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: Comp.1, Comp.2, ..., Comp.4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>   Comp.1 Comp.2  Comp.3 ... |   .element #>                             |   <chr>    #> 1  -2.68  0.319  0.0279     | 1 score    #> 2  -2.71 -0.177  0.210      | 2 score    #> 3  -2.89 -0.145 -0.0179 ... | 3 score    #> 4  -2.75 -0.318 -0.0316     | 4 score    #> 5  -2.73  0.327 -0.0901     | 5 score    #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 4 ] #>    Comp.1  Comp.2  Comp.3 ... |   name         center scale .element #>                               |   <chr>         <dbl> <dbl> <chr>    #> 1  0.361   0.657   0.582      | 1 Sepal.Length   5.84     1 active   #> 2 -0.0845  0.730  -0.598  ... | 2 Sepal.Width    3.06     1 active   #> 3  0.857  -0.173  -0.0762     | 3 Petal.Length   3.76     1 active   #> 4  0.358  -0.0755 -0.546      | 4 Petal.Width    1.20     1 active"},{"path":"/reference/methods-svd.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for singular value decompositions — methods-svd","title":"Functionality for singular value decompositions — methods-svd","text":"methods extract data , attribute new data , objects class \"svd_ord\" returned svd_ord().","code":""},{"path":"/reference/methods-svd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for singular value decompositions — methods-svd","text":"","code":"# S3 method for class 'svd_ord' as_tbl_ord(x)  # S3 method for class 'svd_ord' recover_rows(x)  # S3 method for class 'svd_ord' recover_cols(x)  # S3 method for class 'svd_ord' recover_inertia(x)  # S3 method for class 'svd_ord' recover_coord(x)  # S3 method for class 'svd_ord' recover_conference(x)  # S3 method for class 'svd_ord' recover_aug_rows(x)  # S3 method for class 'svd_ord' recover_aug_cols(x)  # S3 method for class 'svd_ord' recover_aug_coord(x)"},{"path":"/reference/methods-svd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for singular value decompositions — methods-svd","text":"x ordination object.","code":""},{"path":"/reference/methods-svd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for singular value decompositions — methods-svd","text":"recovery generics recover_*() return core model components, distribution inertia, supplementary elements, intrinsic metadata; require methods model class tell components . generic as_tbl_ord() returns input wrapped 'tbl_ord' class. methods determine model classes allowed wrap. provides 'tbl_ord' methods access recoverers hence model components.","code":""},{"path":[]},{"path":"/reference/methods-svd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for singular value decompositions — methods-svd","text":"","code":"# matrix of U.S. personal expenditure data class(USPersonalExpenditure) #> [1] \"matrix\" \"array\"  print(USPersonalExpenditure) #>                       1940   1945  1950 1955  1960 #> Food and Tobacco    22.200 44.500 59.60 73.2 86.80 #> Household Operation 10.500 15.500 29.00 36.5 46.20 #> Medical and Health   3.530  5.760  9.71 14.0 21.10 #> Personal Care        1.040  1.980  2.45  3.4  5.40 #> Private Education    0.341  0.974  1.80  2.6  3.64 # singular value decomposition into row and column coordinates USPersonalExpenditure %>%   svd_ord() %>%   as_tbl_ord() %>%   print() -> spend_svd #> # A tbl_ord of class 'svd_ord': (5 x 5) x (5 x 5)' #> # 5 coordinates: SV1, SV2, ..., SV5 #> #  #> # Rows (standard): [ 5 x 5 | 0 ] #>       SV1     SV2     SV3 ... |  #>                               |  #> 1 -0.881   0.456  -0.122      |  #> 2 -0.436  -0.677   0.583  ... |  #> 3 -0.176  -0.562  -0.734      |  #> 4 -0.0455 -0.0929 -0.314      |  #> 5 -0.0311 -0.0989 -0.0892     |  #> #  #> # Columns (standard): [ 5 x 5 | 0 ] #>      SV1     SV2    SV3 ... |  #>                             |  #> 1 -0.159  0.113   0.182     |  #> 2 -0.302  0.792  -0.527 ... |  #> 3 -0.429  0.211   0.620     |  #> 4 -0.532  0.0266  0.302     |  #> 5 -0.645 -0.561  -0.461     |   # recover matrices of row and column coordinates get_rows(spend_svd) #>                             SV1         SV2         SV3         SV4         SV5 #> Food and Tobacco    -0.88086766  0.45563080 -0.12237718  0.02450591 -0.02993361 #> Household Operation -0.43580483 -0.67662102  0.58341818 -0.07630369  0.07784028 #> Medical and Health  -0.17637018 -0.56230756 -0.73372346  0.04111351 -0.33565360 #> Personal Care       -0.04553400 -0.09285599 -0.31360568 -0.49361448  0.80454996 #> Private Education   -0.03108899 -0.09885616 -0.08915387  0.86500383  0.48278452 get_cols(spend_svd) #>             SV1         SV2        SV3         SV4         SV5 #> 1940 -0.1589586  0.11313761  0.1824780 -0.89728506 -0.35144462 #> 1945 -0.3016855  0.79223017 -0.5274149  0.02654943  0.04985844 #> 1950 -0.4293572  0.21081041  0.6202698 -0.01464040  0.62150007 #> 1955 -0.5323309  0.02659741  0.3024320  0.42107353 -0.66869157 #> 1960 -0.6449761 -0.56073415 -0.4607988 -0.12906349  0.20146975  # augment with row and column names augment_ord(spend_svd) #> # A tbl_ord of class 'svd_ord': (5 x 5) x (5 x 5)' #> # 5 coordinates: SV1, SV2, ..., SV5 #> #  #> # Rows (standard): [ 5 x 5 | 1 ] #>       SV1     SV2     SV3 ... |   name                #>                               |   <chr>               #> 1 -0.881   0.456  -0.122      | 1 Food and Tobacco    #> 2 -0.436  -0.677   0.583  ... | 2 Household Operation #> 3 -0.176  -0.562  -0.734      | 3 Medical and Health  #> 4 -0.0455 -0.0929 -0.314      | 4 Personal Care       #> 5 -0.0311 -0.0989 -0.0892     | 5 Private Education   #> #  #> # Columns (standard): [ 5 x 5 | 1 ] #>      SV1     SV2    SV3 ... |   name  #>                             |   <chr> #> 1 -0.159  0.113   0.182     | 1 1940  #> 2 -0.302  0.792  -0.527 ... | 2 1945  #> 3 -0.429  0.211   0.620     | 3 1950  #> 4 -0.532  0.0266  0.302     | 4 1955  #> 5 -0.645 -0.561  -0.461     | 5 1960  # initial matrix decomposition confers no inertia to coordinates get_conference(spend_svd) #> [1] 0 0"},{"path":"/reference/negation.html","id":null,"dir":"Reference","previous_headings":"","what":"Negation of ordination axes — negation","title":"Negation of ordination axes — negation","text":"Negate coordinates subset ordination axes row column singular vectors.","code":""},{"path":"/reference/negation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negation of ordination axes — negation","text":"","code":"get_negation(x)  revert_negation(x)  negate_ord(x, negation = NULL)  negate_to_first_orthant(x, .matrix)"},{"path":"/reference/negation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negation of ordination axes — negation","text":"x tbl_ord. negation Integer vector coordinates negate. .matrix character string partially matched (lowercase) several indicators one matrices matrix decomposition used ordination. standard values \"rows\", \"cols\", \"dims\" ().","code":""},{"path":"/reference/negation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negation of ordination axes — negation","text":"negate_ord() negate_to_first_orthant() return tbl_ord certain axes negated wrapped model unchanged. get_negation() returns current negations. revert_negation() returns tbl_ord without manual negations. tbl_ord; wrapped model unchanged.","code":""},{"path":"/reference/negation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negation of ordination axes — negation","text":"purposes comparison visualization, can useful negate (already artificial) coordinates ordination, either fixed criteria better align another basis (matrix) coordinates. negate_ord() allows user negate specified coordinates ordination. get_negation() accesses negations ordination, integer vector 1s -1s stored \"negate\" attribute.","code":""},{"path":"/reference/negation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negation of ordination axes — negation","text":"","code":"(pca <- ordinate(iris, cols = 1:4, prcomp)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   Species #>                            |   <fct>   #> 1 -2.68 -0.319  0.0279     | 1 setosa  #> 2 -2.71  0.177  0.210      | 2 setosa  #> 3 -2.89  0.145 -0.0179 ... | 3 setosa  #> 4 -2.75  0.318 -0.0316     | 4 setosa  #> 5 -2.73 -0.327 -0.0901     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1     PC2     PC3 ... |   name         center #>                               |   <chr>         <dbl> #> 1  0.361  -0.657   0.582      | 1 Sepal.Length   5.84 #> 2 -0.0845 -0.730  -0.598  ... | 2 Sepal.Width    3.06 #> 3  0.857   0.173  -0.0762     | 3 Petal.Length   3.76 #> 4  0.358   0.0755 -0.546      | 4 Petal.Width    1.20 ggbiplot(pca) + geom_rows_point() + geom_cols_vector()   # manually negate second coordinate (pca_neg <- negate_ord(pca, 2)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   Species #>                            |   <fct>   #> 1 -2.68  0.319  0.0279     | 1 setosa  #> 2 -2.71 -0.177  0.210      | 2 setosa  #> 3 -2.89 -0.145 -0.0179 ... | 3 setosa  #> 4 -2.75 -0.318 -0.0316     | 4 setosa  #> 5 -2.73  0.327 -0.0901     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1     PC2     PC3 ... |   name         center #>                               |   <chr>         <dbl> #> 1  0.361   0.657   0.582      | 1 Sepal.Length   5.84 #> 2 -0.0845  0.730  -0.598  ... | 2 Sepal.Width    3.06 #> 3  0.857  -0.173  -0.0762     | 3 Petal.Length   3.76 #> 4  0.358  -0.0755 -0.546      | 4 Petal.Width    1.20 ggbiplot(pca_neg) + geom_rows_point() + geom_cols_vector()   # NB: 'prcomp' method takes precedence; negations are part of the wrapper biplot(pca)  biplot(pca_neg)   # negate to the first orthant (pca_orth <- negate_to_first_orthant(pca, \"v\")) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   Species #>                            |   <fct>   #> 1 -2.68  0.319 -0.0279     | 1 setosa  #> 2 -2.71 -0.177 -0.210      | 2 setosa  #> 3 -2.89 -0.145  0.0179 ... | 3 setosa  #> 4 -2.75 -0.318  0.0316     | 4 setosa  #> 5 -2.73  0.327  0.0901     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 2 ] #>       PC1     PC2     PC3 ... |   name         center #>                               |   <chr>         <dbl> #> 1  0.361   0.657  -0.582      | 1 Sepal.Length   5.84 #> 2 -0.0845  0.730   0.598  ... | 2 Sepal.Width    3.06 #> 3  0.857  -0.173   0.0762     | 3 Petal.Length   3.76 #> 4  0.358  -0.0755  0.546      | 4 Petal.Width    1.20 get_negation(pca_orth) #> PC1 PC2 PC3 PC4  #>   1  -1  -1   1"},{"path":"/reference/ordinate.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an ordination model to a data object — ordinate","title":"Fit an ordination model to a data object — ordinate","text":"convenience function fit ordination model data object, wrap result tbl_ord, annotate output metadata model possibly data.","code":""},{"path":"/reference/ordinate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an ordination model to a data object — ordinate","text":"","code":"ordinate(x, model, ...)  # Default S3 method ordinate(x, model, ...)  # S3 method for class 'array' ordinate(x, model, ...)  # S3 method for class 'table' ordinate(x, model, ...)  # S3 method for class 'data.frame' ordinate(x, model, cols, augment, ...)  # S3 method for class 'dist' ordinate(x, model, ...)"},{"path":"/reference/ordinate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an ordination model to a data object — ordinate","text":"x data object passed model, array, table, data.frame, stats::dist. model ordination function whose output coercible class 'tbl_ord', symbol character string (handled match.fun()). Alternatively, formula ~ fun(., ...) fun function arguments explicit, evaluated x place .. ... Additional arguments passed model. cols <tidy-select> x data frame, columns pass model. missing, columns used. augment <tidy-select> x data frame, columns augment row data ordination. missing, columns included cols augmented.","code":""},{"path":"/reference/ordinate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an ordination model to a data object — ordinate","text":"augmented tbl_ord.","code":""},{"path":"/reference/ordinate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit an ordination model to a data object — ordinate","text":"default method fits specified model provided data object, wraps result tbl_ord, augments output intrinsic metadata model via augment_ord(). default method used classes, though may change future. data.frame method allows user specify columns include model columns annotate output.","code":""},{"path":"/reference/ordinate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an ordination model to a data object — ordinate","text":"","code":"# LRA of arrest data ordinate(USArrests, cols = c(Murder, Rape, Assault), lra) #> # A tbl_ord of class 'lra': (50 x 2) x (3 x 2)' #> # 2 coordinates: LRSV1 and LRSV2 #> #  #> # Rows (standard): [ 50 x 2 | 3 ] #>    LRSV1  LRSV2 |   name       weight UrbanPop #>                 |   <chr>       <dbl>    <int> #> 1 -0.680  0.930 | 1 Alabama    0.0271       58 #> 2  0.930 -0.625 | 2 Alaska     0.0318       48 #> 3 -0.330 -1.31  | 3 Arizona    0.0333       80 #> 4 -0.351  0.277 | 4 Arkansas   0.0219       50 #> 5  0.552 -1.00  | 5 California 0.0326       91 #> # ℹ 45 more rows | # ℹ 45 more rows #>  #> #  #> # Columns (standard): [ 3 x 2 | 2 ] #>    LRSV1  LRSV2 |   name    weight #>                 |   <chr>    <dbl> #> 1  0.283  4.96  | 1 Murder  0.0390 #> 2  2.88  -0.366 | 2 Rape    0.106  #> 3 -0.371 -0.181 | 3 Assault 0.855   # CMDS of inter-city distance data ordinate(UScitiesD, cmdscale_ord, k = 3L) #> # A tbl_ord of class 'cmds_ord': (10 x 3) x (10 x 3)' #> # 3 coordinates: PCo1, PCo2, PCo3 #> #  #> # Rows (symmetric): [ 10 x 3 | 1 ] #>      PCo1   PCo2   PCo3 |    name          #>                         |    <chr>         #>  1  -719.  143.   35.1  |  1 Atlanta       #>  2  -382. -341.   29.6  |  2 Chicago       #>  3   482.  -25.3  53.4  |  3 Denver        #>  4  -161.  573.    1.45 |  4 Houston       #>  5  1204.  390.  -18.6  |  5 LosAngeles    #>  6 -1134.  582.  -32.3  |  6 Miami         #>  7 -1072. -519.  -34.3  |  7 NewYork       #>  8  1421.  113.   -7.75 |  8 SanFrancisco  #>  9  1342. -580.  -23.7  |  9 Seattle       #> 10  -980. -335.   -2.90 | 10 Washington.DC #> #  #> # Columns (symmetric): [ 10 x 3 | 1 ] #>      PCo1   PCo2   PCo3 |    name          #>                         |    <chr>         #>  1  -719.  143.   35.1  |  1 Atlanta       #>  2  -382. -341.   29.6  |  2 Chicago       #>  3   482.  -25.3  53.4  |  3 Denver        #>  4  -161.  573.    1.45 |  4 Houston       #>  5  1204.  390.  -18.6  |  5 LosAngeles    #>  6 -1134.  582.  -32.3  |  6 Miami         #>  7 -1072. -519.  -34.3  |  7 NewYork       #>  8  1421.  113.   -7.75 |  8 SanFrancisco  #>  9  1342. -580.  -23.7  |  9 Seattle       #> 10  -980. -335.   -2.90 | 10 Washington.DC  # PCA of iris data ordinate(iris, princomp, cols = -Species, augment = c(Sepal.Width, Species)) #> # A tbl_ord of class 'princomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: Comp.1, Comp.2, ..., Comp.4 #> #  #> # Rows (principal): [ 150 x 4 | 3 ] #>   Comp.1 Comp.2  Comp.3 ... |   .element Sepal.Width Species #>                             |   <chr>          <dbl> <fct>   #> 1  -2.68  0.319  0.0279     | 1 score            3.5 setosa  #> 2  -2.71 -0.177  0.210      | 2 score            3   setosa  #> 3  -2.89 -0.145 -0.0179 ... | 3 score            3.2 setosa  #> 4  -2.75 -0.318 -0.0316     | 4 score            3.1 setosa  #> 5  -2.73  0.327 -0.0901     | 5 score            3.6 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 4 ] #>    Comp.1  Comp.2  Comp.3 ... |   name         center scale .element #>                               |   <chr>         <dbl> <dbl> <chr>    #> 1  0.361   0.657   0.582      | 1 Sepal.Length   5.84     1 active   #> 2 -0.0845  0.730  -0.598  ... | 2 Sepal.Width    3.06     1 active   #> 3  0.857  -0.173  -0.0762     | 3 Petal.Length   3.76     1 active   #> 4  0.358  -0.0755 -0.546      | 4 Petal.Width    1.20     1 active   ordinate(iris, cols = 1:4, ~ prcomp(., center = TRUE, scale. = TRUE)) #> # A tbl_ord of class 'prcomp': (150 x 4) x (4 x 4)' #> # 4 coordinates: PC1, PC2, ..., PC4 #> #  #> # Rows (principal): [ 150 x 4 | 1 ] #>     PC1    PC2     PC3 ... |   Species #>                            |   <fct>   #> 1 -2.26 -0.478  0.127      | 1 setosa  #> 2 -2.07  0.672  0.234      | 2 setosa  #> 3 -2.36  0.341 -0.0441 ... | 3 setosa  #> 4 -2.29  0.595 -0.0910     | 4 setosa  #> 5 -2.38 -0.645 -0.0157     | 5 setosa  #> # ℹ 145 more rows     | # ℹ 145 more rows #>  #> #  #> # Columns (standard): [ 4 x 4 | 3 ] #>      PC1     PC2    PC3 ... |   name         center scale #>                             |   <chr>         <dbl> <dbl> #> 1  0.521 -0.377   0.720     | 1 Sepal.Length   5.84 0.828 #> 2 -0.269 -0.923  -0.244 ... | 2 Sepal.Width    3.06 0.436 #> 3  0.580 -0.0245 -0.142     | 3 Petal.Length   3.76 1.77  #> 4  0.565 -0.0669 -0.634     | 4 Petal.Width    1.20 0.762  # CA of hair & eye color data haireye <- as.data.frame(rowSums(HairEyeColor, dims = 2L)) ordinate(haireye, MASS::corresp, cols = everything()) #> # A tbl_ord of class 'correspondence': (4 x 1) x (4 x 1)' #> # 1 coordinate: Can1 #> #  #> # Rows (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.10  | 1 Black #> 2 -0.324 | 2 Brown #> 3 -0.283 | 3 Red   #> 4  1.83  | 4 Blond #> #  #> # Columns (standard): [ 4 x 1 | 1 ] #>     Can1 |   name  #>          |   <chr> #> 1 -1.08  | 1 Brown #> 2  1.20  | 2 Blue  #> 3 -0.465 | 3 Hazel #> 4  0.354 | 4 Green  # FA of Swiss social data ordinate(swiss, model = factanal, factors = 2L, scores = \"Bartlett\") #> # A tbl_ord of class 'factanal': (47 x 2) x (6 x 2)' #> # 2 coordinates: Factor1 and Factor2 #> #  #> # Rows (principal): [ 47 x 2 | 2 ] #>   Factor1 Factor2 |   .element name         #>                   |   <chr>    <chr>        #> 1  0.0775  -0.673 | 1 score    Courtelary   #> 2 -0.177    1.14  | 2 score    Delemont     #> 3 -0.587    1.27  | 3 score    Franches-Mnt #> 4 -0.427   -0.169 | 4 score    Moutier      #> 5  0.382   -0.708 | 5 score    Neuveville   #> # ℹ 42 more rows | # ℹ 42 more rows #>  #> #  #> # Columns (principal): [ 6 x 2 | 3 ] #>   Factor1 Factor2 |   name           uniqueness .element #>                   |   <chr>               <dbl> <chr>    #> 1 -0.652   0.393  | 1 Fertility          0.420  active   #> 2 -0.631   0.333  | 2 Agriculture        0.492  active   #> 3  0.685  -0.510  | 3 Examination        0.270  active   #> 4  0.997  -0.0313 | 4 Education          0.005  active   #> 5 -0.124   0.961  | 5 Catholic           0.0607 active   #> 6 -0.0947  0.175  | 6 Infant.Mortal…     0.960  active    # LDA of iris data ordinate(iris, ~ lda_ord(.[, 1:4], .[, 5])) #> # A tbl_ord of class 'lda_ord': (153 x 2) x (4 x 2)' #> # 2 coordinates: LD1 and LD2 #> #  #> # Rows (principal): [ 153 x 2 | 5 ] #>     LD1    LD2 |   name        prior counts grouping  #>                |   <chr>       <dbl>  <int> <chr>     #> 1  7.61 -0.215 | 1 setosa      0.333     50 setosa    #> 2 -1.83  0.728 | 2 versicolor  0.333     50 versicol… #> 3 -5.78 -0.513 | 3 virginica   0.333     50 virginica #> 4  8.06 -0.300 | 4 NA         NA         NA setosa    #> 5  7.13  0.787 | 5 NA         NA         NA setosa    #> # ℹ 148 more rows | # ℹ 148 more rows #> # ℹ 1 more variable: .element <chr> #> #  #> # Columns (standard): [ 4 x 2 | 2 ] #>      LD1     LD2 |   name         .element #>                  |   <chr>        <chr>    #> 1  0.829 -0.0241 | 1 Sepal.Length active   #> 2  1.53  -2.16   | 2 Sepal.Width  active   #> 3 -2.20   0.932  | 3 Petal.Length active   #> 4 -2.81  -2.84   | 4 Petal.Width  active    # CCA of savings data ordinate(   LifeCycleSavings[, c(\"pop15\", \"pop75\")],   # second data set must be handled as an additional parameter to `model`   y = LifeCycleSavings[, c(\"sr\", \"dpi\", \"ddpi\")],   model = cancor_ord, scores = TRUE ) #> # A tbl_ord of class 'cancor_ord': (54 x 2) x (56 x 2)' #> # 2 coordinates: CanCor1 and CanCor2 #> #  #> # Rows (standard): [ 54 x 2 | 3 ] #>    CanCor1 CanCor2 |   name      center .element #>                    |   <chr>      <dbl> <chr>    #> 1 -0.00911 -0.0362 | 1 pop15      35.1  active   #> 2  0.0486  -0.260  | 2 pop75       2.29 active   #> 3  0.0804   0.0577 | 3 Australia  NA    score    #> 4  0.210   -0.125  | 4 Austria    NA    score    #> 5  0.207   -0.147  | 5 Belgium    NA    score    #> # ℹ 49 more rows | # ℹ 49 more rows #>  #> #  #> # Columns (standard): [ 56 x 2 | 3 ] #>    CanCor1    CanCor2 |   name       center .element #>                       |   <chr>       <dbl> <chr>    #> 1 0.00847   0.0334    | 1 sr           9.67 active   #> 2 0.000131 -0.0000759 | 2 dpi       1107.   active   #> 3 0.00417  -0.0123    | 3 ddpi         3.76 active   #> 4 0.171    -0.0232    | 4 Australia   NA    score    #> 5 0.0735    0.0475    | 5 Austria     NA    score    #> # ℹ 51 more rows | # ℹ 51 more rows #>"},{"path":"/reference/ordr-ggproto.html","id":null,"dir":"Reference","previous_headings":"","what":"ggproto classes created and adapted for ordr — ordr-ggproto","title":"ggproto classes created and adapted for ordr — ordr-ggproto","text":"addition geometric element layers (geoms) based base-ggplot2 layers like geom_point() specified matrix factors geom_row_point(), ordr introduces ggproto classes additional geometric elements commonly used biplots. factor-specific geoms invoke statistical transformation layers (stats) stat_rows() stat_cols(), specify matrix factor. ggplot layer consists one stat one geom, necessitates ggproto classes new stats must also come *Rows *Cols flavors.","code":""},{"path":[]},{"path":"/reference/ordr.html","id":null,"dir":"Reference","previous_headings":"","what":"ordr package — ordr","title":"ordr package — ordr","text":"tidyverse extension handling, manipulating, visualizing ordination models consistent conventions tidy workflow.","code":""},{"path":"/reference/ordr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ordr package — ordr","text":"package designed integrate ordination analysis biplot visualization tidyverse workflow. inspired particular extensions ggbiplot tidygraph. package consists several modules: 'tbl_ord' class, wrapper various ordination object classes extracting augmentation factors ordination using dplyr-verbs add annotation factors adjusting conference inertia factors methods generics several widely-used object classes convenient formatting ordination objects ggbiplot(), ggplot2 extension rendering biplots additional stats geoms biplots","code":""},{"path":"/reference/ordr.html","id":"ordinations-and-biplots","dir":"Reference","previous_headings":"","what":"Ordinations and biplots","title":"ordr package — ordr","text":"Ordination encompasses variety techniques data compression, dimension reduction, feature extraction, visualization. Well-known ordination techniques predominantly unsupervised include principal components analysis, multidimensional scaling, correspondence analyis (Podani, 2000, Chapter 7; Palmer, n.d.). methods theoretically grounded geometric data analysis (Le Roux & Rouanet, 2004) powered matrix factorizations described . variety techniques may also viewed, treated using tools, ordination, including linear regression, linear discriminant analysis, k-means clustering, non-negative matrix factorization. Biplots two-layered scatterplots widely used visualize unsupervised SVD-based ordinations. Gabriel (1971) introduced biplots represent scores loadings PCA single set axes. also used visualize generalized linear regression linear discriminant analysis (Greenacre, 2010) can adapted 2-factor matrix decomposition.","code":""},{"path":"/reference/ordr.html","id":"singular-value-decomposition","dir":"Reference","previous_headings":"","what":"Singular value decomposition","title":"ordr package — ordr","text":"popular ordination techniques use singular value decomposition (SVD) factor data matrix \\(X\\) product \\(X=UDV'\\) two orthogonal (rotation) matrices \\(U\\) \\(V\\) diagonal (scaling) matrix \\(D\\), \\(V'\\) transpose \\(V\\). cases, data matrix \\(X\\) transformed original data matrix, e.g. centering, scaling, double-centering, log-transforming. SVD introduces set shared orthogonal coordinates \\(U\\) encodes rows \\(X\\) \\(V\\) encodes columns \\(X\\). singular values \\(D\\) variances \\(X\\) along coordinates, proceed decreasing order, first \\(r\\) (\"rank\") columns \\(U\\) \\(V\\) produce geometrically optimized approximation \\(X\\). Biplots SVD-based ordinations usually plot rows columns \\(X\\) \\(r\\) coordinate axes. SVD-based biplot truly geometric, total variance contained \\(D\\) must conferred onto \\(U\\) \\(V\\), distributed (Orlov, 2015). \\(D\\) conferred onto \\(U\\), rows \\(X\\) represented rows \\(UD\\), distances biplot approximate distances original column space \\(X\\). Meanwhile, columns \\(X\\) represented rows \\(V\\). unit vectors full space shared coordinates, squared lengths biplot indicate proportion variance captured biplot axes cosines approximate correlations columns. Finally, projection row's coordinates (point) onto column's coordinates (vector) approximates corresponding entry \\(X\\).","code":""},{"path":"/reference/ordr.html","id":"acknowledgments","dir":"Reference","previous_headings":"","what":"Acknowledgments","title":"ordr package — ordr","text":"Many users identified problems suggested improvements. Development benefitted use equipment support colleagues UConn Health UF Health.","code":""},{"path":"/reference/ordr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ordr package — ordr","text":"Podani J (2000) \"Ordination\". Introduction Exploration Multivariate Biological Data Chapter 7, 215–284. Backhuys Publishers, ISBN 90-5782-067-6. https://web.archive.org/web/20200221000313/http://ramet.elte.hu/~podani/books.html Palmer M Ordination Methods Ecologists. Website, accessed 2019-07-12. https://ordination.okstate.edu/ Le Roux B & Rouanet H (2004) Geometric Data Analysis: Correspondence Analysis Stsructured Data Analysis. Springer Dordrecht, ISBN: 978-1-4020-2236-4. doi:10.1007/1-4020-2236-0  https://link.springer.com/book/10.1007/1-4020-2236-0 Gabriel KR (1971) \"biplot graphic display matrices application principal component analysis\". Biometrika 58(3), 453–467. doi:10.1093/biomet/58.3.453 Greenacre MJ (2010) Biplots Practice. Fundacion BBVA, ISBN: 978-84-923846. https://www.fbbva.es/microsite/multivariate-statistics/biplots.html Orlov K (2015) Answer \"PCA Correspondence analysis relation Biplot\". CrossValidated, accessed 2019-07-12. https://stats.stackexchange.com//141755/68743","code":""},{"path":[]},{"path":"/reference/ordr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ordr package — ordr","text":"Maintainer: Jason Cory Brunson cornelioid@gmail.com (ORCID) Authors: John Gracey jbgracey6@gmail.com contributors: Emily Paul erpb.71@gmail.com [contributor]","code":""},{"path":"/reference/plot.tbl_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"Adapt stats 'prcomp' 'princomp' methods plot(), screeplot(), biplot() generics 'tbl_ord' objects.","code":""},{"path":"/reference/plot.tbl_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"","code":"# S3 method for class 'tbl_ord' plot(x, main = deparse(substitute(x)), ...)  # S3 method for class 'tbl_ord' screeplot(x, main = deparse(substitute(x)), ...)  # S3 method for class 'tbl_ord' biplot(x, main = deparse(substitute(x)), ...)"},{"path":"/reference/plot.tbl_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"x 'tbl_ord' object. main main title plot, passed methods (included enable parsing object name). ... Additional arguments passed methods.","code":""},{"path":"/reference/plot.tbl_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"Nothing, plot produced current graphics device.","code":""},{"path":"/reference/plot.tbl_ord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"methods defer plot() biplot() methods original, underlying model classes 'tbl_ord' objects. none found: Following examples stats::plot.prcomp() stats::plot.princomp(), plot.tbl_ord() calls stats::screeplot() produce scree plot decomposition variance singular value decomposition. Similarly following stats::biplot.prcomp() stats::biplot.princomp(), biplot.tbl_ord() produces biplot rows columns, using text labels available markers otherwise, rows columns distinguished color additional annotation (e.g. vectors). biplot confers inertia according get_conference() unless proportions sum 1, case produces symmetric biplot (inertia conferred equally rows columns).","code":""},{"path":"/reference/plot.tbl_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot and biplot methods for 'tbl_ord' objects — plot.tbl_ord","text":"","code":"# note: behavior depends on installed packages with class-specific methods  # class 'prcomp' iris_pca <- prcomp(iris[, -5L], scale = TRUE) iris_pca_ord <- as_tbl_ord(iris_pca) plot(iris_pca)  plot(iris_pca_ord)  screeplot(iris_pca)  screeplot(iris_pca_ord)  biplot(iris_pca)  biplot(iris_pca_ord)   # class 'correspondence' haireye_ca <- MASS::corresp(rowSums(HairEyeColor, dims = 2L), nf = 2L) haireye_ca_ord <- as_tbl_ord(haireye_ca) plot(haireye_ca)  plot(haireye_ca_ord)  # no `screeplot()` method for class 'correspondence' screeplot(haireye_ca_ord)  biplot(haireye_ca)  biplot(haireye_ca_ord)"},{"path":"/reference/qswur_usa.html","id":null,"dir":"Reference","previous_headings":"","what":"U.S. university rankings — qswur_usa","title":"U.S. university rankings — qswur_usa","text":"Classifications rankings U.S. universities years 2017–2020.","code":""},{"path":"/reference/qswur_usa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"U.S. university rankings — qswur_usa","text":"","code":"data(qswur_usa)"},{"path":"/reference/qswur_usa.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"U.S. university rankings — qswur_usa","text":"tibble 13 variables 612 cases: year year rankings institution institution higher learning size size category institution focus subject range institution res research intensity institution age age classification institution status status institution rk_academic rank academic reputation rk_employer rank employer reputation rk_ratio rank faculty–student ratio rk_citations rank citations per faculty rk_intl_faculty rank international faculty ratio rk_intl_students rank international student ratio","code":""},{"path":"/reference/qswur_usa.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"U.S. university rankings — qswur_usa","text":"Quacquarelli Symonds (2021).","code":""},{"path":"/reference/qswur_usa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"U.S. university rankings — qswur_usa","text":"Ranking data obtained public QS website.","code":""},{"path":"/reference/qswur_usa.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"U.S. university rankings — qswur_usa","text":"Quacquarelli Symonds (2021) \"University Rankings\". TopUniversities.com https://www.topuniversities.com/university-rankings.","code":""},{"path":"/reference/qswur_usa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"U.S. university rankings — qswur_usa","text":"","code":"# subset QS data to rank variables head(qswur_usa) #> # A tibble: 6 × 13 #>    year institution       size  focus res     age status rk_academic rk_employer #>   <int> <chr>             <fct> <fct> <fct> <int> <chr>        <int>       <int> #> 1  2017 MASSACHUSETTS IN… M     CO    VH        5 B                6           4 #> 2  2017 STANFORD UNIVERS… L     FC    VH        5 A                5           5 #> 3  2017 HARVARD UNIVERSI… L     FC    VH        5 B                1           1 #> 4  2017 CALIFORNIA INSTI… S     CO    VH        5 B               23          90 #> 5  2017 UNIVERSITY OF CH… L     FC    VH        5 B               13          47 #> 6  2017 PRINCETON UNIVER… M     CO    VH        5 B               10          32 #> # ℹ 4 more variables: rk_ratio <int>, rk_citations <int>, #> #   rk_intl_faculty <int>, rk_intl_students <int> qs_ranks <- subset(   qswur_usa,   complete.cases(qswur_usa),   select = 8:13 ) # calculate Kendall correlation matrix qs_cor <- cor(qs_ranks, method = \"kendall\")  # calculate eigendecomposition qs_eigen <- eigen_ord(qs_cor) # view correlations as cosines of biplot vectors biplot(x = qs_eigen$vectors, y = qs_eigen$vectors, col = c(NA, \"black\"))"},{"path":"/reference/recoverers.html","id":null,"dir":"Reference","previous_headings":"","what":"Access factors, coordinates, and metadata from ordination objects — recoverers","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"functions return information matrix factorization underlying ordination.","code":""},{"path":"/reference/recoverers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"","code":"recover_rows(x)  recover_cols(x)  # Default S3 method recover_rows(x)  # Default S3 method recover_cols(x)  # S3 method for class 'data.frame' recover_rows(x)  # S3 method for class 'data.frame' recover_cols(x)  get_rows(x, elements = \"all\")  get_cols(x, elements = \"all\")  # S3 method for class 'tbl_ord' as.matrix(x, ..., .matrix, elements = \"all\")  recover_inertia(x)  # Default S3 method recover_inertia(x)  recover_coord(x)  # Default S3 method recover_coord(x)  # S3 method for class 'data.frame' recover_coord(x)  get_coord(x)  get_inertia(x)  # S3 method for class 'tbl_ord' dim(x)"},{"path":"/reference/recoverers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"x object class 'tbl_ord'. elements Character vector; elements factor render graphical elements. One \"\" (default), \"active\", supplementary element type defined specific class methods (e.g. \"score\" 'factanal', 'lda_ord', 'cancord_ord' \"intraset\" \"interset\" 'cancor_ord'). ... Additional arguments base::.matrix(); ignored. .matrix character string partially matched (lowercase) several indicators one matrices matrix decomposition used ordination. standard values \"rows\", \"cols\", \"dims\" ().","code":""},{"path":"/reference/recoverers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"recover_*() functions generics whose methods return base R objects retrieved model wrapped 'tbl_ord' class: rows: row matrix stored model cols: column matrix stored model inertia: vector eigen-values squared singular values, often known names depending model coord: names artificial axes, model available get_*() functions (generics) return modifications objects: rows: recovered rows, adjusted according negation axes conference inertia cols: recovered columns, adjusted according negation axes conference inertia inertia: recovered inertia, named recovered coordinates coord: recovered coordinates (unmodified) dim() returns dimensions decomposed matrix, .e. numbers rows recover_rows() recover_cols().","code":""},{"path":"/reference/recoverers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"recover_*() S3 methods extract one row column matrix factors constitute original ordination. interpreted case scores (rows) variable loadings (columns). get_*() functions optionally (default) include supplemental observations (see supplementation). recover_*() functions generics require methods ordination class. intended called directly exported users can query methods(\"recover_*\"). get_coord() retrieves names coordinates shared matrix factors original data ordinated, get_inertia() retrieves vector inertia names. dim() retrieves dimensions row column factors, reflect dimensions matrix reconstruct—original data matrix. (matters techniques rely eigendecomposition, decomposed matrix square.)","code":""},{"path":[]},{"path":"/reference/recoverers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access factors, coordinates, and metadata from ordination objects — recoverers","text":"","code":"# example ordination: LRA of U.S. arrests data arrests_lra <- ordinate(USArrests, cols = c(Murder, Rape, Assault), lra)  # extract matrix factors as.matrix(arrests_lra, .matrix = \"rows\") #>                      LRSV1        LRSV2 #> Alabama        -0.68001198  0.929601139 #> Alaska          0.92998988 -0.624577164 #> Arizona        -0.32984955 -1.311581695 #> Arkansas       -0.35134428  0.277323143 #> California      0.55165901 -1.004280086 #> Colorado        1.22910659 -0.638846890 #> Connecticut    -0.43610804 -1.027017532 #> Delaware       -1.54269183 -1.349322890 #> Florida        -0.54682514  0.300298438 #> Georgia         0.15812112  1.916932033 #> Hawaii          3.51365819  2.150284964 #> Idaho          -0.05250833 -2.109188891 #> Illinois       -0.52429773  0.002652531 #> Indiana         1.22231804  0.881075829 #> Iowa            1.39095549 -0.632985189 #> Kansas          0.75715595  0.380674137 #> Kentucky        0.68864901  2.024832534 #> Louisiana      -0.69015525  1.238509473 #> Maine          -0.63716612 -1.499305459 #> Maryland       -0.63629812 -0.286175559 #> Massachusetts  -0.22762978 -1.124006923 #> Michigan        0.41414730  0.171745261 #> Minnesota       1.45222388 -0.789191960 #> Mississippi    -1.47068651  1.436924829 #> Missouri        0.78566710  0.278289912 #> Montana         0.65946921  0.566956397 #> Nebraska        0.82281297 -0.284750183 #> Nevada          1.14994121  0.060475841 #> New Hampshire   0.88778358 -0.710870888 #> New Jersey      0.01717089  0.205735676 #> New Mexico     -0.12336523 -0.223126918 #> New York       -0.35365080  0.100656157 #> North Carolina -2.35659680  0.189728037 #> North Dakota    0.74912231 -2.900272794 #> Ohio            1.11076020  0.766013515 #> Oklahoma        0.30637650 -0.053491161 #> Oregon          1.13217636 -1.312593507 #> Pennsylvania    0.48983869  0.840580871 #> Rhode Island   -2.42442178 -1.868251942 #> South Carolina -0.96800438  0.752042083 #> South Dakota    0.61067278 -0.091684230 #> Tennessee       0.55166149  1.334277800 #> Texas           0.22895595  1.088292623 #> Utah            1.20949943 -1.771844197 #> Vermont         1.78310111 -0.254863377 #> Virginia        0.33180838  0.612645656 #> Washington      1.07067103 -1.635935144 #> West Virginia  -0.02043499  1.475198849 #> Wisconsin       1.43728882  0.033416687 #> Wyoming        -0.50955934  0.033243165 as.matrix(arrests_lra, .matrix = \"cols\") #>             LRSV1      LRSV2 #> Murder   0.283086  4.9570302 #> Rape     2.876702 -0.3660163 #> Assault -0.370595 -0.1805698 # special named functions get_rows(arrests_lra) #>                      LRSV1        LRSV2 #> Alabama        -0.68001198  0.929601139 #> Alaska          0.92998988 -0.624577164 #> Arizona        -0.32984955 -1.311581695 #> Arkansas       -0.35134428  0.277323143 #> California      0.55165901 -1.004280086 #> Colorado        1.22910659 -0.638846890 #> Connecticut    -0.43610804 -1.027017532 #> Delaware       -1.54269183 -1.349322890 #> Florida        -0.54682514  0.300298438 #> Georgia         0.15812112  1.916932033 #> Hawaii          3.51365819  2.150284964 #> Idaho          -0.05250833 -2.109188891 #> Illinois       -0.52429773  0.002652531 #> Indiana         1.22231804  0.881075829 #> Iowa            1.39095549 -0.632985189 #> Kansas          0.75715595  0.380674137 #> Kentucky        0.68864901  2.024832534 #> Louisiana      -0.69015525  1.238509473 #> Maine          -0.63716612 -1.499305459 #> Maryland       -0.63629812 -0.286175559 #> Massachusetts  -0.22762978 -1.124006923 #> Michigan        0.41414730  0.171745261 #> Minnesota       1.45222388 -0.789191960 #> Mississippi    -1.47068651  1.436924829 #> Missouri        0.78566710  0.278289912 #> Montana         0.65946921  0.566956397 #> Nebraska        0.82281297 -0.284750183 #> Nevada          1.14994121  0.060475841 #> New Hampshire   0.88778358 -0.710870888 #> New Jersey      0.01717089  0.205735676 #> New Mexico     -0.12336523 -0.223126918 #> New York       -0.35365080  0.100656157 #> North Carolina -2.35659680  0.189728037 #> North Dakota    0.74912231 -2.900272794 #> Ohio            1.11076020  0.766013515 #> Oklahoma        0.30637650 -0.053491161 #> Oregon          1.13217636 -1.312593507 #> Pennsylvania    0.48983869  0.840580871 #> Rhode Island   -2.42442178 -1.868251942 #> South Carolina -0.96800438  0.752042083 #> South Dakota    0.61067278 -0.091684230 #> Tennessee       0.55166149  1.334277800 #> Texas           0.22895595  1.088292623 #> Utah            1.20949943 -1.771844197 #> Vermont         1.78310111 -0.254863377 #> Virginia        0.33180838  0.612645656 #> Washington      1.07067103 -1.635935144 #> West Virginia  -0.02043499  1.475198849 #> Wisconsin       1.43728882  0.033416687 #> Wyoming        -0.50955934  0.033243165 get_cols(arrests_lra) #>             LRSV1      LRSV2 #> Murder   0.283086  4.9570302 #> Rape     2.876702 -0.3660163 #> Assault -0.370595 -0.1805698 # get dimensions of underlying matrix factorization (not of original data) dim(arrests_lra) #> [1] 50  3  # get names of artificial / latent coordinates get_coord(arrests_lra) #> [1] \"LRSV1\" \"LRSV2\" # get distribution of inertia get_inertia(arrests_lra) #>       LRSV1       LRSV2  #> 0.013826903 0.004074913"},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics glance, tidy gggda geom_axis, geom_bagplot, geom_isoline, geom_lineranges, geom_pointranges, geom_rule, geom_text_radiate, geom_vector, maxpp, minabspp, minpp, stat_bagplot, stat_center, stat_chull, stat_cone, stat_depth, stat_depth_filled, stat_peel, stat_rule, stat_scale, stat_spantree, stat_star ggrepel geom_label_repel, geom_text_repel, position_nudge_repel magrittr %>%","code":""},{"path":"/reference/stat_projection.html","id":null,"dir":"Reference","previous_headings":"","what":"Project rows onto columns or vice-versa — stat_projection","title":"Project rows onto columns or vice-versa — stat_projection","text":"Compute projections vectors one matrix factor onto .","code":""},{"path":"/reference/stat_projection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project rows onto columns or vice-versa — stat_projection","text":"","code":"stat_projection(   mapping = NULL,   data = NULL,   geom = \"segment\",   position = \"identity\",   referent = NULL,   ...,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/stat_projection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project rows onto columns or vice-versa — stat_projection","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. referent reference data set; see Details. ... Additional arguments passed ggplot2::layer(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders().","code":""},{"path":"/reference/stat_projection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project rows onto columns or vice-versa — stat_projection","text":"ggproto layer.","code":""},{"path":"/reference/stat_projection.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project rows onto columns or vice-versa — stat_projection","text":"ordination model continuous data can used predict values along one dimension along , using artificial axes intermediaries. predictions correspond geometrically projections elements one matrix factor principal coordinates onto factor standard coordinates. familiar setting PCA biplots, variable (column) values predicted case (row) locations along PC1 PC2. transformation obtains axis projections xend,yend pairs original points x,y demarcate segments visualizing projections. WARNING: layer appropriate axes standard coordinates (usually confer_inertia(p = \"rows\")) predictive calibration (ggbiplot(axis.type = \"predictive\")).","code":""},{"path":"/reference/stat_projection.html","id":"referential-stats","dir":"Reference","previous_headings":"","what":"Referential stats","title":"Project rows onto columns or vice-versa — stat_projection","text":"statistical transformation done respect reference data passed referent (ignored NULL, default, possibly resulting empty output). See gggda::stat_referent() details. relies sleight hand new undocumented LayerRef class associated ggplot2::ggplot_add() method. result, layers constructed using stat_*() shortcut pass necessary positional aesthetics $setup_params() step, making available pre-process referent data. biplot shortcuts automatically substitute complementary matrix factor referent = NULL use integer vector select subset factor. uses require mapping passage.","code":""},{"path":"/reference/stat_projection.html","id":"biplot-layers","dir":"Reference","previous_headings":"","what":"Biplot layers","title":"Project rows onto columns or vice-versa — stat_projection","text":"ggbiplot() uses ggplot2::fortify() internally produce single data frame .matrix column distinguishing subjects (\"rows\") variables (\"cols\"). stat layers stat_rows() stat_cols() simply filter data frame one two. geom layers geom_rows_*() geom_cols_*() call corresponding stat order render plot elements corresponding factor matrix. geom_dims_*() selects default matrix based common practice, e.g. points rows arrows columns.","code":""},{"path":"/reference/stat_projection.html","id":"ordination-aesthetics","dir":"Reference","previous_headings":"","what":"Ordination aesthetics","title":"Project rows onto columns or vice-versa — stat_projection","text":"statistical transformation compatible convenience function ord_aes(). transformations (e.g. stat_center()) commute projection lower (1 2)-dimensional biplot space. detect aesthetics form ..coord[0-9]+, ..coord1 ..coord2 converted x y remaining ignored. transformations (e.g. stat_spantree()) yield different results lower-dimensional biplot computed versus projection. stat layer detects aesthetics, transformation performed projection, results first two dimensions returned x y. small number transformations (stat_rule()) incompatible ordination aesthetics accept ord_aes() without warning.","code":""},{"path":"/reference/stat_projection.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed variables","title":"Project rows onto columns or vice-versa — stat_projection","text":"calculated statistical transformation can accessed delayed evaluation. xend,yend projections onto (specified) vectors","code":""},{"path":"/reference/stat_projection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project rows onto columns or vice-versa — stat_projection","text":"","code":"# simplify the Motor Trends data to two predictors legible at aspect ratio 1 mtcars %>%   transform(hp00 = hp/100) %>%   subset(select = c(mpg, hp00, wt)) ->   subcars # compute the gradient of `mpg` against these two predictors lm(mpg ~ hp00 + wt, subcars) %>%   coefficients() %>%   as.list() %>% as.data.frame() ->   grad # project the data onto the gradient axis (with a reversed gradient vector) ggplot(subcars, aes(x = hp00, y = wt)) +   coord_equal() +   geom_point(shape = \"circle open\") +   geom_vector(data = -grad) +   stat_projection(referent = grad)"},{"path":"/reference/stat_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Render plot elements for one matrix of an ordination — stat_rows","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"stats merely tell ggplot2::ggplot() factor ordination pull data plot layer. invoked internally various geom_*_*() layers.","code":""},{"path":"/reference/stat_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"","code":"stat_rows(   mapping = NULL,   data = data,   geom = \"point\",   position = \"identity\",   subset = NULL,   elements = \"active\",   ...,   show.legend = NA,   inherit.aes = TRUE )  stat_cols(   mapping = NULL,   data = data,   geom = \"axis\",   position = \"identity\",   subset = NULL,   elements = \"active\",   ...,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/stat_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. subset integer, logical, character vector indicating subset rows columns render graphical elements. NB: Internally, subset taken rows fortified 'tbl_ord' comprising rows one matrix factors. still possible pass formula data parameter, act fortified data restricted one matrix factor. elements Character vector; elements factor render graphical elements. One \"\" (default), \"active\", supplementary element type defined specific class methods (e.g. \"score\" 'factanal', 'lda_ord', 'cancord_ord' \"intraset\" \"interset\" 'cancor_ord'). ... Additional arguments passed ggplot2::layer(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders().","code":""},{"path":"/reference/stat_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"ggproto layer.","code":""},{"path":"/reference/stat_rows.html","id":"biplot-layers","dir":"Reference","previous_headings":"","what":"Biplot layers","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"ggbiplot() uses ggplot2::fortify() internally produce single data frame .matrix column distinguishing subjects (\"rows\") variables (\"cols\"). stat layers stat_rows() stat_cols() simply filter data frame one two. geom layers geom_rows_*() geom_cols_*() call corresponding stat order render plot elements corresponding factor matrix. geom_dims_*() selects default matrix based common practice, e.g. points rows arrows columns.","code":""},{"path":[]},{"path":"/reference/stat_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render plot elements for one matrix of an ordination — stat_rows","text":"","code":"# FA of Swiss social data swiss_fa <-   ordinate(swiss, model = factanal, factors = 2L, scores = \"regression\") # active and supplementary elements get_rows(swiss_fa, elements = \"active\") #>      Factor1 Factor2 head(get_rows(swiss_fa, elements = \"score\")) #>                  Factor1    Factor2 #> Courtelary    0.07912746 -0.6344915 #> Delemont     -0.17926953  1.0783941 #> Franches-Mnt -0.58784929  1.2004233 #> Moutier      -0.42433417 -0.1583409 #> Neuveville    0.38211185 -0.6682790 #> Porrentruy   -0.37286722  1.0884740  # biplot using element filters and selection # (note that filter precedes selection) ggbiplot(swiss_fa) +   geom_rows_point(elements = \"score\") +   geom_rows_label(aes(label = name), elements = \"score\", subset = c(1, 4, 18)) +   scale_alpha_manual(values = c(0, 1), guide = \"none\") +   geom_cols_vector(aes(label = name))"},{"path":"/reference/supplementation.html","id":null,"dir":"Reference","previous_headings":"","what":"Supplement 'tbl_ord' objects with new data — supplementation","title":"Supplement 'tbl_ord' objects with new data — supplementation","text":"functions attach supplementary rows columns ordination object.","code":""},{"path":"/reference/supplementation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supplement 'tbl_ord' objects with new data — supplementation","text":"","code":"recover_supp_rows(x)  # Default S3 method recover_supp_rows(x)  recover_supp_cols(x)  # Default S3 method recover_supp_cols(x)"},{"path":"/reference/supplementation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supplement 'tbl_ord' objects with new data — supplementation","text":"x object class 'tbl_ord'.","code":""},{"path":"/reference/supplementation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supplement 'tbl_ord' objects with new data — supplementation","text":"Matrices numbers columns returned recover_rows() recover_cols(), else NULL.","code":""},{"path":"/reference/supplementation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supplement 'tbl_ord' objects with new data — supplementation","text":"recover_supp_*() S3 methods produce matrices supplemental rows columns tbl_ord object object . motivating example linear discriminant analysis, produces natural biplot class discriminant centroids variable axes usually supplemented case discriminant scores. supplementary values augmented .element column whose value indicates source can incorporated tidied form. supplementary rows factor produced, functions return NULL.","code":""},{"path":[]},{"path":"/reference/sync.html","id":null,"dir":"Reference","previous_headings":"","what":"A synchronization flag. — sync","title":"A synchronization flag. — sync","text":"inert function sync() operates analogously ggplot2::waiver() indicate auxiliary aesthetic synchronized standard aesthetic (mapped data). .sync() reports whether object class.","code":""},{"path":"/reference/sync.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synchronization flag. — sync","text":"","code":"sync()  is.sync(x)"},{"path":"/reference/sync.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A synchronization flag. — sync","text":"x object test","code":""},{"path":"/reference/tbl_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"A unified ordination object class — tbl_ord","title":"A unified ordination object class — tbl_ord","text":"functions wrap ordination objects class tbl_ord, create tbl_ords directly matrices, test class basic structure.","code":""},{"path":"/reference/tbl_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A unified ordination object class — tbl_ord","text":"","code":"as_tbl_ord(x)  # S3 method for class 'tbl_ord' as_tbl_ord(x)  make_tbl_ord(rows = NULL, cols = NULL, ...)  is_tbl_ord(x)  is.tbl_ord(x)  valid_tbl_ord(x)  un_tbl_ord(x)"},{"path":"/reference/tbl_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A unified ordination object class — tbl_ord","text":"x ordination object. rows, cols Matrices used factors tbl_ord. ... Additional elements custom tbl_ord.","code":""},{"path":"/reference/tbl_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A unified ordination object class — tbl_ord","text":"tbl_ord (*(), make*()), S3-class model object can wrapped one (un*()), logical value (*(), value*()).","code":""},{"path":"/reference/tbl_ord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A unified ordination object class — tbl_ord","text":"tbl_ord class wraps around range ordination classes, making available suite ordination tools specialize original object class. tools include format() ggplot2::fortify() methods, facilitate print() method ggbiplot() function. default method provided as_tbl_ord(), despite defined methods equivalent (simply appending 'tbl_ord' vector object classes). prevents objects methods defined re-classed tbl_ords. function make_tbl_ord() creates tbl_ord structured list two matrices, u v, must number columns column names. is_tbl_ord() checks object x tbl_ord class; valid_tbl_ord() additionally checks consistency recover_coord(x) columns recover_rows(x) recover_cols(x), using recoverers. un_tbl_ord() removes attributes associated tbl_ord class order restore object originally passed as_tbl_ord.","code":""},{"path":"/reference/tbl_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A unified ordination object class — tbl_ord","text":"","code":"# illustrative ordination: FA of Swiss social data swiss_fa <- factanal(swiss, factors = 3L, scores = \"regression\") print(swiss_fa) #>  #> Call: #> factanal(x = swiss, factors = 3L, scores = \"regression\") #>  #> Uniquenesses: #>        Fertility      Agriculture      Examination        Education  #>            0.005            0.286            0.213            0.114  #>         Catholic Infant.Mortality  #>            0.083            0.743  #>  #> Loadings: #>                  Factor1 Factor2 Factor3 #> Fertility        -0.512   0.203   0.832  #> Agriculture      -0.774   0.312  -0.129  #> Examination       0.751  -0.423  -0.211  #> Education         0.901          -0.262  #> Catholic         -0.186   0.913   0.220  #> Infant.Mortality                  0.500  #>  #>                Factor1 Factor2 Factor3 #> SS loadings      2.273   1.164   1.120 #> Proportion Var   0.379   0.194   0.187 #> Cumulative Var   0.379   0.573   0.759 #>  #> The degrees of freedom for the model is 0 and the fit was 1e-04   # add the 'tbl_ord' wrapper swiss_fa_ord <- as_tbl_ord(swiss_fa) # inspect wrapped model is_tbl_ord(swiss_fa_ord) #> [1] TRUE print(swiss_fa_ord) #> # A tbl_ord of class 'factanal': (47 x 3) x (6 x 3)' #> # 3 coordinates: Factor1, Factor2, Factor3 #> #  #> # Rows (principal): [ 47 x 3 | 0 ] #>   Factor1 Factor2 Factor3 |  #>                           |  #> 1   0.453  -0.900   1.46  |  #> 2  -0.143   0.886   0.942 |  #> 3  -0.308   0.848   1.75  |  #> 4  -0.125  -0.463   1.53  |  #> 5   0.341  -0.846   1.05  |  #> # ℹ 42 more rows |  #>  #> #  #> # Columns (principal): [ 6 x 3 | 0 ] #>   Factor1 Factor2 Factor3 |  #>                           |  #> 1 -0.512   0.203    0.832 |  #> 2 -0.774   0.312   -0.129 |  #> 3  0.751  -0.423   -0.211 |  #> 4  0.901   0.0784  -0.262 |  #> 5 -0.186   0.913    0.220 |  #> 6  0.0289  0.0772   0.500 |  valid_tbl_ord(swiss_fa_ord) #> [1] TRUE # unwrap the model un_tbl_ord(swiss_fa_ord) #>  #> Call: #> factanal(x = swiss, factors = 3L, scores = \"regression\") #>  #> Uniquenesses: #>        Fertility      Agriculture      Examination        Education  #>            0.005            0.286            0.213            0.114  #>         Catholic Infant.Mortality  #>            0.083            0.743  #>  #> Loadings: #>                  Factor1 Factor2 Factor3 #> Fertility        -0.512   0.203   0.832  #> Agriculture      -0.774   0.312  -0.129  #> Examination       0.751  -0.423  -0.211  #> Education         0.901          -0.262  #> Catholic         -0.186   0.913   0.220  #> Infant.Mortality                  0.500  #>  #>                Factor1 Factor2 Factor3 #> SS loadings      2.273   1.164   1.120 #> Proportion Var   0.379   0.194   0.187 #> Cumulative Var   0.379   0.573   0.759 #>  #> The degrees of freedom for the model is 0 and the fit was 1e-04   # create a 'tbl_ord' directly from row and column factors # (missing inertia & other attributes) swiss_fa_ord2 <- make_tbl_ord(rows = swiss_fa$scores, cols = swiss_fa$loadings) # inspect wrapped factors is_tbl_ord(swiss_fa_ord2) #> [1] TRUE print(swiss_fa_ord2) #> # A tbl_ord: (47 x 3) x (6 x 3)' #> # 3 coordinates: Factor1, Factor2, Factor3 #> #  #> # Rows: [ 47 x 3 | 0 ] #>   Factor1 Factor2 Factor3 |  #>                           |  #> 1   0.453  -0.900   1.46  |  #> 2  -0.143   0.886   0.942 |  #> 3  -0.308   0.848   1.75  |  #> 4  -0.125  -0.463   1.53  |  #> 5   0.341  -0.846   1.05  |  #> # ℹ 42 more rows |  #>  #> #  #> # Columns: [ 6 x 3 | 0 ] #>   Factor1 Factor2 Factor3 |  #>                           |  #> 1 -0.512   0.203    0.832 |  #> 2 -0.774   0.312   -0.129 |  #> 3  0.751  -0.423   -0.211 |  #> 4  0.901   0.0784  -0.262 |  #> 5 -0.186   0.913    0.220 |  #> 6  0.0289  0.0772   0.500 |  valid_tbl_ord(swiss_fa_ord2) #> [1] TRUE # unwrap factors un_tbl_ord(swiss_fa_ord2) #> $rows #>                  Factor1    Factor2     Factor3 #> Courtelary    0.45318326 -0.8996943  1.45754866 #> Delemont     -0.14322063  0.8855428  0.94227871 #> Franches-Mnt -0.30797336  0.8477030  1.74514043 #> Moutier      -0.12534083 -0.4629021  1.52823000 #> Neuveville    0.34109514 -0.8458178  1.04687165 #> Porrentruy   -0.04473114  1.0029812  0.32499084 #> Broye        -0.20957031  0.9388742  0.95013743 #> Glane        -0.07584684  0.9555256  1.84540889 #> Gruyere      -0.17406590  1.0769276  0.80852222 #> Sarine        0.48706293  0.9876863  1.28186031 #> Veveyse      -0.21675238  1.0104124  1.24699185 #> Aigle        -0.10911693 -0.6583181 -0.49672411 #> Aubonne      -0.68437504 -0.8402563 -0.52979298 #> Avenches     -0.03638406 -0.7941117  0.04684235 #> Cossonay     -0.63417597 -0.9062500 -0.97644764 #> Echallens    -0.85262069 -0.5223686 -0.56695418 #> Grandson     -0.07196915 -0.9996237  0.34908713 #> Lausanne      1.61585928 -0.2740672 -0.32842180 #> La Vallee     1.11176971 -0.7484136 -0.66355682 #> Lavaux       -0.45759227 -0.8101884 -0.57253943 #> Morges       -0.16023764 -0.8189392 -0.35143678 #> Moudon       -0.76689426 -0.8871886 -0.73359873 #> Nyone         0.01148304 -0.4441114 -1.18020392 #> Orbe         -0.53346789 -0.8042945 -1.34826105 #> Oron         -1.11777160 -1.0181496 -0.21175864 #> Payerne      -0.36904017 -0.8817496  0.37541143 #> Paysd'enhaut -1.13077900 -0.8986374 -0.29968480 #> Rolle        -0.42160714 -0.6023891 -1.03877760 #> Vevey         0.94345222 -0.3409626 -0.46681372 #> Yverdon      -0.32587490 -0.7719262 -0.45767841 #> Conthey      -1.31619000  1.3250097 -0.61688868 #> Entremont    -0.89250420  1.4492843 -0.97170425 #> Herens       -1.23489054  1.2885602 -0.38378811 #> Martigwy     -0.65337979  1.3258772 -0.68175988 #> Monthey      -0.77161554  1.1439436  0.14336145 #> St Maurice   -0.58929096  1.5132175 -1.21362340 #> Sierre       -1.07854088  1.0949088  1.16699564 #> Sion          0.07266005  1.2536309  0.60709606 #> Boudry        0.42781724 -0.9511974  0.51240946 #> La Chauxdfnd  0.80305682 -0.8488623  0.28442301 #> Le Locle      0.63722154 -0.8395794  0.83668414 #> Neuchatel     2.31502030 -0.3320992  0.93658497 #> Val de Ruz   -0.19124613 -1.0328917  0.84358034 #> ValdeTravers  0.26693510 -0.9979172  0.17191080 #> V. De Geneve  3.72546960  1.0799755 -1.35159069 #> Rive Droite   1.02570325  0.9919321 -2.04348421 #> Rive Gauche   1.45927665  1.0609142 -1.96687793 #>  #> $cols #>  #> Loadings: #>                  Factor1 Factor2 Factor3 #> Fertility        -0.512   0.203   0.832  #> Agriculture      -0.774   0.312  -0.129  #> Examination       0.751  -0.423  -0.211  #> Education         0.901          -0.262  #> Catholic         -0.186   0.913   0.220  #> Infant.Mortality                  0.500  #>  #>                Factor1 Factor2 Factor3 #> SS loadings      2.273   1.164   1.120 #> Proportion Var   0.379   0.194   0.187 #> Cumulative Var   0.379   0.573   0.759 #>"},{"path":"/reference/theme_scaffold.html","id":null,"dir":"Reference","previous_headings":"","what":"Scaffolding theme — theme_scaffold","title":"Scaffolding theme — theme_scaffold","text":"Omit cartesian coordinate visual aids.","code":""},{"path":"/reference/theme_scaffold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scaffolding theme — theme_scaffold","text":"","code":"theme_scaffold()  theme_biplot()"},{"path":"/reference/theme_scaffold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scaffolding theme — theme_scaffold","text":"ggplot theme.","code":""},{"path":"/reference/theme_scaffold.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scaffolding theme — theme_scaffold","text":"Geometric data analysis concerns intrinsic geometry data. Analyses often use artificial arbitrary coordinate systems carry useful interpretation instead serve scaffolding, especially graphical elements like axes represent variables (Gardner, 2001). cases, visual aids (tick marks labels, grid lines) used recover coordinates row column markers add unnecessary clutter omitted. partial theme updates current theme removing elements. biplot theme alias included convenience backward compatibility.","code":""},{"path":"/reference/theme_scaffold.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Scaffolding theme — theme_scaffold","text":"Gardner S (2001) Extensions biplot methodology discriminant analysis applications non-parametric principal components. PhD thesis, Stellenbosch University. https://scholar.sun.ac.za/items/279f7958-0b54-43f1-8c75-da652f65db3f","code":""},{"path":"/reference/tidiers.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidiers for 'tbl_ord' objects — tidiers","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"functions return tibbles summarize object class 'tbl_ord'. tidy() output contains one row per artificial coordinate glance() output contains one row whole ordination.","code":""},{"path":"/reference/tidiers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"","code":"# S3 method for class 'tbl_ord' tidy(x, ...)  # S3 method for class 'tbl_ord' glance(x, ...)  # S3 method for class 'tbl_ord' fortify(model, data, ..., .matrix = \"dims\", elements = \"all\")"},{"path":"/reference/tidiers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"x, model object class 'tbl_ord'. ... Additional arguments allowed generics; currently ignored. data Passed generic methods; currently ignored. .matrix character string partially matched (lowercase) several indicators one matrices matrix decomposition used ordination. standard values \"rows\", \"cols\", \"dims\" (). elements Character vector; elements factor render graphical elements. One \"\" (default), \"active\", supplementary element type defined specific class methods (e.g. \"score\" 'factanal', 'lda_ord', 'cancord_ord' \"intraset\" \"interset\" 'cancor_ord').","code":""},{"path":"/reference/tidiers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"tibble.","code":""},{"path":"/reference/tidiers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"Three generics popularized ggplot2 broom packages make use augmentation methods: generics::tidy() method summarizes information model components, artificial coordinates created ordinations. output can passed ggplot2::ggplot() generate scree plots. returned columns name: (name ) coordinate columns extracted model, usually single additional column singular eigen values inertia: multidimensional variance prop_var: proportion inertia quality: cumulative proportion variance generics::glance() method reports information entire model, always treated one broader class ordination models. returned columns rank: rank ordination model, .e. number ordinates n.row,n.col: dimensions decomposed matrix inertia: total inertia ordination prop.var.*: proportion variance first 2 ordinates class: class wrapped model object ggplot2::fortify() method augments collapses row /column data, depending .matrix .element, single tibble, preparation ggplot2::ggplot(). output resembles generics::augment(), though rows output may correspond rows, columns, original data. .matrix passed \"rows\", \"cols\", \"dims\" (), fortify() returns tibble whose fields obtained, order, via get_*(), recover_aug_*(), annotation_*(). tibble assigned \"coordinates\" attribute whose value obtained via get_coord(). facilitates downstream functionality relies coordinates used position aesthetics biplot, particular stat_spantree().","code":""},{"path":[]},{"path":"/reference/tidiers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tidiers for 'tbl_ord' objects — tidiers","text":"","code":"# illustrative ordination: PCA of iris data iris_pca <- ordinate(iris, ~ prcomp(., center = TRUE, scale. = TRUE), seq(4L))  # use `tidy()` to summarize distribution of inertia tidy(iris_pca) #> # A tibble: 4 × 5 #>   name   sdev inertia prop_var quality #>   <fct> <dbl>   <dbl>    <dbl>   <dbl> #> 1 PC1   1.71   435.    0.730     0.730 #> 2 PC2   0.956  136.    0.229     0.958 #> 3 PC3   0.383   21.9   0.0367    0.995 #> 4 PC4   0.144    3.09  0.00518   1     # this facilitates scree plots tidy(iris_pca) %>%   ggplot(aes(x = name, y = prop_var)) +   geom_col() +   scale_y_continuous(labels = scales::percent) +   labs(x = NULL, y = \"Proportion of variance\")   # use `fortify()` to prepare either matrix factor for `ggplot()` fortify(iris_pca, .matrix = \"V\") %>%   ggplot(aes(x = name, y = PC1)) +   geom_col() +   coord_flip() +   labs(x = \"Measurement\")  iris_pca %>%   fortify(.matrix = \"U\") %>%   ggplot(aes(x = PC1, fill = Species)) +   geom_histogram() +   labs(y = NULL) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.  # ... or to prepare both for `ggbiplot()` fortify(iris_pca) #> # A tibble: 154 × 10 #>      PC1     PC2     PC3      PC4 Species .element .matrix name  center scale #>    <dbl>   <dbl>   <dbl>    <dbl> <fct>   <chr>    <chr>   <chr>  <dbl> <dbl> #>  1 -2.26 -0.478   0.127   0.0241  setosa  active   rows    NA        NA    NA #>  2 -2.07  0.672   0.234   0.103   setosa  active   rows    NA        NA    NA #>  3 -2.36  0.341  -0.0441  0.0283  setosa  active   rows    NA        NA    NA #>  4 -2.29  0.595  -0.0910 -0.0657  setosa  active   rows    NA        NA    NA #>  5 -2.38 -0.645  -0.0157 -0.0358  setosa  active   rows    NA        NA    NA #>  6 -2.07 -1.48   -0.0269  0.00659 setosa  active   rows    NA        NA    NA #>  7 -2.44 -0.0475 -0.334  -0.0367  setosa  active   rows    NA        NA    NA #>  8 -2.23 -0.222   0.0884 -0.0245  setosa  active   rows    NA        NA    NA #>  9 -2.33  1.11   -0.145  -0.0268  setosa  active   rows    NA        NA    NA #> 10 -2.18  0.467   0.253  -0.0398  setosa  active   rows    NA        NA    NA #> # ℹ 144 more rows  # use `glance()` to summarize the model as an ordination glance(iris_pca) #> # A tibble: 1 × 7 #>    rank n.row n.col inertia prop.var.1 prop.var.2 class  #>   <int> <int> <int>   <dbl>      <dbl>      <dbl> <chr>  #> 1     4   150     4    596.      0.730      0.229 prcomp # this enables comparisons to other models rbind(   glance(ordinate(subset(iris, Species == \"setosa\"), prcomp, seq(4L))),   glance(ordinate(subset(iris, Species == \"versicolor\"), prcomp, seq(4L))),   glance(ordinate(subset(iris, Species == \"virginica\"), prcomp, seq(4L))) ) #> # A tibble: 3 × 7 #>    rank n.row n.col inertia prop.var.1 prop.var.2 class  #>   <int> <int> <int>   <dbl>      <dbl>      <dbl> <chr>  #> 1     4    50     4    15.2      0.765      0.119 prcomp #> 2     4    50     4    30.6      0.781      0.116 prcomp #> 3     4    50     4    43.5      0.783      0.120 prcomp"},{"path":"/reference/wrap-ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrappers for lossy ordination methods — wrap-ord","title":"Wrappers for lossy ordination methods — wrap-ord","text":"*_ord functions wrap core R functions modifications use 'tbl_ord' methods. parameters hidden user set settings required methods, matrix outputs given row column names used , new '*_ord' S3 class attributes added enable .","code":""},{"path":"/reference/wrap-ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrappers for lossy ordination methods — wrap-ord","text":"","code":"eigen_ord(x, symmetric = isSymmetric.matrix(x))  svd_ord(x, nu = min(dim(x)), nv = min(dim(x)))  cmdscale_ord(d, k = 2, add = FALSE)  cancor_ord(x, y, xcenter = TRUE, ycenter = TRUE, scores = FALSE)"},{"path":"/reference/wrap-ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrappers for lossy ordination methods — wrap-ord","text":"x numeric complex matrix whose spectral decomposition     computed.  Logical matrices coerced numeric. symmetric TRUE, matrix assumed symmetric     (Hermitian complex) lower triangle (diagonal     included) used.  symmetric specified,     isSymmetric(x) used. nu number left  singular vectors computed.     must 0 n = nrow(x). nv number right singular vectors computed.     must 0 p = ncol(x). d distance structure returned dist     full symmetric matrix containing dissimilarities. k maximum dimension space data     represented ; must \\(\\{1, 2, \\ldots, n-1\\}\\). add logical indicating additive constant \\(c*\\)     computed, added non-diagonal dissimilarities     modified dissimilarities Euclidean. y numeric matrix (\\(n \\times p_2\\)), containing     y coordinates. xcenter logical numeric vector length \\(p_1\\),     describing centering done x values     analysis.  TRUE (default), subtract column means.     FALSE, adjust columns.  Otherwise, vector     values subtracted columns. ycenter analogous xcenter, y values. scores Logical; whether return canonical scores structure correlations.","code":""},{"path":"/reference/wrap-ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrappers for lossy ordination methods — wrap-ord","text":"Objects slightly modified outputs original functions, new '*-ord' classes.","code":""},{"path":"/reference/wrap-ord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrappers for lossy ordination methods — wrap-ord","text":"following table summarizes wrapped functions: default, cancor_ord() returns data stats::cancor(): canonical correlations (cor), canonical coefficients ($xcoef $ycoef), variable means ($xcenter, $ycenter). scores = TRUE, cancor_ord() also returns scores $xscores $yscores calculated (appropriately centered) data coefficients intraset structure correlations $xstructure $ystructure data. modifications inspired cancor() function candisc, though two caveats noted: First, canonical coefficients (hence canonical scores) scaled \\(n - 1\\) compared , though intraset structure correlations . Second, interset structure correlations returned, may obtained conferring inertia unto intraset ones.","code":""},{"path":"/reference/wrap-ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrappers for lossy ordination methods — wrap-ord","text":"","code":"# glass composition data from one furnace glass_banias <- subset(   glass,   Context == \"L.15;B.166\",   select = c(\"SiO2\", \"Na2O\", \"CaO\", \"Al2O3\", \"MgO\", \"K2O\") ) # eigendecomposition of a covariance matrix (glass_cov <- cov(glass_banias)) #>             SiO2       Na2O        CaO    Al2O3         MgO      K2O #> SiO2   2.6155367  0.6093667 -1.2869867 -0.45252 -0.46817333 -0.31149 #> Na2O   0.6093667  0.2559067 -0.3217067 -0.16542 -0.10587333 -0.10726 #> CaO   -1.2869867 -0.3217067  0.7060267  0.24842  0.20559333  0.13220 #> Al2O3 -0.4525200 -0.1654200  0.2484200  0.12716  0.07972000  0.07230 #> MgO   -0.4681733 -0.1058733  0.2055933  0.07972  0.09462667  0.06682 #> K2O   -0.3114900 -0.1072600  0.1322000  0.07230  0.06682000  0.06131 eigen_ord(glass_cov) #> eigen() decomposition #> $values #> [1] 3.617285e+00 1.467376e-01 8.282650e-02 1.360291e-02 1.141672e-04 #> [6] 4.279624e-17 #>  #> $vectors #>              EV1         EV2         EV3         EV4        EV5        EV6 #> SiO2   0.8469970  0.31716695 -0.25837288 -0.11577441  0.2822267  0.1489597 #> Na2O   0.2099520 -0.79170694 -0.10021025 -0.51787194 -0.1385212  0.1780413 #> CaO   -0.4260986  0.04199369 -0.76882445 -0.05663831  0.3233201  0.3432808 #> Al2O3 -0.1556273  0.45906193 -0.08066526 -0.77062798 -0.2878426 -0.2860325 #> MgO   -0.1492104 -0.07286372  0.38010592 -0.30504020  0.8407925 -0.1672273 #> K2O   -0.1023356  0.23408287  0.42558539 -0.16816668 -0.0826960  0.8476385 #>  # singular value decomposition of a data matrix svd_ord(glass_banias) #> $d #> [1] 177.16843535   2.56375788   0.82468871   0.51400398   0.21898181 #> [6]   0.01400983 #>  #> $u #>          SV1          SV2         SV3        SV4        SV5         SV6 #> 1 -0.4114474  0.268953258  0.54464383 -0.4529219  0.4351102  0.25938230 #> 2 -0.4099492  0.124966122  0.51481370  0.3162816 -0.6000110 -0.30206743 #> 3 -0.4097327 -0.103523503 -0.13351247  0.5115444  0.6162163 -0.40271096 #> 4 -0.3914429 -0.815275824 -0.07487103 -0.3907913 -0.1362392 -0.07220201 #> 5 -0.4168814  0.486413365 -0.59131457 -0.3710452 -0.1857274 -0.26036475 #> 6 -0.4095779 -0.007607042 -0.25543255  0.3778329 -0.1337444  0.77865078 #>  #> $v #>               SV1         SV2         SV3          SV4         SV5         SV6 #> SiO2  -0.97757835  0.09992541 -0.16303444  0.046753453 -0.05969843 -0.04500518 #> Na2O  -0.16869103  0.14528933  0.81605152 -0.238508341  0.42108755  0.22426170 #> CaO   -0.11569079 -0.87296399  0.28883998  0.323881874 -0.16853953  0.08840776 #> Al2O3 -0.01665686 -0.29609746 -0.38102381  0.008014293  0.87323378 -0.06533172 #> MgO   -0.03775856 -0.28137368  0.06285458 -0.713218748 -0.10916969 -0.62837365 #> K2O   -0.02822033 -0.19998734 -0.27371758 -0.572086712 -0.12751682  0.73535272 #>  #> attr(,\"class\") #> [1] \"svd_ord\" # classical multidimensional scaling of a distance matrix cmdscale_ord(dist(glass_banias)) #> $points #>             [,1]        [,2] #> [1,] -0.87986198  0.53544035 #> [2,] -0.45244074  0.40907498 #> [3,] -0.08144239 -0.26484655 #> [4,]  3.61567304 -0.04227923 #> [5,] -1.99639680 -0.36657720 #> [6,] -0.20553113 -0.27081236 #>  #> $eig #> [1] 1.808643e+01 7.336881e-01 4.141325e-01 6.801456e-02 5.708361e-04 #> [6] 6.300478e-16 #>  #> $x #>              [,1]        [,2]        [,3]        [,4]       [,5]         [,6] #> [1,] -2.207855556 -1.12728889  0.22354444   6.3455444 -3.2300556 -0.003888889 #> [2,] -1.127288889 -0.87692222  0.03611111   3.3851111 -1.3678889 -0.049122222 #> [3,]  0.223544444  0.03611111 -0.47385556   0.7213444 -0.2278556 -0.279288889 #> [4,]  6.345544444  3.38511111  0.72134444 -26.2322556 14.2529444  1.527311111 #> [5,] -3.230055556 -1.36788889 -0.22785556  14.2529444 -8.5234556 -0.903688889 #> [6,] -0.003888889 -0.04912222 -0.27928889   1.5273111 -0.9036889 -0.291322222 #>  #> $ac #> [1] 0 #>  #> $GOF #> [1] 0.9749924 0.9749924 #>  #> attr(,\"class\") #> [1] \"cmds_ord\"  # canonical correlation analysis with trace components glass_banias_minor <- subset(   glass,   Context == \"L.15;B.166\",   select = c(\"TiO2\", \"FeO\", \"MnO\", \"P2O5\", \"Cl\", \"SO3\") ) # impute half of detection threshold glass_banias_minor$TiO2[[1L]] <- 0.5 cancor_ord(glass_banias, glass_banias_minor) #> $cor #> [1] 1 1 1 1 1 #>  #> $xcoef #>            [,1]       [,2]      [,3]      [,4]      [,5] #> SiO2  -2.296248 -11.369291 -2.825844 -1.997054 -2.879401 #> Na2O   1.035333   3.948798  1.016188  2.099571  2.843217 #> CaO   -1.915708 -13.652940 -3.999884 -2.203852 -3.775547 #> Al2O3  1.133790  11.090690  4.050155  4.884709  4.535237 #> MgO   -7.830795 -31.099321 -8.668147 -6.685554 -6.686017 #>  #> $ycoef #>            [,1]       [,2]        [,3]       [,4]     [,5] #> TiO2  -3.214755  -2.257585   0.6077935  0.8226229 2.960014 #> FeO    6.509558  -1.818302  -3.6350924  2.2052729 0.000000 #> MnO    5.290203   2.278202  -3.6872234 -2.0749981 0.000000 #> P2O5 -14.417571 -17.411690   0.3602733 -4.7270262 0.000000 #> Cl    25.883235   3.745439 -11.0966777 -7.1368602 0.000000 #>  #> $xcenter #>      SiO2      Na2O       CaO     Al2O3       MgO       K2O  #> 70.691667 12.196667  8.383333  1.210000  2.736667  2.045000  #>  #> $ycenter #>      TiO2       FeO       MnO      P2O5        Cl       SO3  #> 0.1933333 0.4300000 0.9666667 0.2700000 0.8100000 0.3483333  #>  #> attr(,\"class\") #> [1] \"cancor_ord\"  # calculate canonical scores and structure correlations glass_cca <-   cancor_ord(glass_banias[, 1:3], glass_banias_minor[, 1:3], scores = TRUE) # scores glass_cca$xscores #>             [,1]         [,2]       [,3] #> [1,]  0.08625757  0.564009626  0.5086737 #> [2,] -0.06325679  0.009686013  0.4449230 #> [3,] -0.31243762 -0.589123478  0.1458326 #> [4,]  0.85114073 -0.156299524 -0.2733283 #> [5,] -0.34697599  0.470284132 -0.6433738 #> [6,] -0.21472789 -0.298556769 -0.1827271 # intraset correlations glass_cca$xstructure #>            [,1]       [,2]       [,3] #> SiO2 -0.9261925  0.3749912 0.03935800 #> Na2O -0.5467957  0.5715073 0.61187732 #> CaO   0.7639885 -0.6435255 0.04686735 # interset correlations glass_cca$xstructure %*% diag(glass_cca$cor) #>            [,1]       [,2]       [,3] #> SiO2 -0.9261925  0.3594308 0.02748688 #> Na2O -0.5467957  0.5477923 0.42732349 #> CaO   0.7639885 -0.6168220 0.03273126"},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"wrapper-defaults-0-2-0","dir":"Changelog","previous_headings":"infrastructure and standards","what":"wrapper defaults","title":"ordr 0.2.0","text":"Previously, lda_ord() mimicked MASS::lda() defaulting retrieval parameters ret.x ret.grouping FALSE. important analysis especially biplots, now default TRUE.","code":""},{"path":"/news/index.html","id":"unit-tests-0-2-0","dir":"Changelog","previous_headings":"infrastructure and standards","what":"unit tests","title":"ordr 0.2.0","text":"Unit tests written ggproto shortcuts, though many subsequently migrated gggda.","code":""},{"path":[]},{"path":"/news/index.html","id":"axis-harmonizers-0-2-0","dir":"Changelog","previous_headings":"upgrades to the biplot chassis","what":"axis harmonizers","title":"ordr 0.2.0","text":"Multiple harmonizers now available scaling secondary axes. recommended Gower, Gardner–Lubbe, Le Roux (2011) default, user can still specify numeric scale instead.","code":""},{"path":"/news/index.html","id":"gda-geared-coordinate-systems-0-2-0","dir":"Changelog","previous_headings":"upgrades to the biplot chassis","what":"GDA-geared coordinate systems","title":"ordr 0.2.0","text":"new ‘scaffold’ coordinate system fixes aspect ratio 1 (required biplots) provides user control ratio plotting window dimensions (defaults 1, recommended biplots). builds ‘rect’ coordinate system originally developed ordr migrated gggda.","code":""},{"path":"/news/index.html","id":"scaffold-theme-0-2-0","dir":"Changelog","previous_headings":"upgrades to the biplot chassis","what":"scaffold theme","title":"ordr 0.2.0","text":"‘biplot’ theme renamed ‘scaffold’, alias backward compatibility.","code":""},{"path":"/news/index.html","id":"standardized-and-restrictive-elements-parameter-breaking-change-0-2-0","dir":"Changelog","previous_headings":"upgrades to the biplot chassis","what":"standardized and restrictive elements parameter (breaking change)","title":"ordr 0.2.0","text":"elements parameter now standardized across statistical transformations (code generation process) accepts restrictive options: value argument-matched \"active\", \"score\", \"structure\"; options may expand additional supplementary elements introduced. Moreover, former default \"\" longer accepted, forecloses trick passing element type aesthetic, e.g. size = .element == \"active\", used several examples.","code":""},{"path":"/news/index.html","id":"up-or-downgrades-to-existing-plot-layers-0-2-0","dir":"Changelog","previous_headings":"","what":"up( or down)grades to existing plot layers","title":"ordr 0.2.0","text":"statistical transformations geometric constructions migrated gggda. changes made prior migration effects since gggda now imported dependency.","code":""},{"path":"/news/index.html","id":"combined-vector-and-radiating-text-geom-breaking-change-0-2-0","dir":"Changelog","previous_headings":"up( or down)grades to existing plot layers","what":"combined vector and radiating text geom (breaking change)","title":"ordr 0.2.0","text":"‘vector’ ‘text_radiate’ geoms combined. shortcut geom_text_radiate() deprecated, geom_vector() generates radiating labels default.","code":""},{"path":"/news/index.html","id":"debugged-axis-geom-0-2-0","dir":"Changelog","previous_headings":"up( or down)grades to existing plot layers","what":"debugged axis geom","title":"ordr 0.2.0","text":"‘axis’ ‘isoline’ geoms hit trouble one points lay origin (x^2 + y^2 == 0). cases now removed setup_data().","code":""},{"path":"/news/index.html","id":"reconciliation-of-summary-functions-0-2-0","dir":"Changelog","previous_headings":"up( or down)grades to existing plot layers","what":"reconciliation of summary functions","title":"ordr 0.2.0","text":"‘center’ ‘star’ stats now follow ‘summary’ stat convention using fun, fun.center deprecated. Additionally, fun.ord accepts function summarizes columns matrix, accommodates summaries like depth median decompose along orthogonal axes.","code":""},{"path":"/news/index.html","id":"revamped-handling-of-secondary-aesthetics-breaking-change-0-2-0","dir":"Changelog","previous_headings":"up( or down)grades to existing plot layers","what":"revamped handling of secondary aesthetics (breaking change)","title":"ordr 0.2.0","text":"Previously, underscore-separated parameters like label_colour used specify secondary aesthetics, .e. aesthetics graphical objects considered “primary” layer. behavior debugged mimicking use period-separated parameters like label.colour ggplot2 v3.5.1, except new bagplot geom, behavior based geom_boxplot() current development version ggplot2. induces breaking changes due renaming , removal , parameters.","code":""},{"path":[]},{"path":"/news/index.html","id":"addition-geom-0-2-0","dir":"Changelog","previous_headings":"new plot layers (retained in ordr)","what":"addition geom","title":"ordr 0.2.0","text":"new ‘interpolation’ geometric element layer renders either two methods vector addition interpolate position—existing ordination biplot—new row column original data matrix.","code":""},{"path":"/news/index.html","id":"referential-stats-0-2-0","dir":"Changelog","previous_headings":"new plot layers (retained in ordr)","what":"referential stats","title":"ordr 0.2.0","text":"new statistical transformation serves parent specific “referential stats”, meaning depend non-inherited (setting, positional) data transform inherited data. reference data passed new referent parameter. new stat coupled additional LayerRef class enables ggplot_add() pass inherited positional aesthetics $setup_params(). Biplot-specific stat_*_*() shortcuts accept additional argument types referent result opposite matrix factor used reference data.","code":""},{"path":"/news/index.html","id":"projection-stat-0-2-0","dir":"Changelog","previous_headings":"new plot layers (retained in ordr)","what":"projection stat","title":"ordr 0.2.0","text":"‘projection’ referential stat prepares segment endpoints x,y positions projections axes defined reference data. natural graphical element predictive biplots ordination models continuous data.","code":""},{"path":[]},{"path":"/news/index.html","id":"rule-stat-0-2-0","dir":"Changelog","previous_headings":"new plot layers (migrated to gggda)","what":"rule stat","title":"ordr 0.2.0","text":"new ‘rule’ statistical transformation computes additional position aesthetics ‘axis’ geom uses limit offset axes. stat referential expects set functions compute limits lower upper along axes yintercept xintercept associated offset axes. ‘axis’ geom preprocesses aesthetics rule endpoints xmin,ymin,xmax,ymax offset vectors xend,yend force plotting window contain limited axis segments , axes remain lines, offsets centered.","code":""},{"path":"/news/index.html","id":"peel-stat-0-2-0","dir":"Changelog","previous_headings":"new plot layers (migrated to gggda)","what":"peel stat","title":"ordr 0.2.0","text":"new ‘peel’ statistical transformation computes nested convex hulls containing specified fractions data.","code":""},{"path":"/news/index.html","id":"depth-stat-0-2-0","dir":"Changelog","previous_headings":"new plot layers (migrated to gggda)","what":"depth stat","title":"ordr 0.2.0","text":"new ‘depth’ statistical transformation estimates depth across grid paired GeomContour produce depth contours, can used plot alpha bags.","code":""},{"path":"/news/index.html","id":"adapted-density-stat--geom-0-2-0","dir":"Changelog","previous_headings":"new plot layers (migrated to gggda)","what":"adapted density stat & geom","title":"ordr 0.2.0","text":"Aided element standardization, classic density_2d statistical transformation geometric construction adapted biplots. Currently, source code generation respect fixed parameters passed layer() stat_*() geom_*() shortcuts; consequence, contour = TRUE must manually passed geom_*_density_2d().","code":""},{"path":"/news/index.html","id":"ordr-012","dir":"Changelog","previous_headings":"","what":"ordr 0.1.2","title":"ordr 0.1.2","text":"CRAN release: 2025-07-02 patch prepares upcoming ggplot2 release overhauls aesthetic mappings (#82). changes user experience anticipated.","code":""},{"path":"/news/index.html","id":"ordr-011","dir":"Changelog","previous_headings":"","what":"ordr 0.1.1","title":"ordr 0.1.1","text":"CRAN release: 2022-10-20","code":""},{"path":"/news/index.html","id":"linewidth-aesthetic-breaking-change-0-1-1","dir":"Changelog","previous_headings":"","what":"linewidth aesthetic (breaking change)","title":"ordr 0.1.1","text":"upcoming release ggplot2 controls stroke width using new linewidth aesthetic rather size. ordr release adapts change internally GeomUnitCircle updating row column layers automatically adapted ggplot2. (#50)","code":""},{"path":"/news/index.html","id":"class-eigen-0-1-1","dir":"Changelog","previous_headings":"","what":"class ‘eigen’","title":"ordr 0.1.1","text":"Methods added ‘eigen’ class returned eigen(), internal eigen_ord() function methods updated accordingly.","code":""},{"path":"/news/index.html","id":"list-tidiers-breaking-change-0-1-1","dir":"Changelog","previous_headings":"","what":"list tidiers (breaking change)","title":"ordr 0.1.1","text":"previous version extended ‘list’ method broom’s tidy() glance() functions recognize output cmdscale() cancor(). spun nascent helper package, broom.list, reduce size prevent attachment warnings.","code":""},{"path":"/news/index.html","id":"ordr-010","dir":"Changelog","previous_headings":"","what":"ordr 0.1.0","title":"ordr 0.1.0","text":"CRAN release: 2022-08-18 addition minor changes, following substantive changes made v0.0.2:","code":""},{"path":"/news/index.html","id":"augmentation-0-1-0","dir":"Changelog","previous_headings":"","what":"augmentation","title":"ordr 0.1.0","text":"column names augment_ord() tidy() outputs longer prefixed periods.","code":""},{"path":"/news/index.html","id":"list-tidiers-0-1-0","dir":"Changelog","previous_headings":"","what":"list tidiers","title":"ordr 0.1.0","text":"new list tidier cancor() output introduced.","code":""},{"path":"/news/index.html","id":"negation-0-1-0","dir":"Changelog","previous_headings":"","what":"negation","title":"ordr 0.1.0","text":"Tools negate subset artificial dimensions, adapted sandboxed set alignment tools, provided.","code":""},{"path":"/news/index.html","id":"convenience-function-0-1-0","dir":"Changelog","previous_headings":"","what":"convenience function","title":"ordr 0.1.0","text":"ordinate() function now generic methods four data classes.","code":""},{"path":"/news/index.html","id":"ggbiplot-0-1-0","dir":"Changelog","previous_headings":"","what":"ggbiplot","title":"ordr 0.1.0","text":"logical prediction parameter replaced character-valued axis.type, based ax.type parameter used UBbipl (Gower, Gardner–Lubbe, & le Roux, 2011).","code":""},{"path":"/news/index.html","id":"tests-0-1-0","dir":"Changelog","previous_headings":"","what":"tests","title":"ordr 0.1.0","text":"Unit tests overhauled remove contexts, omit ad hoc tests, standardize method tests, cover additional methods.","code":""},{"path":"/news/index.html","id":"documentation-0-1-0","dir":"Changelog","previous_headings":"","what":"documentation","title":"ordr 0.1.0","text":"term ‘accessor’, used refer S3 class methods recover standardized model components, changed ‘recoverer’.","code":""},{"path":"/news/index.html","id":"ordr-002","dir":"Changelog","previous_headings":"","what":"ordr 0.0.2","title":"ordr 0.0.2","text":"pre-release makes several substantive changes preparation CRAN submission.","code":""},{"path":"/news/index.html","id":"element-types-0-0-2","dir":"Changelog","previous_headings":"","what":"element types","title":"ordr 0.0.2","text":"Annotation active supplementary elements standardized: character augmentation .element replaces logical .supplement, class methods either omit entirely (retrieved elements active) include row column augmentation (either includes supplementary elements). value .element either ‘active’ type supplement, e.g. ‘score’.","code":""},{"path":"/news/index.html","id":"dependencies-0-0-2","dir":"Changelog","previous_headings":"","what":"dependencies","title":"ordr 0.0.2","text":"Extraneous dependencies dropped reduce overhead. takes two forms: Methods classes specialty (lower-priority) packages (candisc ca) moved ordr.extra replaced methods classes higher-priority packages (stats MASS). One-uses specialty packages examples vignettes replaced.","code":""},{"path":"/news/index.html","id":"documentation-0-0-2","dir":"Changelog","previous_headings":"","what":"documentation","title":"ordr 0.0.2","text":"Description field DESCRIPTION expanded documentation throughout slightly revised, including new references.","code":""},{"path":"/news/index.html","id":"ordr-001","dir":"Changelog","previous_headings":"","what":"ordr 0.0.1","title":"ordr 0.0.1","text":"pre-release anticipation first CRAN submission. Upgrades pre-release CRAN submission focus addressing issues.","code":""}]
